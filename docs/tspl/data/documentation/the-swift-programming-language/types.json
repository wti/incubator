{"metadata":{"title":"Types"},"sections":[],"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Types","interfaceLanguage":"swift"},"schemaVersion":{"patch":0,"major":0,"minor":3},"kind":"article","hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"abstract":[{"type":"text","text":"Use built-in named and compound types."}],"primaryContentSections":[{"kind":"content","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In Swift, there are two kinds of types: named types and compound types."},{"text":" ","type":"text"},{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"text":"named type","type":"text"}]},{"type":"text","text":" is a type that can be given a particular name when it’s defined."},{"text":" ","type":"text"},{"type":"text","text":"Named types include classes, structures, enumerations, and protocols."},{"text":" ","type":"text"},{"text":"For example,","type":"text"},{"text":" ","type":"text"},{"text":"instances of a user-defined class named ","type":"text"},{"type":"codeVoice","code":"MyClass"},{"type":"text","text":" have the type "},{"type":"codeVoice","code":"MyClass"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"In addition to user-defined named types,"},{"type":"text","text":" "},{"text":"the Swift standard library defines many commonly used named types,","type":"text"},{"text":" ","type":"text"},{"text":"including those that represent arrays, dictionaries, and optional values.","type":"text"}]},{"inlineContent":[{"text":"Data types that are normally considered basic or primitive in other languages —","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"such as types that represent numbers, characters, and strings —"},{"type":"text","text":" "},{"text":"are actually named types,","type":"text"},{"text":" ","type":"text"},{"text":"defined and implemented in the Swift standard library using structures.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Because they’re named types,"},{"type":"text","text":" "},{"text":"you can extend their behavior to suit the needs of your program,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"using an extension declaration,"},{"type":"text","text":" "},{"text":"discussed in ","type":"text"},{"isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Extensions","type":"reference"},{"type":"text","text":" and "},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Extension-Declaration"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"compound type"}]},{"text":" is a type without a name, defined in the Swift language itself.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"There are two compound types: function types and tuple types."},{"text":" ","type":"text"},{"text":"A compound type may contain named types and other compound types.","type":"text"},{"type":"text","text":" "},{"text":"For example, the tuple type ","type":"text"},{"type":"codeVoice","code":"(Int, (Int, Int))"},{"type":"text","text":" contains two elements:"},{"type":"text","text":" "},{"text":"The first is the named type ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"and the second is another compound type "},{"type":"codeVoice","code":"(Int, Int)"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can put parentheses around a named type or a compound type."},{"type":"text","text":" "},{"text":"However, adding parentheses around a type doesn’t have any effect.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For example, "},{"code":"(Int)","type":"codeVoice"},{"text":" is equivalent to ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":"."}]},{"inlineContent":[{"text":"This chapter discusses the types defined in the Swift language itself","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and describes the type inference behavior of Swift."}],"type":"paragraph"},{"type":"aside","name":"Grammar of a type","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"function-type"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"array-type","type":"text"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"dictionary-type"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" → "},{"inlineContent":[{"text":"type-identifier","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-type"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"optional-type"}],"type":"emphasis"},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"implicitly-unwrapped-optional-type","type":"text"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]},{"text":" → ","type":"text"},{"inlineContent":[{"text":"protocol-composition-type","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"inlineContent":[{"text":"type","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"opaque-type"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"boxed-protocol-type"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"metatype-type"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"any-type"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"self-type"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"("}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":")"}]}]}]},{"anchor":"Type-Annotation","text":"Type Annotation","type":"heading","level":2},{"inlineContent":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type annotation"}]},{"text":" explicitly specifies the type of a variable or expression.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Type annotations begin with a colon ("},{"type":"codeVoice","code":":"},{"type":"text","text":") and end with a type,"},{"type":"text","text":" "},{"type":"text","text":"as the following examples show:"}],"type":"paragraph"},{"code":["let someTuple: (Double, Double) = (3.14159, 2.71828)","func someFunction(a: Int) { \/* ... *\/ }"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"In the first example,"},{"type":"text","text":" "},{"type":"text","text":"the expression "},{"code":"someTuple","type":"codeVoice"},{"type":"text","text":" is specified to have the tuple type "},{"type":"codeVoice","code":"(Double, Double)"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"In the second example,"},{"text":" ","type":"text"},{"text":"the parameter ","type":"text"},{"code":"a","type":"codeVoice"},{"text":" to the function ","type":"text"},{"type":"codeVoice","code":"someFunction"},{"type":"text","text":" is specified to have the type "},{"code":"Int","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Type annotations can contain an optional list of type attributes before the type."}],"type":"paragraph"},{"name":"Grammar of a type annotation","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"inlineContent":[{"text":"type-annotation","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":":"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"attributes"}],"type":"emphasis"},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"text":"type","type":"text"}],"type":"emphasis"}],"type":"paragraph"}],"style":"note","type":"aside"},{"level":2,"text":"Type Identifier","type":"heading","anchor":"Type-Identifier"},{"inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type identifier"}]},{"text":" refers to either a named type","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"or a type alias of a named or compound type."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Most of the time, a type identifier directly refers to a named type"},{"type":"text","text":" "},{"type":"text","text":"with the same name as the identifier."},{"text":" ","type":"text"},{"type":"text","text":"For example, "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" is a type identifier that directly refers to the named type "},{"code":"Int","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and the type identifier "},{"code":"Dictionary<String, Int>","type":"codeVoice"},{"text":" directly refers","type":"text"},{"type":"text","text":" "},{"text":"to the named type ","type":"text"},{"code":"Dictionary<String, Int>","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"There are two cases in which a type identifier doesn’t refer to a type with the same name.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"In the first case, a type identifier refers to a type alias of a named or compound type."},{"type":"text","text":" "},{"type":"text","text":"For instance, in the example below,"},{"type":"text","text":" "},{"type":"text","text":"the use of "},{"code":"Point","type":"codeVoice"},{"text":" in the type annotation refers to the tuple type ","type":"text"},{"code":"(Int, Int)","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["typealias Point = (Int, Int)","let origin: Point = (0, 0)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the second case, a type identifier uses dot ("},{"type":"codeVoice","code":"."},{"text":") syntax to refer to named types","type":"text"},{"type":"text","text":" "},{"text":"declared in other modules or nested within other types.","type":"text"},{"text":" ","type":"text"},{"text":"For example, the type identifier in the following code references the named type ","type":"text"},{"type":"codeVoice","code":"MyType"},{"type":"text","text":" "},{"type":"text","text":"that’s declared in the "},{"code":"ExampleModule","type":"codeVoice"},{"type":"text","text":" module."}]},{"syntax":"swift","type":"codeListing","code":["var someValue: ExampleModule.MyType"]},{"style":"note","type":"aside","name":"Grammar of a type identifier","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"type-identifier","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"type-name","type":"text"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"generic-argument-clause"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"text":"type-name","type":"text"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"generic-argument-clause"}],"type":"emphasis"},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":"."}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-identifier"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"type-name"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"text":"identifier","type":"text"}],"type":"emphasis"}]}]},{"anchor":"Tuple-Type","level":2,"text":"Tuple Type","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"A ","type":"text"},{"inlineContent":[{"type":"text","text":"tuple type"}],"type":"emphasis"},{"type":"text","text":" is a comma-separated list of types, enclosed in parentheses."}]},{"inlineContent":[{"type":"text","text":"You can use a tuple type as the return type of a function"},{"text":" ","type":"text"},{"text":"to enable the function to return a single tuple containing multiple values.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"You can also name the elements of a tuple type and use those names to refer to"},{"text":" ","type":"text"},{"text":"the values of the individual elements. An element name consists of an identifier","type":"text"},{"type":"text","text":" "},{"type":"text","text":"followed immediately by a colon (:). For an example that demonstrates both of"},{"text":" ","type":"text"},{"text":"these features, see ","type":"text"},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#Functions-with-Multiple-Return-Values","type":"reference","isActive":true},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"When an element of a tuple type has a name,"},{"type":"text","text":" "},{"type":"text","text":"that name is part of the type."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["var someTuple = (top: 10, bottom: 12)  \/\/ someTuple is of type (top: Int, bottom: Int)","someTuple = (top: 4, bottom: 42) \/\/ OK: names match","someTuple = (9, 99)              \/\/ OK: names are inferred","someTuple = (left: 5, right: 5)  \/\/ Error: names don't match"]},{"inlineContent":[{"text":"All tuple types contain two or more types,","type":"text"},{"type":"text","text":" "},{"text":"except for ","type":"text"},{"type":"codeVoice","code":"Void"},{"type":"text","text":" which is a type alias for the empty tuple type, "},{"code":"()","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"aside","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-type"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"code":"(","type":"codeVoice"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":")"}],"type":"strong"},{"type":"text","text":" | "},{"type":"strong","inlineContent":[{"code":"(","type":"codeVoice"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"tuple-type-element"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":",","type":"codeVoice"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-type-element-list"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":")"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"inlineContent":[{"text":"tuple-type-element-list","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-type-element"}]},{"text":" | ","type":"text"},{"inlineContent":[{"type":"text","text":"tuple-type-element"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"code":",","type":"codeVoice"}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"tuple-type-element-list","type":"text"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"tuple-type-element"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"element-name"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"type-annotation"}],"type":"emphasis"},{"type":"text","text":" | "},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"element-name"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier"}]}]}],"style":"note","name":"Grammar of a tuple type"},{"anchor":"Function-Type","type":"heading","text":"Function Type","level":2},{"type":"paragraph","inlineContent":[{"text":"A ","type":"text"},{"inlineContent":[{"text":"function type","type":"text"}],"type":"emphasis"},{"type":"text","text":" represents the type of a function, method, or closure"},{"type":"text","text":" "},{"type":"text","text":"and consists of a parameter and return type separated by an arrow ("},{"type":"codeVoice","code":"->"},{"type":"text","text":"):"}]},{"type":"codeListing","syntax":"swift","code":["(<#parameter type#>) -> <#return type#>"]},{"inlineContent":[{"text":"The ","type":"text"},{"inlineContent":[{"text":"parameter type","type":"text"}],"type":"emphasis"},{"text":" is comma-separated list of types.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Because the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"return type"}]},{"text":" can be a tuple type,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"function types support functions and methods"},{"text":" ","type":"text"},{"text":"that return multiple values.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"A parameter of the function type ","type":"text"},{"code":"() -> T","type":"codeVoice"},{"type":"text","text":" "},{"text":"(where ","type":"text"},{"type":"codeVoice","code":"T"},{"text":" is any type)","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"can apply the "},{"type":"codeVoice","code":"autoclosure"},{"text":" attribute","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"to implicitly create a closure at its call sites."},{"type":"text","text":" "},{"type":"text","text":"This provides a syntactically convenient way"},{"text":" ","type":"text"},{"text":"to defer the evaluation of an expression","type":"text"},{"type":"text","text":" "},{"text":"without needing to write an explicit closure","type":"text"},{"type":"text","text":" "},{"text":"when you call the function.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For an example of an autoclosure function type parameter,"},{"text":" ","type":"text"},{"type":"text","text":"see "},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Autoclosures","isActive":true},{"type":"text","text":"."}]},{"inlineContent":[{"text":"A function type can have variadic parameters in its ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"parameter type","type":"text"}]},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Syntactically,"},{"type":"text","text":" "},{"type":"text","text":"a variadic parameter consists of a base type name followed immediately by three dots ("},{"code":"...","type":"codeVoice"},{"text":"),","type":"text"},{"type":"text","text":" "},{"type":"text","text":"as in "},{"code":"Int...","type":"codeVoice"},{"text":". A variadic parameter is treated as an array that contains elements","type":"text"},{"text":" ","type":"text"},{"text":"of the base type name. For instance, the variadic parameter ","type":"text"},{"code":"Int...","type":"codeVoice"},{"type":"text","text":" is treated"},{"type":"text","text":" "},{"type":"text","text":"as "},{"code":"[Int]","type":"codeVoice"},{"type":"text","text":". For an example that uses a variadic parameter,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#Variadic-Parameters","type":"reference","isActive":true},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"To specify an in-out parameter, prefix the parameter type with the "},{"code":"inout","type":"codeVoice"},{"type":"text","text":" keyword."},{"text":" ","type":"text"},{"type":"text","text":"You can’t mark a variadic parameter or a return type with the "},{"type":"codeVoice","code":"inout"},{"type":"text","text":" keyword."},{"type":"text","text":" "},{"type":"text","text":"In-out parameters are discussed in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#In-Out-Parameters"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a function type has only one parameter"},{"text":" ","type":"text"},{"text":"and that parameter’s type is a tuple type,","type":"text"},{"text":" ","type":"text"},{"text":"then the tuple type must be parenthesized when writing the function’s type.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"codeVoice","code":"((Int, Int)) -> Void"},{"type":"text","text":" "},{"type":"text","text":"is the type of a function that takes a single parameter"},{"type":"text","text":" "},{"type":"text","text":"of the tuple type "},{"code":"(Int, Int)","type":"codeVoice"},{"type":"text","text":" "},{"text":"and doesn’t return any value.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"In contrast, without parentheses,"},{"text":" ","type":"text"},{"code":"(Int, Int) -> Void","type":"codeVoice"},{"type":"text","text":" is the type"},{"type":"text","text":" "},{"type":"text","text":"of a function that takes two "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" parameters"},{"text":" ","type":"text"},{"type":"text","text":"and doesn’t return any value."},{"type":"text","text":" "},{"type":"text","text":"Likewise, because "},{"code":"Void","type":"codeVoice"},{"type":"text","text":" is a type alias for "},{"code":"()","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"the function type ","type":"text"},{"code":"(Void) -> Void","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"is the same as "},{"code":"(()) -> ()","type":"codeVoice"},{"text":" —","type":"text"},{"text":" ","type":"text"},{"text":"a function that takes a single argument that’s an empty tuple.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"These types aren’t the same as "},{"code":"() -> ()","type":"codeVoice"},{"type":"text","text":" —"},{"type":"text","text":" "},{"type":"text","text":"a function that takes no arguments."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Argument names in functions and methods"},{"text":" ","type":"text"},{"text":"aren’t part of the corresponding function type.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For example:"}]},{"type":"codeListing","code":["func someFunction(left: Int, right: Int) {}","func anotherFunction(left: Int, right: Int) {}","func functionWithDifferentLabels(top: Int, bottom: Int) {}","","var f = someFunction \/\/ The type of f is (Int, Int) -> Void, not (left: Int, right: Int) -> Void.","f = anotherFunction              \/\/ OK","f = functionWithDifferentLabels  \/\/ OK","","func functionWithDifferentArgumentTypes(left: Int, right: String) {}","f = functionWithDifferentArgumentTypes     \/\/ Error","","func functionWithDifferentNumberOfArguments(left: Int, right: Int, top: Int) {}","f = functionWithDifferentNumberOfArguments \/\/ Error"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Because argument labels aren’t part of a function’s type,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"you omit them when writing a function type."}]},{"type":"codeListing","code":["var operation: (lhs: Int, rhs: Int) -> Int     \/\/ Error","var operation: (_ lhs: Int, _ rhs: Int) -> Int \/\/ OK","var operation: (Int, Int) -> Int               \/\/ OK"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"If a function type includes more than a single arrow (","type":"text"},{"code":"->","type":"codeVoice"},{"text":"),","type":"text"},{"text":" ","type":"text"},{"text":"the function types are grouped from right to left.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"text":" ","type":"text"},{"type":"text","text":"the function type "},{"code":"(Int) -> (Int) -> Int","type":"codeVoice"},{"type":"text","text":" is understood as "},{"code":"(Int) -> ((Int) -> Int)","type":"codeVoice"},{"text":" —","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"that is, a function that takes an "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" and returns"},{"type":"text","text":" "},{"type":"text","text":"another function that takes and returns an "},{"type":"codeVoice","code":"Int"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Function types for functions"},{"type":"text","text":" "},{"type":"text","text":"that can throw or rethrow an error must be marked with the "},{"code":"throws","type":"codeVoice"},{"type":"text","text":" keyword."},{"text":" ","type":"text"},{"text":"The ","type":"text"},{"type":"codeVoice","code":"throws"},{"type":"text","text":" keyword is part of a function’s type,"},{"text":" ","type":"text"},{"text":"and nonthrowing functions are subtypes of throwing functions.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"As a result, you can use a nonthrowing function in the same places as a throwing one."},{"text":" ","type":"text"},{"text":"Throwing and rethrowing functions are described in","type":"text"},{"type":"text","text":" "},{"isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Throwing-Functions-and-Methods","type":"reference"},{"type":"text","text":" "},{"type":"text","text":"and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Rethrowing-Functions-and-Methods"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Function types for asynchronous functions"},{"type":"text","text":" "},{"text":"must be marked with the ","type":"text"},{"code":"async","type":"codeVoice"},{"text":" keyword.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The "},{"type":"codeVoice","code":"async"},{"type":"text","text":" keyword is part of a function’s type,"},{"text":" ","type":"text"},{"type":"text","text":"and synchronous functions are subtypes of asynchronous functions."},{"text":" ","type":"text"},{"type":"text","text":"As a result, you can use a synchronous function"},{"type":"text","text":" "},{"type":"text","text":"in the same places as an asynchronous one."},{"text":" ","type":"text"},{"type":"text","text":"For information about asynchronous functions,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Asynchronous-Functions-and-Methods","isActive":true,"type":"reference"},{"text":".","type":"text"}]},{"level":3,"anchor":"Restrictions-for-Nonescaping-Closures","type":"heading","text":"Restrictions for Nonescaping Closures"},{"type":"paragraph","inlineContent":[{"text":"A parameter that’s a nonescaping function","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"can’t be stored in a property, variable, or constant of type "},{"code":"Any","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"because that might allow the value to escape."}]},{"type":"paragraph","inlineContent":[{"text":"A parameter that’s a nonescaping function","type":"text"},{"type":"text","text":" "},{"text":"can’t be passed as an argument to another nonescaping function parameter.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"This restriction helps Swift perform"},{"type":"text","text":" "},{"text":"more of its checks for conflicting access to memory","type":"text"},{"type":"text","text":" "},{"text":"at compile time instead of at runtime.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"code":["let external: (() -> Void) -> Void = { _ in () }","func takesTwoFunctions(first: (() -> Void) -> Void, second: (() -> Void) -> Void) {","    first { first {} }       \/\/ Error","    second { second {}  }    \/\/ Error","","    first { second {} }      \/\/ Error","    second { first {} }      \/\/ Error","","    first { external {} }    \/\/ OK","    external { first {} }    \/\/ OK","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"In the code above,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"both of the parameters to "},{"type":"codeVoice","code":"takesTwoFunctions(first:second:)"},{"type":"text","text":" are functions."},{"text":" ","type":"text"},{"type":"text","text":"Neither parameter is marked "},{"code":"@escaping","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"so they’re both nonescaping as a result.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The four function calls marked “Error” in the example above"},{"type":"text","text":" "},{"text":"cause compiler errors.","type":"text"},{"text":" ","type":"text"},{"text":"Because the ","type":"text"},{"type":"codeVoice","code":"first"},{"type":"text","text":" and "},{"code":"second","type":"codeVoice"},{"text":" parameters","type":"text"},{"text":" ","type":"text"},{"text":"are nonescaping functions,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"they can’t be passed as arguments to another nonescaping function parameter."},{"text":" ","type":"text"},{"type":"text","text":"In contrast,"},{"text":" ","type":"text"},{"text":"the two function calls marked “OK” don’t cause a compiler error.","type":"text"},{"type":"text","text":" "},{"text":"These function calls don’t violate the restriction","type":"text"},{"text":" ","type":"text"},{"text":"because ","type":"text"},{"type":"codeVoice","code":"external"},{"type":"text","text":" isn’t one of the parameters of "},{"type":"codeVoice","code":"takesTwoFunctions(first:second:)"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"If you need to avoid this restriction, mark one of the parameters as escaping,","type":"text"},{"text":" ","type":"text"},{"text":"or temporarily convert one of the nonescaping function parameters to an escaping function","type":"text"},{"type":"text","text":" "},{"text":"by using the ","type":"text"},{"code":"withoutActuallyEscaping(_:do:)","type":"codeVoice"},{"text":" function.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For information about avoiding conflicting access to memory,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/MemorySafety"},{"text":".","type":"text"}],"type":"paragraph"},{"name":"Grammar of a function type","type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"function-type","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"attributes"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"function-type-argument-clause","type":"text"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":"async","type":"codeVoice"}]},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":"throws","type":"codeVoice"}]},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"->"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"function-type-argument-clause"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"code":"(","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":")","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"function-type-argument-clause"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"("}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"function-type-argument-list","type":"text"}]},{"text":" ","type":"text"},{"inlineContent":[{"code":"...","type":"codeVoice"}],"type":"strong"},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"code":")","type":"codeVoice"}],"type":"strong"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"function-type-argument-list"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"function-type-argument","type":"text"}]},{"text":" | ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"function-type-argument"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":","}]},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"function-type-argument-list"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"function-type-argument","type":"text"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"attributes"}],"type":"emphasis"},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"parameter-modifier","type":"text"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]},{"text":" | ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"argument-label","type":"text"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"type-annotation"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"argument-label"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"identifier","type":"text"}]}]}]},{"type":"heading","anchor":"Array-Type","text":"Array Type","level":2},{"type":"paragraph","inlineContent":[{"text":"The Swift language provides the following syntactic sugar for the Swift standard library","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"Array<Element>"},{"text":" type:","type":"text"}]},{"code":["[<#type#>]"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"In other words, the following two declarations are equivalent:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let someArray: Array<String> = [\"Alex\", \"Brian\", \"Dave\"]","let someArray: [String] = [\"Alex\", \"Brian\", \"Dave\"]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In both cases, the constant "},{"type":"codeVoice","code":"someArray"},{"text":" ","type":"text"},{"text":"is declared as an array of strings. The elements of an array can be accessed","type":"text"},{"type":"text","text":" "},{"text":"through subscripting by specifying a valid index value in square brackets:","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"someArray[0]"},{"type":"text","text":" refers to the element at index 0, "},{"code":"\"Alex\"","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"text":"You can create multidimensional arrays by nesting pairs of square brackets,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"where the name of the base type of the elements is contained in the innermost"},{"type":"text","text":" "},{"text":"pair of square brackets.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For example, you can create"},{"type":"text","text":" "},{"text":"a three-dimensional array of integers using three sets of square brackets:","type":"text"}]},{"code":["var array3D: [[[Int]]] = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"When accessing the elements in a multidimensional array,"},{"text":" ","type":"text"},{"type":"text","text":"the left-most subscript index refers to the element at that index in the outermost"},{"text":" ","type":"text"},{"text":"array. The next subscript index to the right refers to the element","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"at that index in the array that’s nested one level in. And so on. This means that in"},{"type":"text","text":" "},{"type":"text","text":"the example above, "},{"code":"array3D[0]","type":"codeVoice"},{"type":"text","text":" refers to "},{"code":"[[1, 2], [3, 4]]","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"array3D[0][1]"},{"text":" refers to ","type":"text"},{"type":"codeVoice","code":"[3, 4]"},{"type":"text","text":", and "},{"code":"array3D[0][1][1]","type":"codeVoice"},{"text":" refers to the value 4.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For a detailed discussion of the Swift standard library "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" type,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes#Arrays","isActive":true},{"text":".","type":"text"}],"type":"paragraph"},{"type":"aside","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"array-type","type":"text"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"code":"[","type":"codeVoice"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"]"}]}],"type":"paragraph"}],"style":"note","name":"Grammar of an array type"},{"anchor":"Dictionary-Type","type":"heading","level":2,"text":"Dictionary Type"},{"inlineContent":[{"type":"text","text":"The Swift language provides the following syntactic sugar for the Swift standard library"},{"text":" ","type":"text"},{"code":"Dictionary<Key, Value>","type":"codeVoice"},{"type":"text","text":" type:"}],"type":"paragraph"},{"syntax":"swift","code":["[<#key type#>: <#value type#>]"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"In other words, the following two declarations are equivalent:","type":"text"}]},{"code":["let someDictionary: [String: Int] = [\"Alex\": 31, \"Paul\": 39]","let someDictionary: Dictionary<String, Int> = [\"Alex\": 31, \"Paul\": 39]"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In both cases, the constant "},{"type":"codeVoice","code":"someDictionary"},{"text":" ","type":"text"},{"text":"is declared as a dictionary with strings as keys and integers as values.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The values of a dictionary can be accessed through subscripting","type":"text"},{"type":"text","text":" "},{"type":"text","text":"by specifying the corresponding key in"},{"text":" ","type":"text"},{"text":"square brackets: ","type":"text"},{"type":"codeVoice","code":"someDictionary[\"Alex\"]"},{"type":"text","text":" refers to the value associated"},{"text":" ","type":"text"},{"text":"with the key ","type":"text"},{"code":"\"Alex\"","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The subscript returns an optional value of the dictionary’s value type."},{"text":" ","type":"text"},{"type":"text","text":"If the specified key isn’t contained in the dictionary,"},{"type":"text","text":" "},{"type":"text","text":"the subscript returns "},{"type":"codeVoice","code":"nil"},{"text":".","type":"text"}]},{"inlineContent":[{"text":"The key type of a dictionary must conform to the Swift standard library ","type":"text"},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" protocol."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For a detailed discussion of the Swift standard library "},{"code":"Dictionary","type":"codeVoice"},{"type":"text","text":" type,"},{"text":" ","type":"text"},{"type":"text","text":"see "},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes#Dictionaries"},{"text":".","type":"text"}],"type":"paragraph"},{"name":"Grammar of a dictionary type","type":"aside","style":"note","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"dictionary-type","type":"text"}]},{"text":" → ","type":"text"},{"inlineContent":[{"code":"[","type":"codeVoice"}],"type":"strong"},{"text":" ","type":"text"},{"inlineContent":[{"text":"type","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":":"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"]"}]}]}]},{"text":"Optional Type","level":2,"type":"heading","anchor":"Optional-Type"},{"inlineContent":[{"type":"text","text":"The Swift language defines the postfix "},{"code":"?","type":"codeVoice"},{"type":"text","text":" as syntactic sugar for"},{"type":"text","text":" "},{"text":"the named type ","type":"text"},{"type":"codeVoice","code":"Optional<Wrapped>"},{"type":"text","text":", which is defined in the Swift standard library."},{"text":" ","type":"text"},{"type":"text","text":"In other words, the following two declarations are equivalent:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["var optionalInteger: Int?","var optionalInteger: Optional<Int>"]},{"inlineContent":[{"text":"In both cases, the variable ","type":"text"},{"type":"codeVoice","code":"optionalInteger"},{"text":" ","type":"text"},{"type":"text","text":"is declared to have the type of an optional integer."},{"type":"text","text":" "},{"type":"text","text":"Note that no whitespace may appear between the type and the "},{"type":"codeVoice","code":"?"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"The type ","type":"text"},{"code":"Optional<Wrapped>","type":"codeVoice"},{"type":"text","text":" is an enumeration with two cases, "},{"type":"codeVoice","code":"none"},{"type":"text","text":" and "},{"code":"some(Wrapped)","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which are used to represent values that may or may not be present."},{"text":" ","type":"text"},{"type":"text","text":"Any type can be explicitly declared to be (or implicitly converted to) an optional type."},{"type":"text","text":" "},{"type":"text","text":"If you don’t provide an initial value when you declare an"},{"text":" ","type":"text"},{"type":"text","text":"optional variable or property, its value automatically defaults to "},{"code":"nil","type":"codeVoice"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If an instance of an optional type contains a value,"},{"text":" ","type":"text"},{"type":"text","text":"you can access that value using the postfix operator "},{"code":"!","type":"codeVoice"},{"text":", as shown below:","type":"text"}]},{"syntax":"swift","code":["optionalInteger = 42","optionalInteger! \/\/ 42"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Using the "},{"type":"codeVoice","code":"!"},{"type":"text","text":" operator to unwrap an optional"},{"type":"text","text":" "},{"type":"text","text":"that has a value of "},{"type":"codeVoice","code":"nil"},{"text":" results in a runtime error.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"You can also use optional chaining and optional binding to conditionally perform an","type":"text"},{"type":"text","text":" "},{"type":"text","text":"operation on an optional expression. If the value is "},{"code":"nil","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"no operation is performed and therefore no runtime error is produced."}]},{"inlineContent":[{"type":"text","text":"For more information and to see examples that show how to use optional types,"},{"type":"text","text":" "},{"text":"see ","type":"text"},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TheBasics#Optionals","isActive":true,"type":"reference"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"aside","name":"Grammar of an optional type","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"optional-type"}]},{"text":" → ","type":"text"},{"inlineContent":[{"text":"type","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":"?"}],"type":"strong"}]}]},{"text":"Implicitly Unwrapped Optional Type","anchor":"Implicitly-Unwrapped-Optional-Type","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The Swift language defines the postfix "},{"type":"codeVoice","code":"!"},{"type":"text","text":" as syntactic sugar for"},{"type":"text","text":" "},{"text":"the named type ","type":"text"},{"type":"codeVoice","code":"Optional<Wrapped>"},{"type":"text","text":", which is defined in the Swift standard library,"},{"type":"text","text":" "},{"type":"text","text":"with the additional behavior that"},{"type":"text","text":" "},{"type":"text","text":"it’s automatically unwrapped when it’s accessed."},{"text":" ","type":"text"},{"text":"If you try to use an implicitly unwrapped optional that has a value of ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"you’ll get a runtime error."},{"type":"text","text":" "},{"text":"With the exception of the implicit unwrapping behavior,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the following two declarations are equivalent:"}]},{"syntax":"swift","code":["var implicitlyUnwrappedString: String!","var explicitlyUnwrappedString: Optional<String>"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Note that no whitespace may appear between the type and the ","type":"text"},{"type":"codeVoice","code":"!"},{"text":".","type":"text"}]},{"inlineContent":[{"text":"Because implicit unwrapping","type":"text"},{"type":"text","text":" "},{"type":"text","text":"changes the meaning of the declaration that contains that type,"},{"type":"text","text":" "},{"type":"text","text":"optional types that are nested inside a tuple type or a generic type"},{"text":" ","type":"text"},{"type":"text","text":"— such as the element types of a dictionary or array —"},{"type":"text","text":" "},{"text":"can’t be marked as implicitly unwrapped.","type":"text"},{"type":"text","text":" "},{"text":"For example:","type":"text"}],"type":"paragraph"},{"code":["let tupleOfImplicitlyUnwrappedElements: (Int!, Int!)  \/\/ Error","let implicitlyUnwrappedTuple: (Int, Int)!             \/\/ OK","","let arrayOfImplicitlyUnwrappedElements: [Int!]        \/\/ Error","let implicitlyUnwrappedArray: [Int]!                  \/\/ OK"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Because implicitly unwrapped optionals"},{"type":"text","text":" "},{"type":"text","text":"have the same "},{"type":"codeVoice","code":"Optional<Wrapped>"},{"type":"text","text":" type as optional values,"},{"text":" ","type":"text"},{"text":"you can use implicitly unwrapped optionals","type":"text"},{"type":"text","text":" "},{"type":"text","text":"in all the same places in your code"},{"text":" ","type":"text"},{"type":"text","text":"that you can use optionals."},{"type":"text","text":" "},{"text":"For example, you can assign values of implicitly unwrapped","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"optionals to variables, constants, and properties of optionals, and vice versa."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"As with optionals, if you don’t provide an initial value when you declare an","type":"text"},{"text":" ","type":"text"},{"text":"implicitly unwrapped optional variable or property,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"its value automatically defaults to "},{"code":"nil","type":"codeVoice"},{"type":"text","text":"."}]},{"inlineContent":[{"text":"Use optional chaining to conditionally perform an","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"operation on an implicitly unwrapped optional expression."},{"type":"text","text":" "},{"type":"text","text":"If the value is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"no operation is performed and therefore no runtime error is produced."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more information about implicitly unwrapped optional types,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TheBasics#Implicitly-Unwrapped-Optionals","isActive":true,"type":"reference"},{"type":"text","text":"."}]},{"style":"note","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"implicitly-unwrapped-optional-type","type":"text"}]},{"text":" → ","type":"text"},{"inlineContent":[{"text":"type","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":"!"}],"type":"strong"}]}],"type":"aside","name":"Grammar of an implicitly unwrapped optional type"},{"anchor":"Protocol-Composition-Type","level":2,"type":"heading","text":"Protocol Composition Type"},{"inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"protocol composition type"}]},{"type":"text","text":" defines a type that conforms to each protocol"},{"text":" ","type":"text"},{"text":"in a list of specified protocols,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"or a type that’s a subclass of a given class"},{"type":"text","text":" "},{"text":"and conforms to each protocol in a list of specified protocols.","type":"text"},{"text":" ","type":"text"},{"text":"Protocol composition types may be used only when specifying a type","type":"text"},{"type":"text","text":" "},{"text":"in type annotations,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"in generic parameter clauses,"},{"type":"text","text":" "},{"text":"and in generic ","type":"text"},{"type":"codeVoice","code":"where"},{"text":" clauses.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Protocol composition types have the following form:"}]},{"syntax":"swift","code":["<#Protocol 1#> & <#Protocol 2#>"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"A protocol composition type allows you to specify a value whose type conforms to the requirements","type":"text"},{"type":"text","text":" "},{"type":"text","text":"of multiple protocols without explicitly defining a new, named protocol"},{"type":"text","text":" "},{"text":"that inherits from each protocol you want the type to conform to.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"you can use the protocol composition type "},{"code":"ProtocolA & ProtocolB & ProtocolC","type":"codeVoice"},{"type":"text","text":" "},{"text":"instead of declaring a new protocol","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that inherits from "},{"code":"ProtocolA","type":"codeVoice"},{"type":"text","text":", "},{"code":"ProtocolB","type":"codeVoice"},{"text":", and ","type":"text"},{"code":"ProtocolC","type":"codeVoice"},{"type":"text","text":"."},{"text":" ","type":"text"},{"text":"Likewise, you can use ","type":"text"},{"code":"SuperClass & ProtocolA","type":"codeVoice"},{"text":" ","type":"text"},{"text":"instead of declaring a new protocol","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that’s a subclass of "},{"code":"SuperClass","type":"codeVoice"},{"text":" and conforms to ","type":"text"},{"code":"ProtocolA","type":"codeVoice"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Each item in a protocol composition list is one of the following;","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the list can contain at most one class:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The name of a class"}]}]},{"content":[{"inlineContent":[{"text":"The name of a protocol","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A type alias whose underlying type"},{"text":" ","type":"text"},{"text":"is a protocol composition type, a protocol, or a class.","type":"text"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When a protocol composition type contains type aliases,"},{"text":" ","type":"text"},{"text":"it’s possible for the same protocol to appear","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"more than once in the definitions —"},{"text":" ","type":"text"},{"text":"duplicates are ignored.","type":"text"},{"text":" ","type":"text"},{"text":"For example,","type":"text"},{"type":"text","text":" "},{"text":"the definition of ","type":"text"},{"code":"PQR","type":"codeVoice"},{"text":" in the code below","type":"text"},{"type":"text","text":" "},{"text":"is equivalent to ","type":"text"},{"code":"P & Q & R","type":"codeVoice"},{"text":".","type":"text"}]},{"code":["typealias PQ = P & Q","typealias PQR = PQ & Q & R"],"type":"codeListing","syntax":"swift"},{"content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"protocol-composition-type"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"type-identifier","type":"text"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":"&","type":"codeVoice"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"protocol-composition-continuation"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"protocol-composition-continuation"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"type-identifier"}],"type":"emphasis"},{"text":" | ","type":"text"},{"inlineContent":[{"text":"protocol-composition-type","type":"text"}],"type":"emphasis"}],"type":"paragraph"}],"type":"aside","name":"Grammar of a protocol composition type","style":"note"},{"level":2,"text":"Opaque Type","type":"heading","anchor":"Opaque-Type"},{"type":"paragraph","inlineContent":[{"text":"An ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"opaque type","type":"text"}]},{"text":" defines a type","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"that conforms to a protocol or protocol composition,"},{"text":" ","type":"text"},{"text":"without specifying the underlying concrete type.","type":"text"}]},{"inlineContent":[{"text":"Opaque types appear as the return type of a function or subscript,","type":"text"},{"text":" ","type":"text"},{"text":"or the type of a property.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Opaque types can’t appear as part of a tuple type or a generic type,"},{"type":"text","text":" "},{"text":"such as the element type of an array or the wrapped type of an optional.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Opaque types have the following form:","type":"text"}]},{"type":"codeListing","code":["some <#constraint#>"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"constraint"}]},{"text":" is a class type,","type":"text"},{"type":"text","text":" "},{"text":"protocol type,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"protocol composition type,"},{"text":" ","type":"text"},{"type":"text","text":"or "},{"code":"Any","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"A value can be used as an instance of the opaque type","type":"text"},{"type":"text","text":" "},{"text":"only if it’s an instance of a type","type":"text"},{"type":"text","text":" "},{"text":"that conforms to the listed protocol or protocol composition,","type":"text"},{"type":"text","text":" "},{"text":"or inherits from the listed class.","type":"text"},{"type":"text","text":" "},{"text":"Code that interacts with an opaque value","type":"text"},{"text":" ","type":"text"},{"text":"can use the value only in ways","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that are part of the interface defined by the "},{"inlineContent":[{"type":"text","text":"constraint"}],"type":"emphasis"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"At compile time,"},{"type":"text","text":" "},{"text":"a value whose type is opaque has a specific concrete type,","type":"text"},{"type":"text","text":" "},{"text":"and Swift can use that underlying type for optimizations.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"However,"},{"text":" ","type":"text"},{"type":"text","text":"the opaque type forms a boundary"},{"text":" ","type":"text"},{"text":"that information about that underlying type can’t cross.","type":"text"}]},{"inlineContent":[{"type":"text","text":"Protocol declarations can’t include opaque types."},{"type":"text","text":" "},{"text":"Classes can’t use an opaque type as the return type of a nonfinal method.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A function that uses an opaque type as its return type"},{"text":" ","type":"text"},{"text":"must return values that share a single underlying type.","type":"text"},{"text":" ","type":"text"},{"text":"The return type can include types","type":"text"},{"text":" ","type":"text"},{"text":"that are part of the function’s generic type parameters.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For example, a function "},{"code":"someFunction<T>()","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"could return a value of type "},{"type":"codeVoice","code":"T"},{"type":"text","text":" or "},{"code":"Dictionary<String, T>","type":"codeVoice"},{"type":"text","text":"."}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"opaque-type","type":"text"}]},{"text":" → ","type":"text"},{"inlineContent":[{"code":"some","type":"codeVoice"}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]}],"type":"paragraph"}],"style":"note","name":"Grammar of an opaque type","type":"aside"},{"text":"Boxed Protocol Type","type":"heading","level":2,"anchor":"Boxed-Protocol-Type"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"boxed protocol type"}]},{"type":"text","text":" defines a type"},{"type":"text","text":" "},{"text":"that conforms to a protocol or protocol composition,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"with the ability for that conforming type"},{"text":" ","type":"text"},{"type":"text","text":"to vary while the program is running."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Boxed protocol types have the following form:"}]},{"syntax":"swift","type":"codeListing","code":["any <#constraint#>"]},{"inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"text":"constraint","type":"text"}]},{"text":" is a protocol type,","type":"text"},{"text":" ","type":"text"},{"text":"protocol composition type,","type":"text"},{"type":"text","text":" "},{"text":"a metatype of a protocol type,","type":"text"},{"type":"text","text":" "},{"text":"or a metatype of a protocol composition type.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"At runtime,"},{"text":" ","type":"text"},{"type":"text","text":"an instance of a boxed protocol type can contain a value"},{"type":"text","text":" "},{"type":"text","text":"of any type that satisfies the "},{"inlineContent":[{"type":"text","text":"constraint"}],"type":"emphasis"},{"type":"text","text":"."},{"text":" ","type":"text"},{"text":"This behavior contrasts with how an opaque types work,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"where there is some specific conforming type known at compile time."},{"type":"text","text":" "},{"type":"text","text":"The additional level of indirection that’s used"},{"text":" ","type":"text"},{"text":"when working with a boxed protocol type is called :newTerm:","type":"text"},{"code":"boxing","type":"codeVoice"},{"type":"text","text":"."},{"text":" ","type":"text"},{"text":"Boxing typically requires a separate memory allocation for storage","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and an additional level of indirection for access,"},{"type":"text","text":" "},{"text":"which incurs a performance cost at runtime.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Applying ","type":"text"},{"type":"codeVoice","code":"any"},{"text":" to the ","type":"text"},{"code":"Any","type":"codeVoice"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"AnyObject"},{"text":" types","type":"text"},{"type":"text","text":" "},{"type":"text","text":"has no effect,"},{"type":"text","text":" "},{"text":"because those types are already boxed protocol types.","type":"text"}]},{"style":"note","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"boxed-protocol-type"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"any"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]}],"type":"paragraph"}],"name":"Grammar of a boxed protocol type","type":"aside"},{"level":2,"text":"Metatype Type","type":"heading","anchor":"Metatype-Type"},{"inlineContent":[{"type":"text","text":"A "},{"inlineContent":[{"text":"metatype type","type":"text"}],"type":"emphasis"},{"type":"text","text":" refers to the type of any type,"},{"text":" ","type":"text"},{"text":"including class types, structure types, enumeration types, and protocol types.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"The metatype of a class, structure, or enumeration type is","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the name of that type followed by "},{"code":".Type","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"The metatype of a protocol type — not the concrete type that","type":"text"},{"text":" ","type":"text"},{"text":"conforms to the protocol at runtime —","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"is the name of that protocol followed by "},{"code":".Protocol","type":"codeVoice"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For example, the metatype of the class type "},{"code":"SomeClass","type":"codeVoice"},{"text":" is ","type":"text"},{"code":"SomeClass.Type","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"and the metatype of the protocol "},{"type":"codeVoice","code":"SomeProtocol"},{"text":" is ","type":"text"},{"code":"SomeProtocol.Protocol","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"text":"You can use the postfix ","type":"text"},{"type":"codeVoice","code":"self"},{"text":" expression to access a type as a value.","type":"text"},{"type":"text","text":" "},{"text":"For example, ","type":"text"},{"type":"codeVoice","code":"SomeClass.self"},{"type":"text","text":" returns "},{"type":"codeVoice","code":"SomeClass"},{"text":" itself,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"not an instance of "},{"code":"SomeClass","type":"codeVoice"},{"type":"text","text":"."},{"text":" ","type":"text"},{"text":"And ","type":"text"},{"type":"codeVoice","code":"SomeProtocol.self"},{"type":"text","text":" returns "},{"code":"SomeProtocol","type":"codeVoice"},{"type":"text","text":" itself,"},{"type":"text","text":" "},{"text":"not an instance of a type that conforms to ","type":"text"},{"type":"codeVoice","code":"SomeProtocol"},{"text":" at runtime.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"You can call the "},{"type":"codeVoice","code":"type(of:)"},{"text":" function with an instance of a type","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"to access that instance’s dynamic, runtime type as a value,"},{"text":" ","type":"text"},{"type":"text","text":"as the following example shows:"}]},{"type":"codeListing","code":["class SomeBaseClass {","    class func printClassName() {","        print(\"SomeBaseClass\")","    }","}","class SomeSubClass: SomeBaseClass {","    override class func printClassName() {","        print(\"SomeSubClass\")","    }","}","let someInstance: SomeBaseClass = SomeSubClass()","\/\/ The compile-time type of someInstance is SomeBaseClass,","\/\/ and the runtime type of someInstance is SomeSubClass","type(of: someInstance).printClassName()","\/\/ Prints \"SomeSubClass\""],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"For more information,"},{"text":" ","type":"text"},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/2885064-type"},{"text":" ","type":"text"},{"type":"text","text":"in the Swift standard library."}],"type":"paragraph"},{"inlineContent":[{"text":"Use an initializer expression to construct an instance of a type","type":"text"},{"type":"text","text":" "},{"type":"text","text":"from that type’s metatype value."},{"text":" ","type":"text"},{"text":"For class instances,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the initializer that’s called must be marked with the "},{"type":"codeVoice","code":"required"},{"text":" keyword","type":"text"},{"type":"text","text":" "},{"text":"or the entire class marked with the ","type":"text"},{"code":"final","type":"codeVoice"},{"type":"text","text":" keyword."}],"type":"paragraph"},{"syntax":"swift","code":["class AnotherSubClass: SomeBaseClass {","    let string: String","    required init(string: String) {","        self.string = string","    }","    override class func printClassName() {","        print(\"AnotherSubClass\")","    }","}","let metatype: AnotherSubClass.Type = AnotherSubClass.self","let anotherInstance = metatype.init(string: \"some string\")"],"type":"codeListing"},{"type":"aside","name":"Grammar of a metatype type","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"metatype-type"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"."}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":"Type","type":"codeVoice"}]},{"type":"text","text":" | "},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":".","type":"codeVoice"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":"Protocol"}],"type":"strong"}],"type":"paragraph"}]},{"level":2,"type":"heading","text":"Any Type","anchor":"Any-Type"},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"Any"},{"text":" type can contain values from all other types.","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"Any"},{"text":" can be used as the concrete type","type":"text"},{"type":"text","text":" "},{"type":"text","text":"for an instance of any of the following types:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"A class, structure, or enumeration"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A metatype, such as "},{"code":"Int.self","type":"codeVoice"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"A tuple with any types of components"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"A closure or function type","type":"text"}]}]}]},{"type":"codeListing","syntax":"swift","code":["let mixed: [Any] = [\"one\", 2, true, (4, 5.3), { () -> Int in return 6 }]"]},{"type":"paragraph","inlineContent":[{"text":"When you use ","type":"text"},{"type":"codeVoice","code":"Any"},{"type":"text","text":" as a concrete type for an instance,"},{"text":" ","type":"text"},{"type":"text","text":"you need to cast the instance to a known type"},{"type":"text","text":" "},{"text":"before you can access its properties or methods.","type":"text"},{"text":" ","type":"text"},{"text":"Instances with a concrete type of ","type":"text"},{"code":"Any","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"maintain their original dynamic type"},{"text":" ","type":"text"},{"type":"text","text":"and can be cast to that type using one of the type-cast operators —"},{"text":" ","type":"text"},{"type":"codeVoice","code":"as"},{"type":"text","text":", "},{"type":"codeVoice","code":"as?"},{"type":"text","text":", or "},{"code":"as!","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"text":"use ","type":"text"},{"code":"as?","type":"codeVoice"},{"type":"text","text":" to conditionally downcast the first object in a heterogeneous array"},{"text":" ","type":"text"},{"text":"to a ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" as follows:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["if let first = mixed.first as? String {","    print(\"The first item, '\\(first)', is a string.\")","}","\/\/ Prints \"The first item, 'one', is a string.\""]},{"type":"paragraph","inlineContent":[{"text":"For more information about casting, see ","type":"text"},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting","type":"reference","isActive":true},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"AnyObject"},{"text":" protocol is similar to the ","type":"text"},{"code":"Any","type":"codeVoice"},{"type":"text","text":" type."},{"type":"text","text":" "},{"type":"text","text":"All classes implicitly conform to "},{"code":"AnyObject","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Unlike "},{"code":"Any","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"which is defined by the language,"},{"type":"text","text":" "},{"type":"codeVoice","code":"AnyObject"},{"type":"text","text":" is defined by the Swift standard library."},{"text":" ","type":"text"},{"type":"text","text":"For more information, see"},{"type":"text","text":" "},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Class-Only-Protocols"},{"text":" ","type":"text"},{"text":"and ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/anyobject","isActive":true,"type":"reference"},{"type":"text","text":"."}]},{"name":"Grammar of an Any type","type":"aside","style":"note","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"inlineContent":[{"inlineContent":[{"text":"any-type","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"Any"}],"type":"strong"}],"type":"paragraph"}]},{"anchor":"Self-Type","text":"Self Type","type":"heading","level":2},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"Self"},{"type":"text","text":" type isn’t a specific type,"},{"type":"text","text":" "},{"type":"text","text":"but rather lets you conveniently refer to the current type"},{"type":"text","text":" "},{"text":"without repeating or knowing that type’s name.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In a protocol declaration or a protocol member declaration,"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"type":"codeVoice","code":"Self"},{"text":" type refers to the eventual type that conforms to the protocol.","type":"text"}]},{"inlineContent":[{"type":"text","text":"In a structure, class, or enumeration declaration,"},{"text":" ","type":"text"},{"type":"text","text":"the "},{"code":"Self","type":"codeVoice"},{"text":" type refers to the type introduced by the declaration.","type":"text"},{"type":"text","text":" "},{"text":"Inside the declaration for a member of a type,","type":"text"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"type":"codeVoice","code":"Self"},{"text":" type refers to that type.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"In the members of a class declaration,"},{"text":" ","type":"text"},{"type":"codeVoice","code":"Self"},{"text":" can appear only as follows:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"As the return type of a method","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"As the return type of a read-only subscript","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"As the type of a read-only computed property"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"In the body of a method"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"the code below shows an instance method "},{"type":"codeVoice","code":"f"},{"type":"text","text":" "},{"type":"text","text":"whose return type is "},{"type":"codeVoice","code":"Self"},{"text":".","type":"text"}]},{"syntax":"swift","code":["class Superclass {","    func f() -> Self { return self }","}","let x = Superclass()","print(type(of: x.f()))","\/\/ Prints \"Superclass\"","","class Subclass: Superclass { }","let y = Subclass()","print(type(of: y.f()))","\/\/ Prints \"Subclass\"","","let z: Superclass = Subclass()","print(type(of: z.f()))","\/\/ Prints \"Subclass\""],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The last part of the example above shows that"},{"type":"text","text":" "},{"type":"codeVoice","code":"Self"},{"type":"text","text":" refers to the runtime type "},{"code":"Subclass","type":"codeVoice"},{"type":"text","text":" of the value of "},{"type":"codeVoice","code":"z"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"not the compile-time type "},{"code":"Superclass","type":"codeVoice"},{"text":" of the variable itself.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Inside a nested type declaration,"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"type":"codeVoice","code":"Self"},{"type":"text","text":" type refers to the type"},{"type":"text","text":" "},{"type":"text","text":"introduced by the innermost type declaration."}]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"Self"},{"text":" type refers to the same type","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"as the "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/2885064-type","overridingTitle":"type(of:)","overridingTitleInlineContent":[{"type":"codeVoice","code":"type(of:)"}]},{"type":"text","text":" "},{"type":"text","text":"function in the Swift standard library."},{"type":"text","text":" "},{"type":"text","text":"Writing "},{"code":"Self.someStaticMember","type":"codeVoice"},{"type":"text","text":" to access a member of the current type"},{"type":"text","text":" "},{"type":"text","text":"is the same as writing "},{"type":"codeVoice","code":"type(of: self).someStaticMember"},{"type":"text","text":"."}]},{"name":"Grammar of a Self type","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"self-type","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"Self"}]}]}],"style":"note"},{"level":2,"type":"heading","anchor":"Type-Inheritance-Clause","text":"Type Inheritance Clause"},{"inlineContent":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type inheritance clause"}]},{"type":"text","text":" is used to specify which class a named type inherits from"},{"text":" ","type":"text"},{"type":"text","text":"and which protocols a named type conforms to."},{"text":" ","type":"text"},{"text":"A type inheritance clause begins with a colon (","type":"text"},{"code":":","type":"codeVoice"},{"text":"),","type":"text"},{"type":"text","text":" "},{"text":"followed by a list of type identifiers.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Class types can inherit from a single superclass and conform to any number of protocols."},{"text":" ","type":"text"},{"type":"text","text":"When defining a class,"},{"type":"text","text":" "},{"type":"text","text":"the name of the superclass must appear first in the list of type identifiers,"},{"type":"text","text":" "},{"type":"text","text":"followed by any number of protocols the class must conform to."},{"type":"text","text":" "},{"text":"If the class doesn’t inherit from another class,","type":"text"},{"type":"text","text":" "},{"text":"the list can begin with a protocol instead.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For an extended discussion and several examples of class inheritance,"},{"text":" ","type":"text"},{"type":"text","text":"see "},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Inheritance","isActive":true},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Other named types can only inherit from or conform to a list of protocols.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Protocol types can inherit from any number of other protocols."},{"type":"text","text":" "},{"text":"When a protocol type inherits from other protocols,","type":"text"},{"type":"text","text":" "},{"text":"the set of requirements from those other protocols are aggregated together,","type":"text"},{"type":"text","text":" "},{"text":"and any type that inherits from the current protocol must conform to all of those requirements.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"A type inheritance clause in an enumeration definition can be either a list of protocols,","type":"text"},{"type":"text","text":" "},{"text":"or in the case of an enumeration that assigns raw values to its cases,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"a single, named type that specifies the type of those raw values."},{"text":" ","type":"text"},{"text":"For an example of an enumeration definition that uses a type inheritance clause","type":"text"},{"type":"text","text":" "},{"text":"to specify the type of its raw values, see ","type":"text"},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Enumerations#Raw-Values","type":"reference","isActive":true},{"text":".","type":"text"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"type-inheritance-clause","type":"text"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":":"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-inheritance-list"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type-inheritance-list","type":"text"}]},{"text":" → ","type":"text"},{"inlineContent":[{"text":"attributes","type":"text"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-identifier"}]},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"attributes"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"type-identifier"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"code":",","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"type-inheritance-list"}],"type":"emphasis"}],"type":"paragraph"}],"type":"aside","name":"Grammar of a type inheritance clause","style":"note"},{"anchor":"Type-Inference","level":2,"type":"heading","text":"Type Inference"},{"inlineContent":[{"type":"text","text":"Swift uses "},{"type":"emphasis","inlineContent":[{"text":"type inference","type":"text"}]},{"type":"text","text":" extensively,"},{"text":" ","type":"text"},{"type":"text","text":"allowing you to omit the type or part of the type of many variables and expressions in your code."},{"text":" ","type":"text"},{"text":"For example,","type":"text"},{"text":" ","type":"text"},{"text":"instead of writing ","type":"text"},{"code":"var x: Int = 0","type":"codeVoice"},{"type":"text","text":", you can write "},{"type":"codeVoice","code":"var x = 0"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"omitting the type completely —"},{"type":"text","text":" "},{"text":"the compiler correctly infers that ","type":"text"},{"type":"codeVoice","code":"x"},{"type":"text","text":" names a value of type "},{"code":"Int","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"Similarly, you can omit part of a type when the full type can be inferred from context.","type":"text"},{"type":"text","text":" "},{"text":"For example, if you write ","type":"text"},{"code":"let dict: Dictionary = [\"A\": 1]","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"the compiler infers that ","type":"text"},{"type":"codeVoice","code":"dict"},{"text":" has the type ","type":"text"},{"code":"Dictionary<String, Int>","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"In both of the examples above,","type":"text"},{"text":" ","type":"text"},{"text":"the type information is passed up from the leaves of the expression tree to its root.","type":"text"},{"text":" ","type":"text"},{"text":"That is,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the type of "},{"type":"codeVoice","code":"x"},{"type":"text","text":" in "},{"type":"codeVoice","code":"var x: Int = 0"},{"type":"text","text":" is inferred by first checking the type of "},{"type":"codeVoice","code":"0"},{"text":" ","type":"text"},{"type":"text","text":"and then passing this type information up to the root (the variable "},{"type":"codeVoice","code":"x"},{"type":"text","text":")."}]},{"type":"paragraph","inlineContent":[{"text":"In Swift, type information can also flow in the opposite direction — from the root down to the leaves.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"In the following example, for instance,"},{"type":"text","text":" "},{"type":"text","text":"the explicit type annotation ("},{"code":": Float","type":"codeVoice"},{"type":"text","text":") on the constant "},{"type":"codeVoice","code":"eFloat"},{"type":"text","text":" "},{"text":"causes the numeric literal ","type":"text"},{"code":"2.71828","type":"codeVoice"},{"text":" to have an inferred type of ","type":"text"},{"code":"Float","type":"codeVoice"},{"type":"text","text":" instead of "},{"code":"Double","type":"codeVoice"},{"text":".","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let e = 2.71828 \/\/ The type of e is inferred to be Double.","let eFloat: Float = 2.71828 \/\/ The type of eFloat is Float."]},{"type":"paragraph","inlineContent":[{"text":"Type inference in Swift operates at the level of a single expression or statement.","type":"text"},{"type":"text","text":" "},{"text":"This means that all of the information needed to infer an omitted type or part of a type","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"in an expression must be accessible from type-checking"},{"text":" ","type":"text"},{"type":"text","text":"the expression or one of its subexpressions."}]}]}],"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/CollectionTypes#Dictionaries":{"url":"\/documentation\/the-swift-programming-language\/collectiontypes#Dictionaries","abstract":[],"kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes#Dictionaries","title":"Dictionaries"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/CollectionTypes#Arrays":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes#Arrays","abstract":[],"title":"Arrays","kind":"section","type":"topic","url":"\/documentation\/the-swift-programming-language\/collectiontypes#Arrays"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Declarations#Asynchronous-Functions-and-Methods":{"url":"\/documentation\/the-swift-programming-language\/declarations#Asynchronous-Functions-and-Methods","abstract":[],"kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Asynchronous-Functions-and-Methods","title":"Asynchronous Functions and Methods"},"https://developer.apple.com/documentation/swift/anyobject":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/anyobject","titleInlineContent":[{"code":"AnyObject","type":"codeVoice"}],"title":"AnyObject","type":"link","url":"https:\/\/developer.apple.com\/documentation\/swift\/anyobject"},"https://developer.apple.com/documentation/swift/2885064-type":{"url":"https:\/\/developer.apple.com\/documentation\/swift\/2885064-type","titleInlineContent":[{"code":"type(of:)","type":"codeVoice"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/2885064-type","title":"type(of:)"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Declarations#Rethrowing-Functions-and-Methods":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Rethrowing-Functions-and-Methods","abstract":[],"title":"Rethrowing Functions and Methods","kind":"section","type":"topic","url":"\/documentation\/the-swift-programming-language\/declarations#Rethrowing-Functions-and-Methods"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Inheritance":{"title":"Inheritance","url":"\/documentation\/the-swift-programming-language\/inheritance","type":"topic","role":"article","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Inheritance","abstract":[{"text":"Subclass to add or override functionality.","type":"text"}],"kind":"article"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions#Variadic-Parameters":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#Variadic-Parameters","url":"\/documentation\/the-swift-programming-language\/functions#Variadic-Parameters","abstract":[],"kind":"section","type":"topic","title":"Variadic Parameters"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"abstract":[],"role":"collection","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language","kind":"article","type":"topic","title":"The Swift Programming Language (5.9.2)","url":"\/documentation\/the-swift-programming-language"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures#Autoclosures":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Autoclosures","abstract":[],"title":"Autoclosures","kind":"section","type":"topic","url":"\/documentation\/the-swift-programming-language\/closures#Autoclosures"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TheBasics#Optionals":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TheBasics#Optionals","url":"\/documentation\/the-swift-programming-language\/thebasics#Optionals","abstract":[],"kind":"section","title":"Optionals","type":"topic"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Declarations#Throwing-Functions-and-Methods":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Throwing-Functions-and-Methods","abstract":[],"title":"Throwing Functions and Methods","kind":"section","type":"topic","url":"\/documentation\/the-swift-programming-language\/declarations#Throwing-Functions-and-Methods"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Declarations#Extension-Declaration":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Extension-Declaration","url":"\/documentation\/the-swift-programming-language\/declarations#Extension-Declaration","abstract":[],"kind":"section","title":"Extension Declaration","type":"topic"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions#Functions-with-Multiple-Return-Values":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#Functions-with-Multiple-Return-Values","abstract":[],"title":"Functions with Multiple Return Values","kind":"section","type":"topic","url":"\/documentation\/the-swift-programming-language\/functions#Functions-with-Multiple-Return-Values"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Extensions":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Extensions","role":"article","title":"Extensions","kind":"article","abstract":[{"type":"text","text":"Add functionality to an existing type."}],"type":"topic","url":"\/documentation\/the-swift-programming-language\/extensions"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Protocols#Class-Only-Protocols":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Class-Only-Protocols","url":"\/documentation\/the-swift-programming-language\/protocols#Class-Only-Protocols","abstract":[],"kind":"section","title":"Class-Only Protocols","type":"topic"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions#In-Out-Parameters":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#In-Out-Parameters","abstract":[],"title":"In-Out Parameters","kind":"section","type":"topic","url":"\/documentation\/the-swift-programming-language\/functions#In-Out-Parameters"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TheBasics#Implicitly-Unwrapped-Optionals":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TheBasics#Implicitly-Unwrapped-Optionals","url":"\/documentation\/the-swift-programming-language\/thebasics#Implicitly-Unwrapped-Optionals","abstract":[],"kind":"section","title":"Implicitly Unwrapped Optionals","type":"topic"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TypeCasting":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting","role":"article","title":"Type Casting","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/typecasting","abstract":[{"text":"Determine a value’s runtime type and give it more specific type information.","type":"text"}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/MemorySafety":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/MemorySafety","role":"article","title":"Memory Safety","url":"\/documentation\/the-swift-programming-language\/memorysafety","kind":"article","type":"topic","abstract":[{"text":"Structure your code to avoid conflicts when accessing memory.","type":"text"}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Enumerations#Raw-Values":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Enumerations#Raw-Values","abstract":[],"title":"Raw Values","kind":"section","type":"topic","url":"\/documentation\/the-swift-programming-language\/enumerations#Raw-Values"}}}