{"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","interfaceLanguage":"swift"},"metadata":{"title":"Generics"},"sections":[],"kind":"article","schemaVersion":{"major":0,"minor":3,"patch":0},"abstract":[{"type":"text","text":"Write code that works for multiple types and specify requirements for those types."}],"primaryContentSections":[{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Generic code"}]},{"type":"text","text":" enables you to write flexible, reusable functions and types"},{"text":" ","type":"text"},{"type":"text","text":"that can work with any type, subject to requirements that you define."},{"text":" ","type":"text"},{"type":"text","text":"You can write code that avoids duplication"},{"type":"text","text":" "},{"type":"text","text":"and expresses its intent in a clear, abstracted manner."}]},{"type":"paragraph","inlineContent":[{"text":"Generics are one of the most powerful features of Swift,","type":"text"},{"text":" ","type":"text"},{"text":"and much of the Swift standard library is built with generic code.","type":"text"},{"text":" ","type":"text"},{"text":"In fact, you’ve been using generics throughout the ","type":"text"},{"inlineContent":[{"text":"Language Guide","type":"text"}],"type":"emphasis"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"even if you didn’t realize it.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For example, Swift’s "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" and "},{"code":"Dictionary","type":"codeVoice"},{"text":" types","type":"text"},{"type":"text","text":" "},{"type":"text","text":"are both generic collections."},{"type":"text","text":" "},{"text":"You can create an array that holds ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":" values,"},{"text":" ","type":"text"},{"type":"text","text":"or an array that holds "},{"code":"String","type":"codeVoice"},{"text":" values,","type":"text"},{"text":" ","type":"text"},{"text":"or indeed an array for any other type that can be created in Swift.","type":"text"},{"type":"text","text":" "},{"text":"Similarly, you can create a dictionary to store values of any specified type,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and there are no limitations on what that type can be."}]},{"text":"The Problem That Generics Solve","level":2,"anchor":"The-Problem-That-Generics-Solve","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Here’s a standard, nongeneric function called ","type":"text"},{"type":"codeVoice","code":"swapTwoInts(_:_:)"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"which swaps two ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":" values:"}]},{"type":"codeListing","code":["func swapTwoInts(_ a: inout Int, _ b: inout Int) {","    let temporaryA = a","    a = b","    b = temporaryA","}"],"syntax":"swift"},{"inlineContent":[{"text":"This function makes use of in-out parameters to swap the values of ","type":"text"},{"type":"codeVoice","code":"a"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"b"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"as described in "},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#In-Out-Parameters","isActive":true,"type":"reference"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"swapTwoInts(_:_:)"},{"type":"text","text":" function swaps the original value of "},{"type":"codeVoice","code":"b"},{"type":"text","text":" into "},{"type":"codeVoice","code":"a"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"and the original value of ","type":"text"},{"type":"codeVoice","code":"a"},{"type":"text","text":" into "},{"code":"b","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"You can call this function to swap the values in two ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":" variables:","type":"text"}]},{"syntax":"swift","code":["var someInt = 3","var anotherInt = 107","swapTwoInts(&someInt, &anotherInt)","print(\"someInt is now \\(someInt), and anotherInt is now \\(anotherInt)\")","\/\/ Prints \"someInt is now 107, and anotherInt is now 3\""],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The "},{"code":"swapTwoInts(_:_:)","type":"codeVoice"},{"text":" function is useful, but it can only be used with ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":" values.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"If you want to swap two "},{"code":"String","type":"codeVoice"},{"type":"text","text":" values,"},{"type":"text","text":" "},{"type":"text","text":"or two "},{"type":"codeVoice","code":"Double"},{"text":" values,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"you have to write more functions,"},{"type":"text","text":" "},{"text":"such as the ","type":"text"},{"code":"swapTwoStrings(_:_:)","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"swapTwoDoubles(_:_:)"},{"type":"text","text":" functions shown below:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["func swapTwoStrings(_ a: inout String, _ b: inout String) {","    let temporaryA = a","    a = b","    b = temporaryA","}","","func swapTwoDoubles(_ a: inout Double, _ b: inout Double) {","    let temporaryA = a","    a = b","    b = temporaryA","}"]},{"inlineContent":[{"type":"text","text":"You may have noticed that the bodies of"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"type":"codeVoice","code":"swapTwoInts(_:_:)"},{"text":", ","type":"text"},{"type":"codeVoice","code":"swapTwoStrings(_:_:)"},{"text":", and ","type":"text"},{"type":"codeVoice","code":"swapTwoDoubles(_:_:)"},{"text":" functions are identical.","type":"text"},{"text":" ","type":"text"},{"text":"The only difference is the type of the values that they accept","type":"text"},{"text":" ","type":"text"},{"text":"(","type":"text"},{"type":"codeVoice","code":"Int"},{"text":", ","type":"text"},{"code":"String","type":"codeVoice"},{"text":", and ","type":"text"},{"type":"codeVoice","code":"Double"},{"text":").","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"It’s more useful, and considerably more flexible,","type":"text"},{"type":"text","text":" "},{"text":"to write a single function that swaps two values of ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"any","type":"text"}]},{"text":" type.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Generic code enables you to write such a function."},{"text":" ","type":"text"},{"type":"text","text":"(A generic version of these functions is defined below.)"}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"text":"In all three functions,","type":"text"},{"type":"text","text":" "},{"text":"the types of ","type":"text"},{"type":"codeVoice","code":"a"},{"type":"text","text":" and "},{"code":"b","type":"codeVoice"},{"type":"text","text":" must be the same."},{"type":"text","text":" "},{"text":"If ","type":"text"},{"code":"a","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"b","type":"codeVoice"},{"text":" aren’t of the same type,","type":"text"},{"text":" ","type":"text"},{"text":"it isn’t possible to swap their values.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Swift is a type-safe language,"},{"type":"text","text":" "},{"type":"text","text":"and doesn’t allow (for example) a variable of type "},{"code":"String","type":"codeVoice"},{"type":"text","text":" "},{"text":"and a variable of type ","type":"text"},{"code":"Double","type":"codeVoice"},{"text":" ","type":"text"},{"text":"to swap values with each other.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Attempting to do so results in a compile-time error."}]}],"type":"aside","style":"note","name":"Note"},{"type":"heading","level":2,"text":"Generic Functions","anchor":"Generic-Functions"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Generic functions"}],"type":"emphasis"},{"type":"text","text":" can work with any type."},{"type":"text","text":" "},{"type":"text","text":"Here’s a generic version of the "},{"code":"swapTwoInts(_:_:)","type":"codeVoice"},{"text":" function from above,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"called "},{"code":"swapTwoValues(_:_:)","type":"codeVoice"},{"type":"text","text":":"}]},{"code":["func swapTwoValues<T>(_ a: inout T, _ b: inout T) {","    let temporaryA = a","    a = b","    b = temporaryA","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"The body of the ","type":"text"},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"type":"text","text":" function"},{"type":"text","text":" "},{"type":"text","text":"is identical to the body of the "},{"type":"codeVoice","code":"swapTwoInts(_:_:)"},{"type":"text","text":" function."},{"type":"text","text":" "},{"type":"text","text":"However, the first line of "},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"type":"text","text":" "},{"text":"is slightly different from ","type":"text"},{"type":"codeVoice","code":"swapTwoInts(_:_:)"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Here’s how the first lines compare:"}]},{"type":"codeListing","code":["func swapTwoInts(_ a: inout Int, _ b: inout Int)","func swapTwoValues<T>(_ a: inout T, _ b: inout T)"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The generic version of the function"},{"type":"text","text":" "},{"text":"uses a ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"placeholder"}]},{"type":"text","text":" type name (called "},{"code":"T","type":"codeVoice"},{"text":", in this case)","type":"text"},{"type":"text","text":" "},{"text":"instead of an ","type":"text"},{"inlineContent":[{"type":"text","text":"actual"}],"type":"emphasis"},{"text":" type name (such as ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":", "},{"code":"String","type":"codeVoice"},{"text":", or ","type":"text"},{"type":"codeVoice","code":"Double"},{"type":"text","text":")."},{"text":" ","type":"text"},{"type":"text","text":"The placeholder type name doesn’t say anything about what "},{"code":"T","type":"codeVoice"},{"type":"text","text":" must be,"},{"type":"text","text":" "},{"type":"text","text":"but it "},{"type":"emphasis","inlineContent":[{"text":"does","type":"text"}]},{"type":"text","text":" say that both "},{"code":"a","type":"codeVoice"},{"type":"text","text":" and "},{"code":"b","type":"codeVoice"},{"text":" must be of the same type ","type":"text"},{"code":"T","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"whatever ","type":"text"},{"type":"codeVoice","code":"T"},{"type":"text","text":" represents."},{"type":"text","text":" "},{"type":"text","text":"The actual type to use in place of "},{"type":"codeVoice","code":"T"},{"type":"text","text":" "},{"type":"text","text":"is determined each time the "},{"code":"swapTwoValues(_:_:)","type":"codeVoice"},{"text":" function is called.","type":"text"}]},{"inlineContent":[{"type":"text","text":"The other difference between a generic function and a nongeneric function"},{"text":" ","type":"text"},{"text":"is that the generic function’s name (","type":"text"},{"code":"swapTwoValues(_:_:)","type":"codeVoice"},{"type":"text","text":")"},{"type":"text","text":" "},{"text":"is followed by the placeholder type name (","type":"text"},{"code":"T","type":"codeVoice"},{"text":") inside angle brackets (","type":"text"},{"type":"codeVoice","code":"<T>"},{"type":"text","text":")."},{"text":" ","type":"text"},{"type":"text","text":"The brackets tell Swift that "},{"code":"T","type":"codeVoice"},{"type":"text","text":" is a placeholder type name"},{"type":"text","text":" "},{"text":"within the ","type":"text"},{"code":"swapTwoValues(_:_:)","type":"codeVoice"},{"text":" function definition.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Because "},{"type":"codeVoice","code":"T"},{"text":" is a placeholder, Swift doesn’t look for an actual type called ","type":"text"},{"code":"T","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"type":"text","text":" function can now be called in the same way as "},{"code":"swapTwoInts","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"except that it can be passed two values of ","type":"text"},{"inlineContent":[{"text":"any","type":"text"}],"type":"emphasis"},{"type":"text","text":" type,"},{"type":"text","text":" "},{"type":"text","text":"as long as both of those values are of the same type as each other."},{"type":"text","text":" "},{"type":"text","text":"Each time "},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"type":"text","text":" is called,"},{"type":"text","text":" "},{"type":"text","text":"the type to use for "},{"code":"T","type":"codeVoice"},{"type":"text","text":" is inferred from the types of values passed to the function."}]},{"inlineContent":[{"type":"text","text":"In the two examples below, "},{"code":"T","type":"codeVoice"},{"text":" is inferred to be ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" respectively:","type":"text"}],"type":"paragraph"},{"code":["var someInt = 3","var anotherInt = 107","swapTwoValues(&someInt, &anotherInt)","\/\/ someInt is now 107, and anotherInt is now 3","","var someString = \"hello\"","var anotherString = \"world\"","swapTwoValues(&someString, &anotherString)","\/\/ someString is now \"world\", and anotherString is now \"hello\""],"syntax":"swift","type":"codeListing"},{"style":"note","name":"Note","content":[{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"type":"text","text":" function defined above is inspired by"},{"type":"text","text":" "},{"text":"a generic function called ","type":"text"},{"type":"codeVoice","code":"swap"},{"text":", which is part of the Swift standard library,","type":"text"},{"type":"text","text":" "},{"text":"and is automatically made available for you to use in your apps.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"If you need the behavior of the "},{"code":"swapTwoValues(_:_:)","type":"codeVoice"},{"text":" function in your own code,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"you can use Swift’s existing "},{"code":"swap(_:_:)","type":"codeVoice"},{"type":"text","text":" function rather than providing your own implementation."}],"type":"paragraph"}],"type":"aside"},{"text":"Type Parameters","anchor":"Type-Parameters","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the "},{"code":"swapTwoValues(_:_:)","type":"codeVoice"},{"text":" example above,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the placeholder type "},{"type":"codeVoice","code":"T"},{"type":"text","text":" is an example of a "},{"type":"emphasis","inlineContent":[{"text":"type parameter","type":"text"}]},{"type":"text","text":"."},{"text":" ","type":"text"},{"text":"Type parameters specify and name a placeholder type,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and are written immediately after the function’s name,"},{"type":"text","text":" "},{"type":"text","text":"between a pair of matching angle brackets (such as "},{"type":"codeVoice","code":"<T>"},{"type":"text","text":")."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Once you specify a type parameter,"},{"type":"text","text":" "},{"type":"text","text":"you can use it to define the type of a function’s parameters"},{"text":" ","type":"text"},{"type":"text","text":"(such as the "},{"type":"codeVoice","code":"a"},{"type":"text","text":" and "},{"type":"codeVoice","code":"b"},{"type":"text","text":" parameters of the "},{"code":"swapTwoValues(_:_:)","type":"codeVoice"},{"text":" function),","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"or as the function’s return type,"},{"type":"text","text":" "},{"text":"or as a type annotation within the body of the function.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"In each case, the type parameter"},{"type":"text","text":" "},{"type":"text","text":"is replaced with an "},{"inlineContent":[{"type":"text","text":"actual"}],"type":"emphasis"},{"type":"text","text":" type whenever the function is called."},{"type":"text","text":" "},{"type":"text","text":"(In the "},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"text":" example above,","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"T"},{"type":"text","text":" was replaced with "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" the first time the function was called,"},{"type":"text","text":" "},{"type":"text","text":"and was replaced with "},{"code":"String","type":"codeVoice"},{"type":"text","text":" the second time it was called.)"}]},{"inlineContent":[{"text":"You can provide more than one type parameter","type":"text"},{"type":"text","text":" "},{"text":"by writing multiple type parameter names within the angle brackets,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"separated by commas."}],"type":"paragraph"},{"level":2,"type":"heading","text":"Naming Type Parameters","anchor":"Naming-Type-Parameters"},{"type":"paragraph","inlineContent":[{"text":"In most cases, type parameters have descriptive names,","type":"text"},{"type":"text","text":" "},{"text":"such as ","type":"text"},{"code":"Key","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Value"},{"type":"text","text":" in "},{"code":"Dictionary<Key, Value>","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"and "},{"type":"codeVoice","code":"Element"},{"text":" in ","type":"text"},{"code":"Array<Element>","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"which tells the reader about the relationship between the type parameter"},{"type":"text","text":" "},{"text":"and the generic type or function it’s used in.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"However, when there isn’t a meaningful relationship between them,"},{"text":" ","type":"text"},{"text":"it’s traditional to name them using single letters such as ","type":"text"},{"code":"T","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":"U"},{"type":"text","text":", and "},{"type":"codeVoice","code":"V"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"such as ","type":"text"},{"type":"codeVoice","code":"T"},{"text":" in the ","type":"text"},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"text":" function above.","type":"text"}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"Always give type parameters upper camel case names","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"(such as "},{"type":"codeVoice","code":"T"},{"type":"text","text":" and "},{"type":"codeVoice","code":"MyTypeParameter"},{"text":")","type":"text"},{"text":" ","type":"text"},{"text":"to indicate that they’re a placeholder for a ","type":"text"},{"inlineContent":[{"text":"type","type":"text"}],"type":"emphasis"},{"type":"text","text":", not a value."}]}],"name":"Note","type":"aside"},{"level":2,"anchor":"Generic-Types","text":"Generic Types","type":"heading"},{"inlineContent":[{"text":"In addition to generic functions,","type":"text"},{"type":"text","text":" "},{"text":"Swift enables you to define your own ","type":"text"},{"inlineContent":[{"text":"generic types","type":"text"}],"type":"emphasis"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"These are custom classes, structures, and enumerations","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that can work with "},{"inlineContent":[{"type":"text","text":"any"}],"type":"emphasis"},{"text":" type, in a similar way to ","type":"text"},{"type":"codeVoice","code":"Array"},{"text":" and ","type":"text"},{"code":"Dictionary","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"This section shows you how to write a generic collection type called ","type":"text"},{"type":"codeVoice","code":"Stack"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"A stack is an ordered set of values, similar to an array,"},{"text":" ","type":"text"},{"type":"text","text":"but with a more restricted set of operations than Swift’s "},{"code":"Array","type":"codeVoice"},{"type":"text","text":" type."},{"type":"text","text":" "},{"type":"text","text":"An array allows new items to be inserted and removed at any location in the array."},{"text":" ","type":"text"},{"text":"A stack, however, allows new items to be appended only to the end of the collection","type":"text"},{"type":"text","text":" "},{"text":"(known as ","type":"text"},{"inlineContent":[{"type":"text","text":"pushing"}],"type":"emphasis"},{"text":" a new value on to the stack).","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Similarly, a stack allows items to be removed only from the end of the collection"},{"type":"text","text":" "},{"text":"(known as ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"popping","type":"text"}]},{"type":"text","text":" a value off the stack)."}],"type":"paragraph"},{"name":"Note","type":"aside","content":[{"inlineContent":[{"text":"The concept of a stack is used by the ","type":"text"},{"code":"UINavigationController","type":"codeVoice"},{"type":"text","text":" class"},{"text":" ","type":"text"},{"text":"to model the view controllers in its navigation hierarchy.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"You call the "},{"type":"codeVoice","code":"UINavigationController"},{"text":" class","type":"text"},{"text":" ","type":"text"},{"code":"pushViewController(_:animated:)","type":"codeVoice"},{"text":" method to add (or push)","type":"text"},{"type":"text","text":" "},{"text":"a view controller on to the navigation stack,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and its "},{"type":"codeVoice","code":"popViewControllerAnimated(_:)"},{"type":"text","text":" method to remove (or pop)"},{"type":"text","text":" "},{"text":"a view controller from the navigation stack.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"A stack is a useful collection model whenever you need a strict"},{"type":"text","text":" "},{"type":"text","text":"“last in, first out” approach to managing a collection."}],"type":"paragraph"}],"style":"note"},{"type":"paragraph","inlineContent":[{"text":"The illustration below shows the push and pop behavior for a stack:","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"stackPushPop"}]},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"There are currently three values on the stack."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"A fourth value is pushed onto the top of the stack.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The stack now holds four values, with the most recent one at the top."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"The top item in the stack is popped."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"After popping a value, the stack once again holds three values.","type":"text"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s how to write a nongeneric version of a stack,"},{"text":" ","type":"text"},{"text":"in this case for a stack of ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":" values:"}]},{"code":["struct IntStack {","    var items: [Int] = []","    mutating func push(_ item: Int) {","        items.append(item)","    }","    mutating func pop() -> Int {","        return items.removeLast()","    }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This structure uses an "},{"code":"Array","type":"codeVoice"},{"type":"text","text":" property called "},{"type":"codeVoice","code":"items"},{"text":" to store the values in the stack.","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"Stack"},{"text":" provides two methods, ","type":"text"},{"code":"push","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"pop","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"to push and pop values on and off the stack."},{"text":" ","type":"text"},{"type":"text","text":"These methods are marked as "},{"code":"mutating","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"because they need to modify (or "},{"type":"emphasis","inlineContent":[{"text":"mutate","type":"text"}]},{"text":") the structure’s ","type":"text"},{"type":"codeVoice","code":"items"},{"type":"text","text":" array."}]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"IntStack"},{"type":"text","text":" type shown above can only be used with "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" values, however."},{"text":" ","type":"text"},{"text":"It would be much more useful to define a ","type":"text"},{"inlineContent":[{"type":"text","text":"generic"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" structure,"},{"text":" ","type":"text"},{"type":"text","text":"that can manage a stack of "},{"inlineContent":[{"type":"text","text":"any"}],"type":"emphasis"},{"text":" type of value.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Here’s a generic version of the same code:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["struct Stack<Element> {","    var items: [Element] = []","    mutating func push(_ item: Element) {","        items.append(item)","    }","    mutating func pop() -> Element {","        return items.removeLast()","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note how the generic version of "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" "},{"type":"text","text":"is essentially the same as the nongeneric version,"},{"text":" ","type":"text"},{"text":"but with a type parameter called ","type":"text"},{"type":"codeVoice","code":"Element"},{"text":" ","type":"text"},{"type":"text","text":"instead of an actual type of "},{"code":"Int","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"This type parameter is written within a pair of angle brackets (","type":"text"},{"type":"codeVoice","code":"<Element>"},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"immediately after the structure’s name."}]},{"type":"paragraph","inlineContent":[{"code":"Element","type":"codeVoice"},{"type":"text","text":" defines a placeholder name for"},{"type":"text","text":" "},{"text":"a type to be provided later.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This future type can be referred to as "},{"code":"Element","type":"codeVoice"},{"text":" ","type":"text"},{"text":"anywhere within the structure’s definition.","type":"text"},{"text":" ","type":"text"},{"text":"In this case, ","type":"text"},{"code":"Element","type":"codeVoice"},{"type":"text","text":" is used as a placeholder in three places:"}]},{"items":[{"content":[{"inlineContent":[{"text":"To create a property called ","type":"text"},{"code":"items","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"which is initialized with an empty array of values of type ","type":"text"},{"type":"codeVoice","code":"Element"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"To specify that the "},{"type":"codeVoice","code":"push(_:)"},{"type":"text","text":" method has a single parameter called "},{"code":"item","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which must be of type "},{"type":"codeVoice","code":"Element"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"To specify that the value returned by the ","type":"text"},{"type":"codeVoice","code":"pop()"},{"text":" method","type":"text"},{"type":"text","text":" "},{"text":"will be a value of type ","type":"text"},{"code":"Element","type":"codeVoice"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"Because it’s a generic type,","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" can be used to create a stack of "},{"type":"emphasis","inlineContent":[{"text":"any","type":"text"}]},{"type":"text","text":" valid type in Swift,"},{"text":" ","type":"text"},{"type":"text","text":"in a similar manner to "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Dictionary"},{"text":".","type":"text"}]},{"inlineContent":[{"type":"text","text":"You create a new "},{"code":"Stack","type":"codeVoice"},{"text":" instance by writing","type":"text"},{"text":" ","type":"text"},{"text":"the type to be stored in the stack within angle brackets.","type":"text"},{"type":"text","text":" "},{"text":"For example, to create a new stack of strings,","type":"text"},{"text":" ","type":"text"},{"text":"you write ","type":"text"},{"code":"Stack<String>()","type":"codeVoice"},{"type":"text","text":":"}],"type":"paragraph"},{"code":["var stackOfStrings = Stack<String>()","stackOfStrings.push(\"uno\")","stackOfStrings.push(\"dos\")","stackOfStrings.push(\"tres\")","stackOfStrings.push(\"cuatro\")","\/\/ the stack now contains 4 strings"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Here’s how ","type":"text"},{"type":"codeVoice","code":"stackOfStrings"},{"text":" looks after pushing these four values on to the stack:","type":"text"}]},{"inlineContent":[{"type":"image","identifier":"stackPushedFourStrings"}],"type":"paragraph"},{"inlineContent":[{"text":"Popping a value from the stack removes and returns the top value, ","type":"text"},{"type":"codeVoice","code":"\"cuatro\""},{"text":":","type":"text"}],"type":"paragraph"},{"code":["let fromTheTop = stackOfStrings.pop()","\/\/ fromTheTop is equal to \"cuatro\", and the stack now contains 3 strings"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Here’s how the stack looks after popping its top value:","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"stackPoppedOneString"}]},{"type":"heading","anchor":"Extending-a-Generic-Type","text":"Extending a Generic Type","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"When you extend a generic type,"},{"type":"text","text":" "},{"type":"text","text":"you don’t provide a type parameter list as part of the extension’s definition."},{"text":" ","type":"text"},{"text":"Instead, the type parameter list from the ","type":"text"},{"inlineContent":[{"text":"original","type":"text"}],"type":"emphasis"},{"text":" type definition","type":"text"},{"type":"text","text":" "},{"type":"text","text":"is available within the body of the extension,"},{"type":"text","text":" "},{"type":"text","text":"and the original type parameter names are used to refer to"},{"text":" ","type":"text"},{"text":"the type parameters from the original definition.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The following example extends the generic "},{"code":"Stack","type":"codeVoice"},{"text":" type to add","type":"text"},{"type":"text","text":" "},{"text":"a read-only computed property called ","type":"text"},{"code":"topItem","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"which returns the top item on the stack without popping it from the stack:"}]},{"syntax":"swift","type":"codeListing","code":["extension Stack {","    var topItem: Element? {","        return items.isEmpty ? nil : items[items.count - 1]","    }","}"]},{"inlineContent":[{"type":"text","text":"The "},{"code":"topItem","type":"codeVoice"},{"type":"text","text":" property returns an optional value of type "},{"code":"Element","type":"codeVoice"},{"text":".","type":"text"},{"type":"text","text":" "},{"text":"If the stack is empty, ","type":"text"},{"type":"codeVoice","code":"topItem"},{"type":"text","text":" returns "},{"type":"codeVoice","code":"nil"},{"type":"text","text":";"},{"type":"text","text":" "},{"type":"text","text":"if the stack isn’t empty, "},{"type":"codeVoice","code":"topItem"},{"text":" returns the final item in the ","type":"text"},{"code":"items","type":"codeVoice"},{"text":" array.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that this extension doesn’t define a type parameter list."},{"type":"text","text":" "},{"type":"text","text":"Instead, the "},{"code":"Stack","type":"codeVoice"},{"type":"text","text":" type’s existing type parameter name, "},{"code":"Element","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"is used within the extension to indicate the optional type of","type":"text"},{"type":"text","text":" "},{"text":"the ","type":"text"},{"type":"codeVoice","code":"topItem"},{"type":"text","text":" computed property."}]},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"topItem"},{"type":"text","text":" computed property can now be used with any "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" instance"},{"text":" ","type":"text"},{"type":"text","text":"to access and query its top item without removing it."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["if let topItem = stackOfStrings.topItem {","    print(\"The top item on the stack is \\(topItem).\")","}","\/\/ Prints \"The top item on the stack is tres.\""]},{"type":"paragraph","inlineContent":[{"text":"Extensions of a generic type can also include requirements","type":"text"},{"type":"text","text":" "},{"text":"that instances of the extended type must satisfy","type":"text"},{"text":" ","type":"text"},{"text":"in order to gain the new functionality,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"as discussed in "},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics#Extensions-with-a-Generic-Where-Clause","type":"reference","isActive":true},{"text":" below.","type":"text"}]},{"level":2,"text":"Type Constraints","type":"heading","anchor":"Type-Constraints"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"type":"text","text":" function and the "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" type can work with any type."},{"type":"text","text":" "},{"text":"However, it’s sometimes useful to enforce","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"certain "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type constraints"}]},{"text":" on the types that can be used with","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"generic functions and generic types."},{"text":" ","type":"text"},{"text":"Type constraints specify that a type parameter must","type":"text"},{"type":"text","text":" "},{"type":"text","text":"inherit from a specific class,"},{"type":"text","text":" "},{"text":"or conform to a particular protocol or protocol composition.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example,"},{"text":" ","type":"text"},{"text":"Swift’s ","type":"text"},{"type":"codeVoice","code":"Dictionary"},{"text":" type places a limitation on","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the types that can be used as keys for a dictionary."},{"type":"text","text":" "},{"type":"text","text":"As described in "},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes#Dictionaries","isActive":true},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"the type of a dictionary’s keys must be ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"hashable"}]},{"text":".","type":"text"},{"type":"text","text":" "},{"text":"That is, it must provide a way to make itself uniquely representable.","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" needs its keys to be hashable so that it can"},{"text":" ","type":"text"},{"text":"check whether it already contains a value for a particular key.","type":"text"},{"text":" ","type":"text"},{"text":"Without this requirement, ","type":"text"},{"type":"codeVoice","code":"Dictionary"},{"text":" couldn’t tell","type":"text"},{"type":"text","text":" "},{"type":"text","text":"whether it should insert or replace a value for a particular key,"},{"text":" ","type":"text"},{"text":"nor would it be able to find a value for a given key that’s already in the dictionary.","type":"text"}]},{"inlineContent":[{"type":"text","text":"This requirement is enforced by a type constraint on the key type for "},{"code":"Dictionary","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"which specifies that the key type must conform to the ","type":"text"},{"type":"codeVoice","code":"Hashable"},{"text":" protocol,","type":"text"},{"text":" ","type":"text"},{"text":"a special protocol defined in the Swift standard library.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"All of Swift’s basic types (such as "},{"code":"String","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"Int"},{"text":", ","type":"text"},{"code":"Double","type":"codeVoice"},{"text":", and ","type":"text"},{"type":"codeVoice","code":"Bool"},{"type":"text","text":")"},{"text":" ","type":"text"},{"text":"are hashable by default.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For information about"},{"type":"text","text":" "},{"type":"text","text":"making your own custom types conform to the "},{"code":"Hashable","type":"codeVoice"},{"type":"text","text":" protocol,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/hashable#2849490"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"You can define your own type constraints when creating custom generic types,"},{"text":" ","type":"text"},{"text":"and these constraints provide much of the power of generic programming.","type":"text"},{"text":" ","type":"text"},{"text":"Abstract concepts like ","type":"text"},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" "},{"type":"text","text":"characterize types in terms of their conceptual characteristics,"},{"text":" ","type":"text"},{"type":"text","text":"rather than their concrete type."}],"type":"paragraph"},{"anchor":"Type-Constraint-Syntax","text":"Type Constraint Syntax","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"text":"You write type constraints by placing a single class or protocol constraint","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"after a type parameter’s name, separated by a colon,"},{"type":"text","text":" "},{"text":"as part of the type parameter list.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The basic syntax for type constraints on a generic function is shown below"},{"type":"text","text":" "},{"text":"(although the syntax is the same for generic types):","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["func someFunction<T: SomeClass, U: SomeProtocol>(someT: T, someU: U) {","    \/\/ function body goes here","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The hypothetical function above has two type parameters."},{"text":" ","type":"text"},{"text":"The first type parameter, ","type":"text"},{"type":"codeVoice","code":"T"},{"type":"text","text":", has a type constraint"},{"type":"text","text":" "},{"text":"that requires ","type":"text"},{"code":"T","type":"codeVoice"},{"text":" to be a subclass of ","type":"text"},{"code":"SomeClass","type":"codeVoice"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"The second type parameter, "},{"type":"codeVoice","code":"U"},{"type":"text","text":", has a type constraint"},{"type":"text","text":" "},{"type":"text","text":"that requires "},{"type":"codeVoice","code":"U"},{"type":"text","text":" to conform to the protocol "},{"type":"codeVoice","code":"SomeProtocol"},{"text":".","type":"text"}]},{"text":"Type Constraints in Action","level":3,"type":"heading","anchor":"Type-Constraints-in-Action"},{"inlineContent":[{"type":"text","text":"Here’s a nongeneric function called "},{"code":"findIndex(ofString:in:)","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"which is given a ","type":"text"},{"type":"codeVoice","code":"String"},{"type":"text","text":" value to find"},{"type":"text","text":" "},{"type":"text","text":"and an array of "},{"code":"String","type":"codeVoice"},{"type":"text","text":" values within which to find it."},{"type":"text","text":" "},{"type":"text","text":"The "},{"code":"findIndex(ofString:in:)","type":"codeVoice"},{"type":"text","text":" function returns an optional "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" value,"},{"type":"text","text":" "},{"text":"which will be the index of the first matching string in the array if it’s found,","type":"text"},{"type":"text","text":" "},{"text":"or ","type":"text"},{"code":"nil","type":"codeVoice"},{"type":"text","text":" if the string can’t be found:"}],"type":"paragraph"},{"syntax":"swift","code":["func findIndex(ofString valueToFind: String, in array: [String]) -> Int? {","    for (index, value) in array.enumerated() {","        if value == valueToFind {","            return index","        }","    }","    return nil","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"findIndex(ofString:in:)","type":"codeVoice"},{"type":"text","text":" function can be used to find a string value in an array of strings:"}]},{"type":"codeListing","syntax":"swift","code":["let strings = [\"cat\", \"dog\", \"llama\", \"parakeet\", \"terrapin\"]","if let foundIndex = findIndex(ofString: \"llama\", in: strings) {","    print(\"The index of llama is \\(foundIndex)\")","}","\/\/ Prints \"The index of llama is 2\""]},{"type":"paragraph","inlineContent":[{"text":"The principle of finding the index of a value in an array isn’t useful only for strings, however.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"You can write the same functionality as a generic function"},{"text":" ","type":"text"},{"text":"by replacing any mention of strings with values of some type ","type":"text"},{"type":"codeVoice","code":"T"},{"type":"text","text":" instead."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s how you might expect a generic version of "},{"type":"codeVoice","code":"findIndex(ofString:in:)"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"called "},{"code":"findIndex(of:in:)","type":"codeVoice"},{"type":"text","text":", to be written."},{"text":" ","type":"text"},{"type":"text","text":"Note that the return type of this function is still "},{"type":"codeVoice","code":"Int?"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"because the function returns an optional index number,"},{"type":"text","text":" "},{"type":"text","text":"not an optional value from the array."},{"text":" ","type":"text"},{"type":"text","text":"Be warned, though — this function doesn’t compile,"},{"type":"text","text":" "},{"type":"text","text":"for reasons explained after the example:"}]},{"code":["func findIndex<T>(of valueToFind: T, in array:[T]) -> Int? {","    for (index, value) in array.enumerated() {","        if value == valueToFind {","            return index","        }","    }","    return nil","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"This function doesn’t compile as written above.","type":"text"},{"text":" ","type":"text"},{"text":"The problem lies with the equality check, “","type":"text"},{"type":"codeVoice","code":"if value == valueToFind"},{"type":"text","text":"”."},{"type":"text","text":" "},{"type":"text","text":"Not every type in Swift can be compared with the equal to operator ("},{"type":"codeVoice","code":"=="},{"text":").","type":"text"},{"text":" ","type":"text"},{"text":"If you create your own class or structure to represent a complex data model, for example,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"then the meaning of “equal to” for that class or structure"},{"text":" ","type":"text"},{"text":"isn’t something that Swift can guess for you.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Because of this, it isn’t possible to guarantee that this code will work"},{"type":"text","text":" "},{"type":"text","text":"for "},{"type":"emphasis","inlineContent":[{"text":"every","type":"text"}]},{"type":"text","text":" possible type "},{"type":"codeVoice","code":"T"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and an appropriate error is reported when you try to compile the code."}]},{"type":"paragraph","inlineContent":[{"text":"All is not lost, however.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The Swift standard library defines a protocol called "},{"code":"Equatable","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"which requires any conforming type to implement","type":"text"},{"type":"text","text":" "},{"text":"the equal to operator (","type":"text"},{"type":"codeVoice","code":"=="},{"type":"text","text":") and the not equal to operator ("},{"code":"!=","type":"codeVoice"},{"text":")","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to compare any two values of that type."},{"text":" ","type":"text"},{"text":"All of Swift’s standard types automatically support the ","type":"text"},{"type":"codeVoice","code":"Equatable"},{"text":" protocol.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Any type that’s "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" can be used safely with the "},{"code":"findIndex(of:in:)","type":"codeVoice"},{"type":"text","text":" function,"},{"text":" ","type":"text"},{"type":"text","text":"because it’s guaranteed to support the equal to operator."},{"type":"text","text":" "},{"type":"text","text":"To express this fact, you write a type constraint of "},{"type":"codeVoice","code":"Equatable"},{"text":" ","type":"text"},{"type":"text","text":"as part of the type parameter’s definition when you define the function:"}]},{"type":"codeListing","syntax":"swift","code":["func findIndex<T: Equatable>(of valueToFind: T, in array:[T]) -> Int? {","    for (index, value) in array.enumerated() {","        if value == valueToFind {","            return index","        }","    }","    return nil","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The single type parameter for "},{"code":"findIndex(of:in:)","type":"codeVoice"},{"text":" is written as ","type":"text"},{"type":"codeVoice","code":"T: Equatable"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which means “any type "},{"code":"T","type":"codeVoice"},{"text":" that conforms to the ","type":"text"},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" protocol.”"}]},{"inlineContent":[{"text":"The ","type":"text"},{"code":"findIndex(of:in:)","type":"codeVoice"},{"type":"text","text":" function now compiles successfully"},{"type":"text","text":" "},{"type":"text","text":"and can be used with any type that’s "},{"type":"codeVoice","code":"Equatable"},{"text":", such as ","type":"text"},{"type":"codeVoice","code":"Double"},{"type":"text","text":" or "},{"type":"codeVoice","code":"String"},{"type":"text","text":":"}],"type":"paragraph"},{"syntax":"swift","code":["let doubleIndex = findIndex(of: 9.3, in: [3.14159, 0.1, 0.25])","\/\/ doubleIndex is an optional Int with no value, because 9.3 isn't in the array","let stringIndex = findIndex(of: \"Andrea\", in: [\"Mike\", \"Malcolm\", \"Andrea\"])","\/\/ stringIndex is an optional Int containing a value of 2"],"type":"codeListing"},{"level":2,"text":"Associated Types","anchor":"Associated-Types","type":"heading"},{"inlineContent":[{"type":"text","text":"When defining a protocol,"},{"type":"text","text":" "},{"type":"text","text":"it’s sometimes useful to declare one or more associated types"},{"type":"text","text":" "},{"text":"as part of the protocol’s definition.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"An "},{"inlineContent":[{"text":"associated type","type":"text"}],"type":"emphasis"},{"type":"text","text":" gives a placeholder name"},{"type":"text","text":" "},{"text":"to a type that’s used as part of the protocol.","type":"text"},{"type":"text","text":" "},{"text":"The actual type to use for that associated type","type":"text"},{"type":"text","text":" "},{"text":"isn’t specified until the protocol is adopted.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Associated types are specified with the "},{"type":"codeVoice","code":"associatedtype"},{"type":"text","text":" keyword."}],"type":"paragraph"},{"type":"heading","level":3,"anchor":"Associated-Types-in-Action","text":"Associated Types in Action"},{"inlineContent":[{"type":"text","text":"Here’s an example of a protocol called "},{"type":"codeVoice","code":"Container"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"which declares an associated type called "},{"code":"Item","type":"codeVoice"},{"type":"text","text":":"}],"type":"paragraph"},{"code":["protocol Container {","    associatedtype Item","    mutating func append(_ item: Item)","    var count: Int { get }","    subscript(i: Int) -> Item { get }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"Container","type":"codeVoice"},{"type":"text","text":" protocol defines three required capabilities"},{"type":"text","text":" "},{"type":"text","text":"that any container must provide:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"It must be possible to add a new item to the container with an "},{"type":"codeVoice","code":"append(_:)"},{"type":"text","text":" method."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"It must be possible to access a count of the items in the container","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"through a "},{"type":"codeVoice","code":"count"},{"text":" property that returns an ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":" value.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"It must be possible to retrieve each item in the container with a subscript"},{"type":"text","text":" "},{"type":"text","text":"that takes an "},{"code":"Int","type":"codeVoice"},{"text":" index value.","type":"text"}],"type":"paragraph"}]}]},{"inlineContent":[{"text":"This protocol doesn’t specify how the items in the container should be stored","type":"text"},{"type":"text","text":" "},{"text":"or what type they’re allowed to be.","type":"text"},{"text":" ","type":"text"},{"text":"The protocol only specifies the three bits of functionality","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that any type must provide in order to be considered a "},{"type":"codeVoice","code":"Container"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"A conforming type can provide additional functionality,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"as long as it satisfies these three requirements."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Any type that conforms to the "},{"code":"Container","type":"codeVoice"},{"type":"text","text":" protocol must be able to specify"},{"type":"text","text":" "},{"text":"the type of values it stores.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Specifically, it must ensure that only items of the right type"},{"type":"text","text":" "},{"text":"are added to the container,","type":"text"},{"text":" ","type":"text"},{"text":"and it must be clear about the type of the items returned by its subscript.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"To define these requirements,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol needs a way to refer to"},{"text":" ","type":"text"},{"type":"text","text":"the type of the elements that a container will hold,"},{"type":"text","text":" "},{"text":"without knowing what that type is for a specific container.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The "},{"code":"Container","type":"codeVoice"},{"text":" protocol needs to specify that","type":"text"},{"text":" ","type":"text"},{"text":"any value passed to the ","type":"text"},{"type":"codeVoice","code":"append(_:)"},{"type":"text","text":" method"},{"type":"text","text":" "},{"type":"text","text":"must have the same type as the container’s element type,"},{"text":" ","type":"text"},{"text":"and that the value returned by the container’s subscript","type":"text"},{"type":"text","text":" "},{"text":"will be of the same type as the container’s element type.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"To achieve this,"},{"type":"text","text":" "},{"text":"the ","type":"text"},{"type":"codeVoice","code":"Container"},{"text":" protocol declares an associated type called ","type":"text"},{"type":"codeVoice","code":"Item"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"written as  "},{"type":"codeVoice","code":"associatedtype Item"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The protocol doesn’t define what "},{"type":"codeVoice","code":"Item"},{"text":" is —","type":"text"},{"type":"text","text":" "},{"text":"that information is left for any conforming type to provide.","type":"text"},{"type":"text","text":" "},{"text":"Nonetheless, the ","type":"text"},{"type":"codeVoice","code":"Item"},{"text":" alias provides a way to refer to","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the type of the items in a "},{"type":"codeVoice","code":"Container"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"and to define a type for use with the ","type":"text"},{"code":"append(_:)","type":"codeVoice"},{"text":" method and subscript,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to ensure that the expected behavior of any "},{"type":"codeVoice","code":"Container"},{"text":" is enforced.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s a version of the nongeneric "},{"type":"codeVoice","code":"IntStack"},{"text":" type","type":"text"},{"type":"text","text":" "},{"text":"from ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics#Generic-Types"},{"type":"text","text":" above,"},{"type":"text","text":" "},{"type":"text","text":"adapted to conform to the "},{"code":"Container","type":"codeVoice"},{"text":" protocol:","type":"text"}]},{"type":"codeListing","code":["struct IntStack: Container {","    \/\/ original IntStack implementation","    var items: [Int] = []","    mutating func push(_ item: Int) {","        items.append(item)","    }","    mutating func pop() -> Int {","        return items.removeLast()","    }","    \/\/ conformance to the Container protocol","    typealias Item = Int","    mutating func append(_ item: Int) {","        self.push(item)","    }","    var count: Int {","        return items.count","    }","    subscript(i: Int) -> Int {","        return items[i]","    }","}"],"syntax":"swift"},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"IntStack"},{"type":"text","text":" type implements all three of the "},{"code":"Container","type":"codeVoice"},{"text":" protocol’s requirements,","type":"text"},{"type":"text","text":" "},{"text":"and in each case wraps part of the ","type":"text"},{"type":"codeVoice","code":"IntStack"},{"text":" type’s existing functionality","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to satisfy these requirements."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Moreover, "},{"type":"codeVoice","code":"IntStack"},{"type":"text","text":" specifies that for this implementation of "},{"code":"Container","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"the appropriate ","type":"text"},{"code":"Item","type":"codeVoice"},{"text":" to use is a type of ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The definition of "},{"type":"codeVoice","code":"typealias Item = Int"},{"type":"text","text":" turns the abstract type of "},{"type":"codeVoice","code":"Item"},{"text":" ","type":"text"},{"type":"text","text":"into a concrete type of "},{"type":"codeVoice","code":"Int"},{"text":" for this implementation of the ","type":"text"},{"code":"Container","type":"codeVoice"},{"text":" protocol.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Thanks to Swift’s type inference,"},{"type":"text","text":" "},{"text":"you don’t actually need to declare a concrete ","type":"text"},{"type":"codeVoice","code":"Item"},{"text":" of ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":" "},{"text":"as part of the definition of ","type":"text"},{"type":"codeVoice","code":"IntStack"},{"text":".","type":"text"},{"type":"text","text":" "},{"text":"Because ","type":"text"},{"code":"IntStack","type":"codeVoice"},{"text":" conforms to all of the requirements of the ","type":"text"},{"code":"Container","type":"codeVoice"},{"text":" protocol,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Swift can infer the appropriate "},{"code":"Item","type":"codeVoice"},{"type":"text","text":" to use,"},{"text":" ","type":"text"},{"text":"simply by looking at the type of the ","type":"text"},{"type":"codeVoice","code":"append(_:)"},{"text":" method’s ","type":"text"},{"type":"codeVoice","code":"item"},{"type":"text","text":" parameter"},{"text":" ","type":"text"},{"text":"and the return type of the subscript.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Indeed, if you delete the "},{"code":"typealias Item = Int","type":"codeVoice"},{"text":" line from the code above,","type":"text"},{"type":"text","text":" "},{"text":"everything still works, because it’s clear what type should be used for ","type":"text"},{"type":"codeVoice","code":"Item"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"You can also make the generic ","type":"text"},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" type conform to the "},{"code":"Container","type":"codeVoice"},{"type":"text","text":" protocol:"}]},{"syntax":"swift","type":"codeListing","code":["struct Stack<Element>: Container {","    \/\/ original Stack<Element> implementation","    var items: [Element] = []","    mutating func push(_ item: Element) {","        items.append(item)","    }","    mutating func pop() -> Element {","        return items.removeLast()","    }","    \/\/ conformance to the Container protocol","    mutating func append(_ item: Element) {","        self.push(item)","    }","    var count: Int {","        return items.count","    }","    subscript(i: Int) -> Element {","        return items[i]","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This time, the type parameter "},{"type":"codeVoice","code":"Element"},{"text":" is used as","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the type of the "},{"code":"append(_:)","type":"codeVoice"},{"text":" method’s ","type":"text"},{"code":"item","type":"codeVoice"},{"type":"text","text":" parameter"},{"type":"text","text":" "},{"text":"and the return type of the subscript.","type":"text"},{"type":"text","text":" "},{"text":"Swift can therefore infer that ","type":"text"},{"code":"Element","type":"codeVoice"},{"text":" is the appropriate type to use","type":"text"},{"type":"text","text":" "},{"type":"text","text":"as the "},{"code":"Item","type":"codeVoice"},{"type":"text","text":" for this particular container."}]},{"type":"heading","text":"Extending an Existing Type to Specify an Associated Type","level":3,"anchor":"Extending-an-Existing-Type-to-Specify-an-Associated-Type"},{"inlineContent":[{"type":"text","text":"You can extend an existing type to add conformance to a protocol,"},{"text":" ","type":"text"},{"text":"as described in ","type":"text"},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Adding-Protocol-Conformance-with-an-Extension","isActive":true,"type":"reference"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"This includes a protocol with an associated type.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Swift’s ","type":"text"},{"type":"codeVoice","code":"Array"},{"type":"text","text":" type already provides an "},{"type":"codeVoice","code":"append(_:)"},{"type":"text","text":" method,"},{"type":"text","text":" "},{"text":"a ","type":"text"},{"type":"codeVoice","code":"count"},{"text":" property, and a subscript with an ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":" index to retrieve its elements."},{"text":" ","type":"text"},{"type":"text","text":"These three capabilities match the requirements of the "},{"code":"Container","type":"codeVoice"},{"type":"text","text":" protocol."},{"text":" ","type":"text"},{"type":"text","text":"This means that you can extend "},{"type":"codeVoice","code":"Array"},{"text":" to conform to the ","type":"text"},{"type":"codeVoice","code":"Container"},{"text":" protocol","type":"text"},{"type":"text","text":" "},{"type":"text","text":"simply by declaring that "},{"code":"Array","type":"codeVoice"},{"type":"text","text":" adopts the protocol."},{"type":"text","text":" "},{"type":"text","text":"You do this with an empty extension,"},{"type":"text","text":" "},{"text":"as described in ","type":"text"},{"isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Declaring-Protocol-Adoption-with-an-Extension","type":"reference"},{"text":":","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["extension Array: Container {}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Array’s existing "},{"code":"append(_:)","type":"codeVoice"},{"text":" method and subscript enable Swift to infer","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the appropriate type to use for "},{"type":"codeVoice","code":"Item"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"just as for the generic "},{"code":"Stack","type":"codeVoice"},{"text":" type above.","type":"text"},{"type":"text","text":" "},{"text":"After defining this extension, you can use any ","type":"text"},{"code":"Array","type":"codeVoice"},{"text":" as a ","type":"text"},{"type":"codeVoice","code":"Container"},{"type":"text","text":"."}]},{"type":"heading","level":3,"anchor":"Adding-Constraints-to-an-Associated-Type","text":"Adding Constraints to an Associated Type"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can add type constraints to an associated type in a protocol"},{"text":" ","type":"text"},{"text":"to require that conforming types satisfy those constraints.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"the following code defines a version of "},{"code":"Container","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"that requires the items in the container to be equatable."}]},{"type":"codeListing","syntax":"swift","code":["protocol Container {","    associatedtype Item: Equatable","    mutating func append(_ item: Item)","    var count: Int { get }","    subscript(i: Int) -> Item { get }","}"]},{"inlineContent":[{"type":"text","text":"To conform to this version of "},{"type":"codeVoice","code":"Container"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the container’s "},{"code":"Item","type":"codeVoice"},{"type":"text","text":" type has to conform to the "},{"code":"Equatable","type":"codeVoice"},{"text":" protocol.","type":"text"}],"type":"paragraph"},{"anchor":"Using-a-Protocol-in-Its-Associated-Types-Constraints","level":3,"type":"heading","text":"Using a Protocol in Its Associated Type’s Constraints"},{"inlineContent":[{"text":"A protocol can appear as part of its own requirements.","type":"text"},{"text":" ","type":"text"},{"text":"For example,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"here’s a protocol that refines the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol,"},{"text":" ","type":"text"},{"type":"text","text":"adding the requirement of a "},{"type":"codeVoice","code":"suffix(_:)"},{"type":"text","text":" method."},{"type":"text","text":" "},{"text":"The ","type":"text"},{"type":"codeVoice","code":"suffix(_:)"},{"text":" method","type":"text"},{"text":" ","type":"text"},{"text":"returns a given number of elements from the end of the container,","type":"text"},{"text":" ","type":"text"},{"text":"storing them in an instance of the ","type":"text"},{"code":"Suffix","type":"codeVoice"},{"type":"text","text":" type."}],"type":"paragraph"},{"code":["protocol SuffixableContainer: Container {","    associatedtype Suffix: SuffixableContainer where Suffix.Item == Item","    func suffix(_ size: Int) -> Suffix","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"In this protocol,","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"Suffix"},{"text":" is an associated type,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"like the "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" type in the "},{"type":"codeVoice","code":"Container"},{"text":" example above.","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"Suffix"},{"text":" has two constraints:","type":"text"},{"type":"text","text":" "},{"type":"text","text":"It must conform to the "},{"type":"codeVoice","code":"SuffixableContainer"},{"text":" protocol","type":"text"},{"type":"text","text":" "},{"type":"text","text":"(the protocol currently being defined),"},{"type":"text","text":" "},{"type":"text","text":"and its "},{"code":"Item","type":"codeVoice"},{"type":"text","text":" type must be the same"},{"text":" ","type":"text"},{"type":"text","text":"as the container’s "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" type."},{"text":" ","type":"text"},{"type":"text","text":"The constraint on "},{"type":"codeVoice","code":"Item"},{"text":" is a generic ","type":"text"},{"type":"codeVoice","code":"where"},{"text":" clause,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"which is discussed in "},{"isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics#Associated-Types-with-a-Generic-Where-Clause","type":"reference"},{"type":"text","text":" below."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s an extension of the "},{"code":"Stack","type":"codeVoice"},{"text":" type","type":"text"},{"type":"text","text":" "},{"text":"from ","type":"text"},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics#Generic-Types","isActive":true,"type":"reference"},{"type":"text","text":" above"},{"text":" ","type":"text"},{"text":"that adds conformance to the ","type":"text"},{"type":"codeVoice","code":"SuffixableContainer"},{"type":"text","text":" protocol:"}]},{"type":"codeListing","code":["extension Stack: SuffixableContainer {","    func suffix(_ size: Int) -> Stack {","        var result = Stack()","        for index in (count-size)..<count {","            result.append(self[index])","        }","        return result","    }","    \/\/ Inferred that Suffix is Stack.","}","var stackOfInts = Stack<Int>()","stackOfInts.append(10)","stackOfInts.append(20)","stackOfInts.append(30)","let suffix = stackOfInts.suffix(2)","\/\/ suffix contains 20 and 30"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"In the example above,","type":"text"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"code":"Suffix","type":"codeVoice"},{"text":" associated type for ","type":"text"},{"code":"Stack","type":"codeVoice"},{"text":" is also ","type":"text"},{"type":"codeVoice","code":"Stack"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"so the suffix operation on ","type":"text"},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" returns another "},{"type":"codeVoice","code":"Stack"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Alternatively,"},{"text":" ","type":"text"},{"text":"a type that conforms to ","type":"text"},{"code":"SuffixableContainer","type":"codeVoice"},{"type":"text","text":" "},{"text":"can have a ","type":"text"},{"type":"codeVoice","code":"Suffix"},{"type":"text","text":" type that’s different from itself —"},{"type":"text","text":" "},{"type":"text","text":"meaning the suffix operation can return a different type."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"text":" ","type":"text"},{"text":"here’s an extension to the nongeneric ","type":"text"},{"type":"codeVoice","code":"IntStack"},{"text":" type","type":"text"},{"type":"text","text":" "},{"text":"that adds ","type":"text"},{"type":"codeVoice","code":"SuffixableContainer"},{"type":"text","text":" conformance,"},{"text":" ","type":"text"},{"type":"text","text":"using "},{"type":"codeVoice","code":"Stack<Int>"},{"type":"text","text":" as its suffix type instead of "},{"type":"codeVoice","code":"IntStack"},{"type":"text","text":":"}]},{"type":"codeListing","code":["extension IntStack: SuffixableContainer {","    func suffix(_ size: Int) -> Stack<Int> {","        var result = Stack<Int>()","        for index in (count-size)..<count {","            result.append(self[index])","        }","        return result","    }","    \/\/ Inferred that Suffix is Stack<Int>.","}"],"syntax":"swift"},{"level":2,"type":"heading","text":"Generic Where Clauses","anchor":"Generic-Where-Clauses"},{"inlineContent":[{"type":"text","text":"Type constraints, as described in "},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics#Type-Constraints","isActive":true},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"enable you to define requirements on the type parameters associated with"},{"text":" ","type":"text"},{"text":"a generic function, subscript, or type.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"It can also be useful to define requirements for associated types."},{"type":"text","text":" "},{"text":"You do this by defining a ","type":"text"},{"inlineContent":[{"type":"text","text":"generic where clause"}],"type":"emphasis"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"A generic "},{"code":"where","type":"codeVoice"},{"type":"text","text":" clause enables you to require that"},{"text":" ","type":"text"},{"type":"text","text":"an associated type must conform to a certain protocol,"},{"type":"text","text":" "},{"text":"or that certain type parameters and associated types must be the same.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"A generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause starts with the "},{"code":"where","type":"codeVoice"},{"type":"text","text":" keyword,"},{"type":"text","text":" "},{"text":"followed by constraints for associated types","type":"text"},{"type":"text","text":" "},{"type":"text","text":"or equality relationships between types and associated types."},{"text":" ","type":"text"},{"type":"text","text":"You write a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause right before the opening curly brace"},{"text":" ","type":"text"},{"type":"text","text":"of a type or function’s body."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example below defines a generic function called "},{"type":"codeVoice","code":"allItemsMatch"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"which checks to see if two ","type":"text"},{"type":"codeVoice","code":"Container"},{"text":" instances contain","type":"text"},{"type":"text","text":" "},{"text":"the same items in the same order.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The function returns a Boolean value of "},{"type":"codeVoice","code":"true"},{"text":" if all items match","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and a value of "},{"type":"codeVoice","code":"false"},{"text":" if they don’t.","type":"text"}]},{"inlineContent":[{"text":"The two containers to be checked don’t have to be","type":"text"},{"type":"text","text":" "},{"text":"the same type of container (although they can be),","type":"text"},{"type":"text","text":" "},{"text":"but they do have to hold the same type of items.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This requirement is expressed through a combination of type constraints"},{"text":" ","type":"text"},{"text":"and a generic ","type":"text"},{"code":"where","type":"codeVoice"},{"text":" clause:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["func allItemsMatch<C1: Container, C2: Container>","        (_ someContainer: C1, _ anotherContainer: C2) -> Bool","        where C1.Item == C2.Item, C1.Item: Equatable {","","    \/\/ Check that both containers contain the same number of items.","    if someContainer.count != anotherContainer.count {","        return false","    }","","    \/\/ Check each pair of items to see if they're equivalent.","    for i in 0..<someContainer.count {","        if someContainer[i] != anotherContainer[i] {","            return false","        }","    }","","    \/\/ All items match, so return true.","    return true","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"This function takes two arguments called"},{"type":"text","text":" "},{"code":"someContainer","type":"codeVoice"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"anotherContainer"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The "},{"code":"someContainer","type":"codeVoice"},{"type":"text","text":" argument is of type "},{"type":"codeVoice","code":"C1"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"and the "},{"type":"codeVoice","code":"anotherContainer"},{"type":"text","text":" argument is of type "},{"type":"codeVoice","code":"C2"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Both "},{"type":"codeVoice","code":"C1"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"C2"},{"type":"text","text":" are type parameters"},{"type":"text","text":" "},{"type":"text","text":"for two container types to be determined when the function is called."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The following requirements are placed on the function’s two type parameters:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"C1"},{"text":" must conform to the ","type":"text"},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol (written as "},{"code":"C1: Container","type":"codeVoice"},{"text":").","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"C2"},{"text":" must also conform to the ","type":"text"},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol (written as "},{"type":"codeVoice","code":"C2: Container"},{"text":").","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"Item"},{"type":"text","text":" for "},{"type":"codeVoice","code":"C1"},{"type":"text","text":" must be the same as the "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" for "},{"type":"codeVoice","code":"C2"},{"type":"text","text":" "},{"text":"(written as ","type":"text"},{"type":"codeVoice","code":"C1.Item == C2.Item"},{"type":"text","text":")."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"Item","type":"codeVoice"},{"text":" for ","type":"text"},{"code":"C1","type":"codeVoice"},{"text":" must conform to the ","type":"text"},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" protocol"},{"type":"text","text":" "},{"type":"text","text":"(written as "},{"code":"C1.Item: Equatable","type":"codeVoice"},{"text":").","type":"text"}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"The first and second requirements are defined in the function’s type parameter list,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and the third and fourth requirements are defined in the function’s generic "},{"type":"codeVoice","code":"where"},{"text":" clause.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"These requirements mean:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"someContainer","type":"codeVoice"},{"text":" is a container of type ","type":"text"},{"code":"C1","type":"codeVoice"},{"text":".","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"anotherContainer"},{"type":"text","text":" is a container of type "},{"type":"codeVoice","code":"C2"},{"text":".","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"someContainer"},{"type":"text","text":" and "},{"code":"anotherContainer","type":"codeVoice"},{"text":" contain the same type of items.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"The items in "},{"type":"codeVoice","code":"someContainer"},{"type":"text","text":" can be checked with the not equal operator ("},{"type":"codeVoice","code":"!="},{"type":"text","text":")"},{"text":" ","type":"text"},{"text":"to see if they’re different from each other.","type":"text"}],"type":"paragraph"}]}]},{"inlineContent":[{"type":"text","text":"The third and fourth requirements combine to mean that"},{"type":"text","text":" "},{"text":"the items in ","type":"text"},{"type":"codeVoice","code":"anotherContainer"},{"text":" can ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"also","type":"text"}]},{"type":"text","text":" be checked with the "},{"type":"codeVoice","code":"!="},{"text":" operator,","type":"text"},{"text":" ","type":"text"},{"text":"because they’re exactly the same type as the items in ","type":"text"},{"type":"codeVoice","code":"someContainer"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"These requirements enable the ","type":"text"},{"type":"codeVoice","code":"allItemsMatch(_:_:)"},{"type":"text","text":" function to compare the two containers,"},{"type":"text","text":" "},{"type":"text","text":"even if they’re of a different container type."}]},{"inlineContent":[{"text":"The ","type":"text"},{"code":"allItemsMatch(_:_:)","type":"codeVoice"},{"text":" function starts by checking that","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"both containers contain the same number of items."},{"type":"text","text":" "},{"type":"text","text":"If they contain a different number of items, there’s no way that they can match,"},{"type":"text","text":" "},{"type":"text","text":"and the function returns "},{"code":"false","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"After making this check, the function iterates over all of the items in "},{"code":"someContainer","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"with a "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"code":"in","type":"codeVoice"},{"type":"text","text":" loop and the half-open range operator ("},{"code":"..<","type":"codeVoice"},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"For each item, the function checks whether the item from "},{"type":"codeVoice","code":"someContainer"},{"text":" isn’t equal to","type":"text"},{"type":"text","text":" "},{"text":"the corresponding item in ","type":"text"},{"type":"codeVoice","code":"anotherContainer"},{"type":"text","text":"."},{"text":" ","type":"text"},{"text":"If the two items aren’t equal, then the two containers don’t match,","type":"text"},{"type":"text","text":" "},{"text":"and the function returns ","type":"text"},{"type":"codeVoice","code":"false"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"If the loop finishes without finding a mismatch,","type":"text"},{"text":" ","type":"text"},{"text":"the two containers match, and the function returns ","type":"text"},{"type":"codeVoice","code":"true"},{"type":"text","text":"."}]},{"inlineContent":[{"type":"text","text":"Here’s how the "},{"code":"allItemsMatch(_:_:)","type":"codeVoice"},{"type":"text","text":" function looks in action:"}],"type":"paragraph"},{"syntax":"swift","code":["var stackOfStrings = Stack<String>()","stackOfStrings.push(\"uno\")","stackOfStrings.push(\"dos\")","stackOfStrings.push(\"tres\")","","var arrayOfStrings = [\"uno\", \"dos\", \"tres\"]","","if allItemsMatch(stackOfStrings, arrayOfStrings) {","    print(\"All items match.\")","} else {","    print(\"Not all items match.\")","}","\/\/ Prints \"All items match.\""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"The example above creates a ","type":"text"},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" instance to store "},{"type":"codeVoice","code":"String"},{"text":" values,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and pushes three strings onto the stack."},{"type":"text","text":" "},{"text":"The example also creates an ","type":"text"},{"type":"codeVoice","code":"Array"},{"text":" instance initialized with","type":"text"},{"type":"text","text":" "},{"text":"an array literal containing the same three strings as the stack.","type":"text"},{"type":"text","text":" "},{"text":"Even though the stack and the array are of a different type,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"they both conform to the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol,"},{"text":" ","type":"text"},{"text":"and both contain the same type of values.","type":"text"},{"type":"text","text":" "},{"text":"You can therefore call the ","type":"text"},{"code":"allItemsMatch(_:_:)","type":"codeVoice"},{"type":"text","text":" function"},{"text":" ","type":"text"},{"text":"with these two containers as its arguments.","type":"text"},{"type":"text","text":" "},{"text":"In the example above, the ","type":"text"},{"type":"codeVoice","code":"allItemsMatch(_:_:)"},{"text":" function correctly reports that","type":"text"},{"type":"text","text":" "},{"type":"text","text":"all of the items in the two containers match."}]},{"text":"Extensions with a Generic Where Clause","anchor":"Extensions-with-a-Generic-Where-Clause","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can also use a generic "},{"code":"where","type":"codeVoice"},{"type":"text","text":" clause as part of an extension."},{"type":"text","text":" "},{"text":"The example below","type":"text"},{"type":"text","text":" "},{"type":"text","text":"extends the generic "},{"code":"Stack","type":"codeVoice"},{"type":"text","text":" structure from the previous examples"},{"text":" ","type":"text"},{"type":"text","text":"to add an "},{"type":"codeVoice","code":"isTop(_:)"},{"type":"text","text":" method."}]},{"type":"codeListing","syntax":"swift","code":["extension Stack where Element: Equatable {","    func isTop(_ item: Element) -> Bool {","        guard let topItem = items.last else {","            return false","        }","        return topItem == item","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"This new ","type":"text"},{"type":"codeVoice","code":"isTop(_:)"},{"type":"text","text":" method"},{"text":" ","type":"text"},{"type":"text","text":"first checks that the stack isn’t empty,"},{"type":"text","text":" "},{"type":"text","text":"and then compares the given item"},{"type":"text","text":" "},{"text":"against the stack’s topmost item.","type":"text"},{"text":" ","type":"text"},{"text":"If you tried to do this without a generic ","type":"text"},{"code":"where","type":"codeVoice"},{"type":"text","text":" clause,"},{"type":"text","text":" "},{"text":"you would have a problem:","type":"text"},{"type":"text","text":" "},{"text":"The implementation of ","type":"text"},{"type":"codeVoice","code":"isTop(_:)"},{"type":"text","text":" uses the "},{"type":"codeVoice","code":"=="},{"type":"text","text":" operator,"},{"text":" ","type":"text"},{"text":"but the definition of ","type":"text"},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" doesn’t require"},{"type":"text","text":" "},{"type":"text","text":"its items to be equatable,"},{"text":" ","type":"text"},{"type":"text","text":"so using the "},{"code":"==","type":"codeVoice"},{"text":" operator results in a compile-time error.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Using a generic "},{"code":"where","type":"codeVoice"},{"text":" clause","type":"text"},{"text":" ","type":"text"},{"text":"lets you add a new requirement to the extension,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"so that the extension adds the "},{"code":"isTop(_:)","type":"codeVoice"},{"text":" method","type":"text"},{"type":"text","text":" "},{"text":"only when the items in the stack are equatable.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s how the "},{"type":"codeVoice","code":"isTop(_:)"},{"text":" method looks in action:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["if stackOfStrings.isTop(\"tres\") {","    print(\"Top element is tres.\")","} else {","    print(\"Top element is something else.\")","}","\/\/ Prints \"Top element is tres.\""]},{"type":"paragraph","inlineContent":[{"text":"If you try to call the ","type":"text"},{"code":"isTop(_:)","type":"codeVoice"},{"type":"text","text":" method"},{"text":" ","type":"text"},{"type":"text","text":"on a stack whose elements aren’t equatable,"},{"type":"text","text":" "},{"type":"text","text":"you’ll get a compile-time error."}]},{"type":"codeListing","syntax":"swift","code":["struct NotEquatable { }","var notEquatableStack = Stack<NotEquatable>()","let notEquatableValue = NotEquatable()","notEquatableStack.push(notEquatableValue)","notEquatableStack.isTop(notEquatableValue)  \/\/ Error"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause with extensions to a protocol."},{"type":"text","text":" "},{"type":"text","text":"The example below extends the "},{"code":"Container","type":"codeVoice"},{"type":"text","text":" protocol from the previous examples"},{"type":"text","text":" "},{"type":"text","text":"to add a "},{"type":"codeVoice","code":"startsWith(_:)"},{"text":" method.","type":"text"}]},{"code":["extension Container where Item: Equatable {","    func startsWith(_ item: Item) -> Bool {","        return count >= 1 && self[0] == item","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"startsWith(_:)","type":"codeVoice"},{"text":" method","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"first makes sure that the container has at least one item,"},{"type":"text","text":" "},{"text":"and then it checks","type":"text"},{"type":"text","text":" "},{"text":"whether the first item in the container matches the given item.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"This new "},{"code":"startsWith(_:)","type":"codeVoice"},{"text":" method","type":"text"},{"text":" ","type":"text"},{"text":"can be used with any type that conforms to the ","type":"text"},{"code":"Container","type":"codeVoice"},{"text":" protocol,","type":"text"},{"text":" ","type":"text"},{"text":"including the stacks and arrays used above,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"as long as the container’s items are equatable."}]},{"code":["if [9, 9, 9].startsWith(42) {","    print(\"Starts with 42.\")","} else {","    print(\"Starts with something else.\")","}","\/\/ Prints \"Starts with something else.\""],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The generic ","type":"text"},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause in the example above"},{"text":" ","type":"text"},{"type":"text","text":"requires "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" to conform to a protocol,"},{"type":"text","text":" "},{"text":"but you can also write a generic ","type":"text"},{"code":"where","type":"codeVoice"},{"type":"text","text":" clauses that require "},{"code":"Item","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"to be a specific type."},{"text":" ","type":"text"},{"type":"text","text":"For example:"}]},{"syntax":"swift","type":"codeListing","code":["extension Container where Item == Double {","    func average() -> Double {","        var sum = 0.0","        for index in 0..<count {","            sum += self[index]","        }","        return sum \/ Double(count)","    }","}","print([1260.0, 1200.0, 98.6, 37.0].average())","\/\/ Prints \"648.9\""]},{"inlineContent":[{"type":"text","text":"This example adds an "},{"type":"codeVoice","code":"average()"},{"type":"text","text":" method"},{"type":"text","text":" "},{"text":"to containers whose ","type":"text"},{"type":"codeVoice","code":"Item"},{"text":" type is ","type":"text"},{"type":"codeVoice","code":"Double"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"It iterates over the items in the container to add them up,"},{"type":"text","text":" "},{"text":"and divides by the container’s count to compute the average.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"It explicitly converts the count from "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" to "},{"code":"Double","type":"codeVoice"},{"text":" ","type":"text"},{"text":"to be able to do floating-point division.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"You can include multiple requirements in a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause"},{"type":"text","text":" "},{"type":"text","text":"that’s part of an extension,"},{"type":"text","text":" "},{"type":"text","text":"just like you can for a generic "},{"code":"where","type":"codeVoice"},{"type":"text","text":" clause that you write elsewhere."},{"type":"text","text":" "},{"type":"text","text":"Separate each requirement in the list with a comma."}],"type":"paragraph"},{"type":"heading","level":2,"anchor":"Contextual-Where-Clauses","text":"Contextual Where Clauses"},{"inlineContent":[{"type":"text","text":"You can write a generic "},{"code":"where","type":"codeVoice"},{"text":" clause","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"as part of a declaration that doesn’t have its own generic type constraints,"},{"type":"text","text":" "},{"type":"text","text":"when you’re already working in the context of generic types."},{"text":" ","type":"text"},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"text":"you can write a generic ","type":"text"},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause"},{"type":"text","text":" "},{"type":"text","text":"on a subscript of a generic type"},{"type":"text","text":" "},{"type":"text","text":"or on a method in an extension to a generic type."},{"text":" ","type":"text"},{"type":"text","text":"The "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" structure is generic,"},{"text":" ","type":"text"},{"type":"text","text":"and the "},{"type":"codeVoice","code":"where"},{"text":" clauses in the example below","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"specify what type constraints have to be satisfied"},{"type":"text","text":" "},{"type":"text","text":"to make these new  methods available on a container."}],"type":"paragraph"},{"syntax":"swift","code":["extension Container {","    func average() -> Double where Item == Int {","        var sum = 0.0","        for index in 0..<count {","            sum += Double(self[index])","        }","        return sum \/ Double(count)","    }","    func endsWith(_ item: Item) -> Bool where Item: Equatable {","        return count >= 1 && self[count-1] == item","    }","}","let numbers = [1260, 1200, 98, 37]","print(numbers.average())","\/\/ Prints \"648.75\"","print(numbers.endsWith(37))","\/\/ Prints \"true\""],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"This example"},{"text":" ","type":"text"},{"type":"text","text":"adds an "},{"type":"codeVoice","code":"average()"},{"type":"text","text":" method to "},{"code":"Container","type":"codeVoice"},{"type":"text","text":" when the items are integers,"},{"text":" ","type":"text"},{"text":"and it adds an ","type":"text"},{"code":"endsWith(_:)","type":"codeVoice"},{"text":" method when the items are equatable.","type":"text"},{"type":"text","text":" "},{"text":"Both functions include a generic ","type":"text"},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause"},{"type":"text","text":" "},{"text":"that adds type constraints to the generic ","type":"text"},{"code":"Item","type":"codeVoice"},{"type":"text","text":" type parameter"},{"type":"text","text":" "},{"text":"from the original declaration of ","type":"text"},{"code":"Container","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"If you want to write this code without using contextual ","type":"text"},{"type":"codeVoice","code":"where"},{"type":"text","text":" clauses,"},{"type":"text","text":" "},{"type":"text","text":"you write two extensions,"},{"type":"text","text":" "},{"text":"one for each generic ","type":"text"},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause."},{"type":"text","text":" "},{"text":"The example above and the example below have the same behavior.","type":"text"}]},{"code":["extension Container where Item == Int {","    func average() -> Double {","        var sum = 0.0","        for index in 0..<count {","            sum += Double(self[index])","        }","        return sum \/ Double(count)","    }","}","extension Container where Item: Equatable {","    func endsWith(_ item: Item) -> Bool {","        return count >= 1 && self[count-1] == item","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"In the version of this example that uses contextual ","type":"text"},{"type":"codeVoice","code":"where"},{"type":"text","text":" clauses,"},{"text":" ","type":"text"},{"type":"text","text":"the implementation of "},{"type":"codeVoice","code":"average()"},{"type":"text","text":" and "},{"type":"codeVoice","code":"endsWith(_:)"},{"type":"text","text":" "},{"text":"are both in the same extension","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"because each method’s generic "},{"type":"codeVoice","code":"where"},{"text":" clause","type":"text"},{"type":"text","text":" "},{"text":"states the requirements that need to be satisfied","type":"text"},{"text":" ","type":"text"},{"text":"to make that method available.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Moving those requirements to the extensions’ generic "},{"code":"where","type":"codeVoice"},{"text":" clauses","type":"text"},{"type":"text","text":" "},{"type":"text","text":"makes the methods available in the same situations,"},{"type":"text","text":" "},{"text":"but requires one extension per requirement.","type":"text"}]},{"type":"heading","level":2,"text":"Associated Types with a Generic Where Clause","anchor":"Associated-Types-with-a-Generic-Where-Clause"},{"type":"paragraph","inlineContent":[{"text":"You can include a generic ","type":"text"},{"code":"where","type":"codeVoice"},{"type":"text","text":" clause on an associated type."},{"type":"text","text":" "},{"type":"text","text":"For example, suppose you want to make a version of "},{"code":"Container","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"that includes an iterator,"},{"text":" ","type":"text"},{"type":"text","text":"like what the "},{"code":"Sequence","type":"codeVoice"},{"type":"text","text":" protocol uses in the Swift standard library."},{"type":"text","text":" "},{"text":"Here’s how you write that:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["protocol Container {","    associatedtype Item","    mutating func append(_ item: Item)","    var count: Int { get }","    subscript(i: Int) -> Item { get }","","    associatedtype Iterator: IteratorProtocol where Iterator.Element == Item","    func makeIterator() -> Iterator","}"]},{"type":"paragraph","inlineContent":[{"text":"The generic ","type":"text"},{"code":"where","type":"codeVoice"},{"type":"text","text":" clause on "},{"code":"Iterator","type":"codeVoice"},{"type":"text","text":" requires that"},{"text":" ","type":"text"},{"text":"the iterator must traverse over elements","type":"text"},{"type":"text","text":" "},{"type":"text","text":"of the same item type as the container’s items,"},{"type":"text","text":" "},{"type":"text","text":"regardless of the iterator’s type."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"makeIterator()"},{"text":" function provides access to a container’s iterator.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For a protocol that inherits from another protocol,"},{"text":" ","type":"text"},{"text":"you add a constraint to an inherited associated type","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"by including the generic "},{"code":"where","type":"codeVoice"},{"text":" clause in the protocol declaration.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For example, the following code"},{"type":"text","text":" "},{"type":"text","text":"declares a "},{"type":"codeVoice","code":"ComparableContainer"},{"type":"text","text":" protocol"},{"type":"text","text":" "},{"text":"that requires ","type":"text"},{"type":"codeVoice","code":"Item"},{"text":" to conform to ","type":"text"},{"code":"Comparable","type":"codeVoice"},{"text":":","type":"text"}]},{"syntax":"swift","code":["protocol ComparableContainer: Container where Item: Comparable { }"],"type":"codeListing"},{"level":2,"text":"Generic Subscripts","type":"heading","anchor":"Generic-Subscripts"},{"type":"paragraph","inlineContent":[{"text":"Subscripts can be generic,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and they can include generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clauses."},{"text":" ","type":"text"},{"type":"text","text":"You write the placeholder type name inside angle brackets after "},{"code":"subscript","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and you write a generic "},{"code":"where","type":"codeVoice"},{"type":"text","text":" clause right before the opening curly brace"},{"text":" ","type":"text"},{"type":"text","text":"of the subscript’s body."},{"type":"text","text":" "},{"text":"For example:","type":"text"}]},{"syntax":"swift","code":["extension Container {","    subscript<Indices: Sequence>(indices: Indices) -> [Item]","            where Indices.Iterator.Element == Int {","        var result: [Item] = []","        for index in indices {","            result.append(self[index])","        }","        return result","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"This extension to the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol"},{"type":"text","text":" "},{"text":"adds a subscript that takes a sequence of indices","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and returns an array containing the items at each given index."},{"text":" ","type":"text"},{"text":"This generic subscript is constrained as follows:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The generic parameter "},{"type":"codeVoice","code":"Indices"},{"type":"text","text":" in angle brackets"},{"text":" ","type":"text"},{"type":"text","text":"has to be a type that conforms to the "},{"code":"Sequence","type":"codeVoice"},{"text":" protocol","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"from the Swift standard library."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The subscript takes a single parameter, "},{"type":"codeVoice","code":"indices"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which is an instance of that "},{"type":"codeVoice","code":"Indices"},{"type":"text","text":" type."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"The generic "},{"type":"codeVoice","code":"where"},{"text":" clause requires","type":"text"},{"text":" ","type":"text"},{"text":"that the iterator for the sequence","type":"text"},{"type":"text","text":" "},{"text":"must traverse over elements of type ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"This ensures that the indices in the sequence"},{"text":" ","type":"text"},{"text":"are the same type as the indices used for a container.","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"text":"Taken together, these constraints mean that","type":"text"},{"type":"text","text":" "},{"text":"the value passed for the ","type":"text"},{"type":"codeVoice","code":"indices"},{"text":" parameter","type":"text"},{"type":"text","text":" "},{"text":"is a sequence of integers.","type":"text"}]}],"kind":"content"}],"references":{"stackPoppedOneString":{"alt":null,"identifier":"stackPoppedOneString","variants":[{"url":"\/images\/stackPoppedOneString@2x.png","traits":["2x","light"]},{"traits":["2x","dark"],"url":"\/images\/stackPoppedOneString~dark@2x.png"}],"type":"image"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Generics#Type-Constraints":{"type":"topic","title":"Type Constraints","abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics#Type-Constraints","url":"\/documentation\/the-swift-programming-language\/generics#Type-Constraints","kind":"section"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions#In-Out-Parameters":{"title":"In-Out Parameters","url":"\/documentation\/the-swift-programming-language\/functions#In-Out-Parameters","kind":"section","abstract":[],"type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#In-Out-Parameters"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Generics#Generic-Types":{"kind":"section","abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics#Generic-Types","type":"topic","url":"\/documentation\/the-swift-programming-language\/generics#Generic-Types","title":"Generic Types"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/CollectionTypes#Dictionaries":{"kind":"section","abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes#Dictionaries","url":"\/documentation\/the-swift-programming-language\/collectiontypes#Dictionaries","type":"topic","title":"Dictionaries"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Protocols#Adding-Protocol-Conformance-with-an-Extension":{"abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Adding-Protocol-Conformance-with-an-Extension","title":"Adding Protocol Conformance with an Extension","kind":"section","type":"topic","url":"\/documentation\/the-swift-programming-language\/protocols#Adding-Protocol-Conformance-with-an-Extension"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Generics#Extensions-with-a-Generic-Where-Clause":{"abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics#Extensions-with-a-Generic-Where-Clause","title":"Extensions with a Generic Where Clause","kind":"section","type":"topic","url":"\/documentation\/the-swift-programming-language\/generics#Extensions-with-a-Generic-Where-Clause"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Protocols#Declaring-Protocol-Adoption-with-an-Extension":{"type":"topic","title":"Declaring Protocol Adoption with an Extension","abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Declaring-Protocol-Adoption-with-an-Extension","url":"\/documentation\/the-swift-programming-language\/protocols#Declaring-Protocol-Adoption-with-an-Extension","kind":"section"},"stackPushedFourStrings":{"alt":null,"identifier":"stackPushedFourStrings","variants":[{"url":"\/images\/stackPushedFourStrings@2x.png","traits":["2x","light"]},{"traits":["2x","dark"],"url":"\/images\/stackPushedFourStrings~dark@2x.png"}],"type":"image"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language","title":"The Swift Programming Language (5.9.2)","url":"\/documentation\/the-swift-programming-language","role":"collection","kind":"article","abstract":[]},"stackPushPop":{"type":"image","variants":[{"url":"\/images\/stackPushPop@2x.png","traits":["2x","light"]},{"traits":["2x","dark"],"url":"\/images\/stackPushPop~dark@2x.png"}],"identifier":"stackPushPop","alt":null},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Generics#Associated-Types-with-a-Generic-Where-Clause":{"kind":"section","abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics#Associated-Types-with-a-Generic-Where-Clause","type":"topic","url":"\/documentation\/the-swift-programming-language\/generics#Associated-Types-with-a-Generic-Where-Clause","title":"Associated Types with a Generic Where Clause"},"https://developer.apple.com/documentation/swift/hashable#2849490":{"type":"link","title":"Conforming to the Hashable Protocol","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/hashable#2849490","titleInlineContent":[{"type":"text","text":"Conforming to the Hashable Protocol"}],"url":"https:\/\/developer.apple.com\/documentation\/swift\/hashable#2849490"}}}