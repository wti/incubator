{"sections":[],"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"abstract":[{"text":"Define requirements that conforming types must implement.","type":"text"}],"metadata":{"title":"Protocols"},"schemaVersion":{"minor":3,"major":0,"patch":0},"primaryContentSections":[{"content":[{"inlineContent":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"protocol","type":"text"}]},{"text":" defines a blueprint of","type":"text"},{"type":"text","text":" "},{"type":"text","text":"methods, properties, and other requirements"},{"type":"text","text":" "},{"type":"text","text":"that suit a particular task or piece of functionality."},{"type":"text","text":" "},{"text":"The protocol can then be ","type":"text"},{"inlineContent":[{"text":"adopted","type":"text"}],"type":"emphasis"},{"type":"text","text":" by a class, structure, or enumeration"},{"type":"text","text":" "},{"text":"to provide an actual implementation of those requirements.","type":"text"},{"text":" ","type":"text"},{"text":"Any type that satisfies the requirements of a protocol is said to","type":"text"},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"conform"}],"type":"emphasis"},{"text":" to that protocol.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In addition to specifying requirements that conforming types must implement,"},{"type":"text","text":" "},{"text":"you can extend a protocol to implement some of these requirements","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"or to implement additional functionality that conforming types can take advantage of."}]},{"type":"heading","level":2,"text":"Protocol Syntax","anchor":"Protocol-Syntax"},{"inlineContent":[{"text":"You define protocols in a very similar way to classes, structures, and enumerations:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["protocol SomeProtocol {","    \/\/ protocol definition goes here","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Custom types state that they adopt a particular protocol"},{"text":" ","type":"text"},{"text":"by placing the protocol’s name after the type’s name,","type":"text"},{"text":" ","type":"text"},{"text":"separated by a colon, as part of their definition.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Multiple protocols can be listed, and are separated by commas:"}]},{"syntax":"swift","code":["struct SomeStructure: FirstProtocol, AnotherProtocol {","    \/\/ structure definition goes here","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"If a class has a superclass, list the superclass name","type":"text"},{"type":"text","text":" "},{"text":"before any protocols it adopts, followed by a comma:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["class SomeClass: SomeSuperclass, FirstProtocol, AnotherProtocol {","    \/\/ class definition goes here","}"]},{"content":[{"inlineContent":[{"type":"text","text":"Because protocols are types,"},{"text":" ","type":"text"},{"text":"begin their names with a capital letter","type":"text"},{"type":"text","text":" "},{"type":"text","text":"(such as "},{"code":"FullyNamed","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"RandomNumberGenerator"},{"type":"text","text":")"},{"text":" ","type":"text"},{"text":"to match the names of other types in Swift","type":"text"},{"type":"text","text":" "},{"type":"text","text":"(such as "},{"code":"Int","type":"codeVoice"},{"type":"text","text":", "},{"code":"String","type":"codeVoice"},{"type":"text","text":", and "},{"code":"Double","type":"codeVoice"},{"type":"text","text":")."}],"type":"paragraph"}],"style":"note","type":"aside","name":"Note"},{"level":2,"text":"Property Requirements","type":"heading","anchor":"Property-Requirements"},{"type":"paragraph","inlineContent":[{"text":"A protocol can require any conforming type to provide","type":"text"},{"type":"text","text":" "},{"text":"an instance property or type property with a particular name and type.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The protocol doesn’t specify whether the property should be"},{"type":"text","text":" "},{"text":"a stored property or a computed property —","type":"text"},{"text":" ","type":"text"},{"text":"it only specifies the required property name and type.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The protocol also specifies whether each property must be gettable"},{"text":" ","type":"text"},{"text":"or gettable ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"and","type":"text"}]},{"type":"text","text":" settable."}]},{"type":"paragraph","inlineContent":[{"text":"If a protocol requires a property to be gettable and settable,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that property requirement can’t be fulfilled by"},{"type":"text","text":" "},{"type":"text","text":"a constant stored property or a read-only computed property."},{"type":"text","text":" "},{"text":"If the protocol only requires a property to be gettable,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the requirement can be satisfied by any kind of property,"},{"type":"text","text":" "},{"type":"text","text":"and it’s valid for the property to be also settable"},{"text":" ","type":"text"},{"type":"text","text":"if this is useful for your own code."}]},{"inlineContent":[{"type":"text","text":"Property requirements are always declared as variable properties,"},{"type":"text","text":" "},{"text":"prefixed with the ","type":"text"},{"type":"codeVoice","code":"var"},{"type":"text","text":" keyword."},{"type":"text","text":" "},{"type":"text","text":"Gettable and settable properties are indicated by writing"},{"type":"text","text":" "},{"code":"{ get set }","type":"codeVoice"},{"text":" after their type declaration,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and gettable properties are indicated by writing "},{"type":"codeVoice","code":"{ get }"},{"type":"text","text":"."}],"type":"paragraph"},{"code":["protocol SomeProtocol {","    var mustBeSettable: Int { get set }","    var doesNotNeedToBeSettable: Int { get }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Always prefix type property requirements with the ","type":"text"},{"type":"codeVoice","code":"static"},{"text":" keyword","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"when you define them in a protocol."},{"text":" ","type":"text"},{"type":"text","text":"This rule pertains even though type property requirements can be prefixed with"},{"type":"text","text":" "},{"text":"the ","type":"text"},{"code":"class","type":"codeVoice"},{"type":"text","text":" or "},{"code":"static","type":"codeVoice"},{"text":" keyword when implemented by a class:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["protocol AnotherProtocol {","    static var someTypeProperty: Int { get set }","}"]},{"type":"paragraph","inlineContent":[{"text":"Here’s an example of a protocol with a single instance property requirement:","type":"text"}]},{"syntax":"swift","code":["protocol FullyNamed {","    var fullName: String { get }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"FullyNamed"},{"text":" protocol requires a conforming type to provide a fully qualified name.","type":"text"},{"type":"text","text":" "},{"text":"The protocol doesn’t specify anything else about the nature of the conforming type —","type":"text"},{"type":"text","text":" "},{"type":"text","text":"it only specifies that the type must be able to provide a full name for itself."},{"type":"text","text":" "},{"text":"The protocol states that any ","type":"text"},{"code":"FullyNamed","type":"codeVoice"},{"text":" type must have","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"a gettable instance property called "},{"code":"fullName","type":"codeVoice"},{"text":", which is of type ","type":"text"},{"type":"codeVoice","code":"String"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s an example of a simple structure that adopts and conforms to"},{"text":" ","type":"text"},{"type":"text","text":"the "},{"type":"codeVoice","code":"FullyNamed"},{"type":"text","text":" protocol:"}]},{"type":"codeListing","syntax":"swift","code":["struct Person: FullyNamed {","    var fullName: String","}","let john = Person(fullName: \"John Appleseed\")","\/\/ john.fullName is \"John Appleseed\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example defines a structure called "},{"code":"Person","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"which represents a specific named person.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"It states that it adopts the "},{"type":"codeVoice","code":"FullyNamed"},{"text":" protocol","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"as part of the first line of its definition."}]},{"inlineContent":[{"text":"Each instance of ","type":"text"},{"code":"Person","type":"codeVoice"},{"type":"text","text":" has a single stored property called "},{"type":"codeVoice","code":"fullName"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"which is of type ","type":"text"},{"code":"String","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"This matches the single requirement of the ","type":"text"},{"type":"codeVoice","code":"FullyNamed"},{"text":" protocol,","type":"text"},{"type":"text","text":" "},{"text":"and means that ","type":"text"},{"type":"codeVoice","code":"Person"},{"text":" has correctly conformed to the protocol.","type":"text"},{"type":"text","text":" "},{"text":"(Swift reports an error at compile time if a protocol requirement isn’t fulfilled.)","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Here’s a more complex class, which also adopts and conforms to the ","type":"text"},{"code":"FullyNamed","type":"codeVoice"},{"type":"text","text":" protocol:"}]},{"syntax":"swift","type":"codeListing","code":["class Starship: FullyNamed {","    var prefix: String?","    var name: String","    init(name: String, prefix: String? = nil) {","        self.name = name","        self.prefix = prefix","    }","    var fullName: String {","        return (prefix != nil ? prefix! + \" \" : \"\") + name","    }","}","var ncc1701 = Starship(name: \"Enterprise\", prefix: \"USS\")","\/\/ ncc1701.fullName is \"USS Enterprise\""]},{"inlineContent":[{"type":"text","text":"This class implements the "},{"type":"codeVoice","code":"fullName"},{"type":"text","text":" property requirement as"},{"text":" ","type":"text"},{"type":"text","text":"a computed read-only property for a starship."},{"text":" ","type":"text"},{"type":"text","text":"Each "},{"type":"codeVoice","code":"Starship"},{"type":"text","text":" class instance stores a mandatory "},{"code":"name","type":"codeVoice"},{"type":"text","text":" and an optional "},{"type":"codeVoice","code":"prefix"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The "},{"code":"fullName","type":"codeVoice"},{"text":" property uses the ","type":"text"},{"type":"codeVoice","code":"prefix"},{"type":"text","text":" value if it exists,"},{"text":" ","type":"text"},{"type":"text","text":"and prepends it to the beginning of "},{"type":"codeVoice","code":"name"},{"text":" to create a full name for the starship.","type":"text"}],"type":"paragraph"},{"text":"Method Requirements","type":"heading","anchor":"Method-Requirements","level":2},{"inlineContent":[{"type":"text","text":"Protocols can require specific instance methods and type methods"},{"text":" ","type":"text"},{"type":"text","text":"to be implemented by conforming types."},{"type":"text","text":" "},{"type":"text","text":"These methods are written as part of the protocol’s definition"},{"text":" ","type":"text"},{"type":"text","text":"in exactly the same way as for normal instance and type methods,"},{"text":" ","type":"text"},{"type":"text","text":"but without curly braces or a method body."},{"type":"text","text":" "},{"type":"text","text":"Variadic parameters are allowed, subject to the same rules as for normal methods."},{"text":" ","type":"text"},{"text":"Default values, however, can’t be specified for method parameters within a protocol’s definition.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"As with type property requirements,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"you always prefix type method requirements with the "},{"code":"static","type":"codeVoice"},{"type":"text","text":" keyword"},{"text":" ","type":"text"},{"text":"when they’re defined in a protocol.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"This is true even though type method requirements are prefixed with"},{"text":" ","type":"text"},{"type":"text","text":"the "},{"type":"codeVoice","code":"class"},{"text":" or ","type":"text"},{"code":"static","type":"codeVoice"},{"type":"text","text":" keyword when implemented by a class:"}],"type":"paragraph"},{"syntax":"swift","code":["protocol SomeProtocol {","    static func someTypeMethod()","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"The following example defines a protocol with a single instance method requirement:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["protocol RandomNumberGenerator {","    func random() -> Double","}"]},{"type":"paragraph","inlineContent":[{"text":"This protocol, ","type":"text"},{"type":"codeVoice","code":"RandomNumberGenerator"},{"type":"text","text":", requires any conforming type"},{"text":" ","type":"text"},{"type":"text","text":"to have an instance method called "},{"type":"codeVoice","code":"random"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"which returns a ","type":"text"},{"code":"Double","type":"codeVoice"},{"type":"text","text":" value whenever it’s called."},{"type":"text","text":" "},{"text":"Although it’s not specified as part of the protocol,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"it’s assumed that this value will be"},{"text":" ","type":"text"},{"text":"a number from ","type":"text"},{"type":"codeVoice","code":"0.0"},{"type":"text","text":" up to (but not including) "},{"code":"1.0","type":"codeVoice"},{"text":".","type":"text"}]},{"inlineContent":[{"type":"text","text":"The "},{"code":"RandomNumberGenerator","type":"codeVoice"},{"type":"text","text":" protocol doesn’t make any assumptions"},{"text":" ","type":"text"},{"text":"about how each random number will be generated —","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"it simply requires the generator to provide a standard way"},{"type":"text","text":" "},{"text":"to generate a new random number.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Here’s an implementation of a class that adopts and conforms to","type":"text"},{"type":"text","text":" "},{"text":"the ","type":"text"},{"type":"codeVoice","code":"RandomNumberGenerator"},{"type":"text","text":" protocol."},{"type":"text","text":" "},{"type":"text","text":"This class implements a pseudorandom number generator algorithm known as"},{"type":"text","text":" "},{"text":"a ","type":"text"},{"inlineContent":[{"type":"text","text":"linear congruential generator"}],"type":"emphasis"},{"type":"text","text":":"}],"type":"paragraph"},{"syntax":"swift","code":["class LinearCongruentialGenerator: RandomNumberGenerator {","    var lastRandom = 42.0","    let m = 139968.0","    let a = 3877.0","    let c = 29573.0","    func random() -> Double {","        lastRandom = ((lastRandom * a + c)","            .truncatingRemainder(dividingBy:m))","        return lastRandom \/ m","    }","}","let generator = LinearCongruentialGenerator()","print(\"Here's a random number: \\(generator.random())\")","\/\/ Prints \"Here's a random number: 0.3746499199817101\"","print(\"And another one: \\(generator.random())\")","\/\/ Prints \"And another one: 0.729023776863283\""],"type":"codeListing"},{"text":"Mutating Method Requirements","level":2,"type":"heading","anchor":"Mutating-Method-Requirements"},{"type":"paragraph","inlineContent":[{"text":"It’s sometimes necessary for a method to modify (or ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"mutate"}]},{"text":") the instance it belongs to.","type":"text"},{"type":"text","text":" "},{"text":"For instance methods on value types (that is, structures and enumerations)","type":"text"},{"type":"text","text":" "},{"text":"you place the ","type":"text"},{"code":"mutating","type":"codeVoice"},{"type":"text","text":" keyword before a method’s "},{"type":"codeVoice","code":"func"},{"type":"text","text":" keyword"},{"type":"text","text":" "},{"text":"to indicate that the method is allowed to modify the instance it belongs to","type":"text"},{"type":"text","text":" "},{"text":"and any properties of that instance.","type":"text"},{"type":"text","text":" "},{"text":"This process is described in ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Methods#Modifying-Value-Types-from-Within-Instance-Methods"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you define a protocol instance method requirement"},{"type":"text","text":" "},{"text":"that’s intended to mutate instances of any type that adopts the protocol,","type":"text"},{"text":" ","type":"text"},{"text":"mark the method with the ","type":"text"},{"code":"mutating","type":"codeVoice"},{"type":"text","text":" keyword"},{"text":" ","type":"text"},{"text":"as part of the protocol’s definition.","type":"text"},{"type":"text","text":" "},{"text":"This enables structures and enumerations to adopt the protocol","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and satisfy that method requirement."}]},{"style":"note","type":"aside","name":"Note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If you mark a protocol instance method requirement as "},{"code":"mutating","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"you don’t need to write the ","type":"text"},{"code":"mutating","type":"codeVoice"},{"text":" keyword when writing","type":"text"},{"type":"text","text":" "},{"type":"text","text":"an implementation of that method for a class."},{"text":" ","type":"text"},{"type":"text","text":"The "},{"type":"codeVoice","code":"mutating"},{"text":" keyword is only used by structures and enumerations.","type":"text"}]}]},{"inlineContent":[{"type":"text","text":"The example below defines a protocol called "},{"code":"Togglable","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"which defines a single instance method requirement called "},{"type":"codeVoice","code":"toggle"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"As its name suggests, the "},{"code":"toggle()","type":"codeVoice"},{"type":"text","text":" method is intended to"},{"type":"text","text":" "},{"type":"text","text":"toggle or invert the state of any conforming type,"},{"text":" ","type":"text"},{"type":"text","text":"typically by modifying a property of that type."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"toggle()"},{"type":"text","text":" method is marked with the "},{"code":"mutating","type":"codeVoice"},{"type":"text","text":" keyword"},{"type":"text","text":" "},{"text":"as part of the ","type":"text"},{"type":"codeVoice","code":"Togglable"},{"text":" protocol definition,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to indicate that the method is expected to mutate the state of a conforming instance"},{"text":" ","type":"text"},{"text":"when it’s called:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["protocol Togglable {","    mutating func toggle()","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you implement the "},{"type":"codeVoice","code":"Togglable"},{"type":"text","text":" protocol for a structure or enumeration,"},{"text":" ","type":"text"},{"text":"that structure or enumeration can conform to the protocol","type":"text"},{"type":"text","text":" "},{"text":"by providing an implementation of the ","type":"text"},{"code":"toggle()","type":"codeVoice"},{"type":"text","text":" method"},{"type":"text","text":" "},{"type":"text","text":"that’s also marked as "},{"code":"mutating","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"text":"The example below defines an enumeration called ","type":"text"},{"type":"codeVoice","code":"OnOffSwitch"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"This enumeration toggles between two states,"},{"text":" ","type":"text"},{"text":"indicated by the enumeration cases ","type":"text"},{"type":"codeVoice","code":"on"},{"type":"text","text":" and "},{"type":"codeVoice","code":"off"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"The enumeration’s "},{"code":"toggle","type":"codeVoice"},{"type":"text","text":" implementation is marked as "},{"code":"mutating","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"to match the ","type":"text"},{"code":"Togglable","type":"codeVoice"},{"text":" protocol’s requirements:","type":"text"}]},{"type":"codeListing","code":["enum OnOffSwitch: Togglable {","    case off, on","    mutating func toggle() {","        switch self {","        case .off:","            self = .on","        case .on:","            self = .off","        }","    }","}","var lightSwitch = OnOffSwitch.off","lightSwitch.toggle()","\/\/ lightSwitch is now equal to .on"],"syntax":"swift"},{"type":"heading","anchor":"Initializer-Requirements","level":2,"text":"Initializer Requirements"},{"inlineContent":[{"text":"Protocols can require specific initializers","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to be implemented by conforming types."},{"type":"text","text":" "},{"text":"You write these initializers as part of the protocol’s definition","type":"text"},{"type":"text","text":" "},{"text":"in exactly the same way as for normal initializers,","type":"text"},{"type":"text","text":" "},{"text":"but without curly braces or an initializer body:","type":"text"}],"type":"paragraph"},{"code":["protocol SomeProtocol {","    init(someParameter: Int)","}"],"syntax":"swift","type":"codeListing"},{"text":"Class Implementations of Protocol Initializer Requirements","anchor":"Class-Implementations-of-Protocol-Initializer-Requirements","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"text":"You can implement a protocol initializer requirement on a conforming class","type":"text"},{"type":"text","text":" "},{"text":"as either a designated initializer or a convenience initializer.","type":"text"},{"text":" ","type":"text"},{"text":"In both cases,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"you must mark the initializer implementation with the "},{"code":"required","type":"codeVoice"},{"type":"text","text":" modifier:"}]},{"syntax":"swift","type":"codeListing","code":["class SomeClass: SomeProtocol {","    required init(someParameter: Int) {","        \/\/ initializer implementation goes here","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"The use of the ","type":"text"},{"type":"codeVoice","code":"required"},{"type":"text","text":" modifier ensures that"},{"type":"text","text":" "},{"type":"text","text":"you provide an explicit or inherited implementation of the initializer requirement"},{"text":" ","type":"text"},{"type":"text","text":"on all subclasses of the conforming class,"},{"type":"text","text":" "},{"type":"text","text":"such that they also conform to the protocol."}]},{"inlineContent":[{"type":"text","text":"For more information on required initializers,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization#Required-Initializers"},{"type":"text","text":"."}],"type":"paragraph"},{"content":[{"inlineContent":[{"text":"You don’t need to mark protocol initializer implementations with the ","type":"text"},{"type":"codeVoice","code":"required"},{"text":" modifier","type":"text"},{"type":"text","text":" "},{"text":"on classes that are marked with the ","type":"text"},{"code":"final","type":"codeVoice"},{"type":"text","text":" modifier,"},{"type":"text","text":" "},{"text":"because final classes can’t subclassed.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For more about the "},{"code":"final","type":"codeVoice"},{"text":" modifier, see ","type":"text"},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Inheritance#Preventing-Overrides","isActive":true},{"type":"text","text":"."}],"type":"paragraph"}],"style":"note","name":"Note","type":"aside"},{"inlineContent":[{"text":"If a subclass overrides a designated initializer from a superclass,","type":"text"},{"text":" ","type":"text"},{"text":"and also implements a matching initializer requirement from a protocol,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"mark the initializer implementation with both the "},{"type":"codeVoice","code":"required"},{"type":"text","text":" and "},{"type":"codeVoice","code":"override"},{"type":"text","text":" modifiers:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["protocol SomeProtocol {","    init()","}","","class SomeSuperClass {","    init() {","        \/\/ initializer implementation goes here","    }","}","","class SomeSubClass: SomeSuperClass, SomeProtocol {","    \/\/ \"required\" from SomeProtocol conformance; \"override\" from SomeSuperClass","    required override init() {","        \/\/ initializer implementation goes here","    }","}"]},{"anchor":"Failable-Initializer-Requirements","text":"Failable Initializer Requirements","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"Protocols can define failable initializer requirements for conforming types,"},{"type":"text","text":" "},{"text":"as defined in ","type":"text"},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization#Failable-Initializers","isActive":true,"type":"reference"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"A failable initializer requirement can be satisfied by"},{"type":"text","text":" "},{"type":"text","text":"a failable or nonfailable initializer on a conforming type."},{"type":"text","text":" "},{"type":"text","text":"A nonfailable initializer requirement can be satisfied by"},{"text":" ","type":"text"},{"text":"a nonfailable initializer or an implicitly unwrapped failable initializer.","type":"text"}],"type":"paragraph"},{"text":"Protocols as Types","level":2,"type":"heading","anchor":"Protocols-as-Types"},{"inlineContent":[{"type":"text","text":"Protocols don’t actually implement any functionality themselves."},{"type":"text","text":" "},{"text":"Regardless, you can use a protocol as a type in your code.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The most common way to use a protocol as a type"},{"type":"text","text":" "},{"type":"text","text":"is to use a protocol as a generic constraint."},{"type":"text","text":" "},{"type":"text","text":"Code with generic constraints can work with"},{"text":" ","type":"text"},{"text":"any type that conforms to the protocol,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and the specific type is chosen by the code that uses the API."},{"text":" ","type":"text"},{"text":"For example,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"when you call a function that takes an argument"},{"type":"text","text":" "},{"text":"and that argument’s type is generic,","type":"text"},{"type":"text","text":" "},{"text":"the caller chooses the type.","type":"text"}]},{"inlineContent":[{"text":"Code with an opaque type","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"works with some type that conforms to the protocol."},{"text":" ","type":"text"},{"type":"text","text":"The underlying type is known at compile time,"},{"type":"text","text":" "},{"text":"and the API implementation chooses that type,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"but that type’s identity is hidden from clients of the API."},{"type":"text","text":" "},{"text":"Using an opaque type lets you prevent implementation details of an API","type":"text"},{"type":"text","text":" "},{"text":"from leaking through the layer of abstraction —","type":"text"},{"type":"text","text":" "},{"type":"text","text":"for example, by hiding the specific return type from a function,"},{"text":" ","type":"text"},{"type":"text","text":"and only guaranteeing that the value conforms to a given protocol."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Code with a boxed protocol type"},{"text":" ","type":"text"},{"type":"text","text":"works with any type, chosen at runtime, that conforms to the protocol."},{"text":" ","type":"text"},{"text":"To support this runtime flexibility,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Swift adds a level of indirection when necessary —"},{"type":"text","text":" "},{"type":"text","text":"known as a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"box"}]},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"which has a performance cost.","type":"text"},{"text":" ","type":"text"},{"text":"Because of this flexibility,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Swift doesn’t know the underlying type at compile time,"},{"type":"text","text":" "},{"text":"which means you can access only the members","type":"text"},{"text":" ","type":"text"},{"text":"that are required by the protocol.","type":"text"},{"text":" ","type":"text"},{"text":"Accessing any other APIs on the underlying type","type":"text"},{"type":"text","text":" "},{"text":"requires casting at runtime.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For information about using protocols as generic constraints,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","type":"reference","isActive":true},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For information about opaque types, and boxed protocol types,"},{"text":" ","type":"text"},{"text":"see ","type":"text"},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes","isActive":true},{"type":"text","text":"."}]},{"anchor":"Delegation","type":"heading","text":"Delegation","level":2},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"Delegation","type":"text"}]},{"type":"text","text":" is a design pattern that enables"},{"text":" ","type":"text"},{"type":"text","text":"a class or structure to hand off (or "},{"inlineContent":[{"type":"text","text":"delegate"}],"type":"emphasis"},{"type":"text","text":")"},{"text":" ","type":"text"},{"type":"text","text":"some of its responsibilities to an instance of another type."},{"type":"text","text":" "},{"text":"This design pattern is implemented by defining","type":"text"},{"type":"text","text":" "},{"type":"text","text":"a protocol that encapsulates the delegated responsibilities,"},{"type":"text","text":" "},{"type":"text","text":"such that a conforming type (known as a delegate)"},{"text":" ","type":"text"},{"text":"is guaranteed to provide the functionality that has been delegated.","type":"text"},{"text":" ","type":"text"},{"text":"Delegation can be used to respond to a particular action,","type":"text"},{"type":"text","text":" "},{"text":"or to retrieve data from an external source without needing to know","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the underlying type of that source."}]},{"inlineContent":[{"type":"text","text":"The example below defines two protocols for use with dice-based board games:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["protocol DiceGame {","    var dice: Dice { get }","    func play()","}","protocol DiceGameDelegate: AnyObject {","    func gameDidStart(_ game: DiceGame)","    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)","    func gameDidEnd(_ game: DiceGame)","}"]},{"inlineContent":[{"type":"text","text":"The "},{"code":"DiceGame","type":"codeVoice"},{"type":"text","text":" protocol is a protocol that can be adopted"},{"text":" ","type":"text"},{"type":"text","text":"by any game that involves dice."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"DiceGameDelegate","type":"codeVoice"},{"type":"text","text":" protocol can be adopted"},{"text":" ","type":"text"},{"text":"to track the progress of a ","type":"text"},{"code":"DiceGame","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"To prevent strong reference cycles,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"delegates are declared as weak references."},{"text":" ","type":"text"},{"type":"text","text":"For information about weak references,"},{"type":"text","text":" "},{"text":"see ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting#Strong-Reference-Cycles-Between-Class-Instances"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Marking the protocol as class-only"},{"type":"text","text":" "},{"text":"lets the ","type":"text"},{"code":"SnakesAndLadders","type":"codeVoice"},{"text":" class later in this chapter","type":"text"},{"type":"text","text":" "},{"text":"declare that its delegate must use a weak reference.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"A class-only protocol"},{"type":"text","text":" "},{"type":"text","text":"is marked by its inheritance from "},{"code":"AnyObject","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"as discussed in ","type":"text"},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Class-Only-Protocols","isActive":true,"type":"reference"},{"type":"text","text":"."}]},{"inlineContent":[{"type":"text","text":"Here’s a version of the "},{"inlineContent":[{"text":"Snakes and Ladders","type":"text"}],"type":"emphasis"},{"type":"text","text":" game originally introduced in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow"},{"text":".","type":"text"},{"type":"text","text":" "},{"text":"This version is adapted to use a ","type":"text"},{"type":"codeVoice","code":"Dice"},{"text":" instance for its dice-rolls;","type":"text"},{"type":"text","text":" "},{"text":"to adopt the ","type":"text"},{"code":"DiceGame","type":"codeVoice"},{"text":" protocol;","type":"text"},{"text":" ","type":"text"},{"text":"and to notify a ","type":"text"},{"type":"codeVoice","code":"DiceGameDelegate"},{"text":" about its progress:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["class SnakesAndLadders: DiceGame {","    let finalSquare = 25","    let dice = Dice(sides: 6, generator: LinearCongruentialGenerator())","    var square = 0","    var board: [Int]","    init() {","        board = Array(repeating: 0, count: finalSquare + 1)","        board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02","        board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08","    }","    weak var delegate: DiceGameDelegate?","    func play() {","        square = 0","        delegate?.gameDidStart(self)","        gameLoop: while square != finalSquare {","            let diceRoll = dice.roll()","            delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)","            switch square + diceRoll {","            case finalSquare:","                break gameLoop","            case let newSquare where newSquare > finalSquare:","                continue gameLoop","            default:","                square += diceRoll","                square += board[square]","            }","        }","        delegate?.gameDidEnd(self)","    }","}"]},{"inlineContent":[{"type":"text","text":"For a description of the "},{"type":"emphasis","inlineContent":[{"text":"Snakes and Ladders","type":"text"}]},{"type":"text","text":" gameplay,"},{"type":"text","text":" "},{"text":"see ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow#Break"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This version of the game is wrapped up as a class called "},{"type":"codeVoice","code":"SnakesAndLadders"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"which adopts the "},{"type":"codeVoice","code":"DiceGame"},{"text":" protocol.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"It provides a gettable "},{"code":"dice","type":"codeVoice"},{"text":" property and a ","type":"text"},{"code":"play()","type":"codeVoice"},{"type":"text","text":" method"},{"text":" ","type":"text"},{"text":"in order to conform to the protocol.","type":"text"},{"text":" ","type":"text"},{"text":"(The ","type":"text"},{"code":"dice","type":"codeVoice"},{"type":"text","text":" property is declared as a constant property"},{"text":" ","type":"text"},{"type":"text","text":"because it doesn’t need to change after initialization,"},{"type":"text","text":" "},{"type":"text","text":"and the protocol only requires that it must be gettable.)"}]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"Snakes and Ladders"}]},{"text":" game board setup takes place within","type":"text"},{"type":"text","text":" "},{"text":"the class’s ","type":"text"},{"code":"init()","type":"codeVoice"},{"type":"text","text":" initializer."},{"type":"text","text":" "},{"text":"All game logic is moved into the protocol’s ","type":"text"},{"code":"play","type":"codeVoice"},{"type":"text","text":" method,"},{"type":"text","text":" "},{"type":"text","text":"which uses the protocol’s required "},{"type":"codeVoice","code":"dice"},{"text":" property to provide its dice roll values.","type":"text"}]},{"inlineContent":[{"text":"Note that the ","type":"text"},{"type":"codeVoice","code":"delegate"},{"type":"text","text":" property is defined as an "},{"inlineContent":[{"text":"optional","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"codeVoice","code":"DiceGameDelegate"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"because a delegate isn’t required in order to play the game."},{"text":" ","type":"text"},{"type":"text","text":"Because it’s of an optional type,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"delegate"},{"type":"text","text":" property is automatically set to an initial value of "},{"code":"nil","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Thereafter, the game instantiator has the option to set the property to a suitable delegate."},{"type":"text","text":" "},{"type":"text","text":"Because the "},{"code":"DiceGameDelegate","type":"codeVoice"},{"type":"text","text":" protocol is class-only, you can declare the"},{"type":"text","text":" "},{"type":"text","text":"delegate to be "},{"code":"weak","type":"codeVoice"},{"text":" to prevent reference cycles.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"codeVoice","code":"DiceGameDelegate"},{"text":" provides three methods for tracking the progress of a game.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"These three methods have been incorporated into the game logic within"},{"text":" ","type":"text"},{"type":"text","text":"the "},{"code":"play()","type":"codeVoice"},{"type":"text","text":" method above, and are called when"},{"text":" ","type":"text"},{"type":"text","text":"a new game starts, a new turn begins, or the game ends."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because the "},{"type":"codeVoice","code":"delegate"},{"text":" property is an ","type":"text"},{"inlineContent":[{"type":"text","text":"optional"}],"type":"emphasis"},{"type":"text","text":" "},{"code":"DiceGameDelegate","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the "},{"code":"play()","type":"codeVoice"},{"text":" method uses optional chaining each time it calls a method on the delegate.","type":"text"},{"type":"text","text":" "},{"text":"If the ","type":"text"},{"code":"delegate","type":"codeVoice"},{"type":"text","text":" property is nil,"},{"text":" ","type":"text"},{"text":"these delegate calls fail gracefully and without error.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"If the "},{"code":"delegate","type":"codeVoice"},{"type":"text","text":" property is non-nil,"},{"type":"text","text":" "},{"text":"the delegate methods are called,","type":"text"},{"type":"text","text":" "},{"text":"and are passed the ","type":"text"},{"type":"codeVoice","code":"SnakesAndLadders"},{"type":"text","text":" instance as a parameter."}]},{"type":"paragraph","inlineContent":[{"text":"This next example shows a class called ","type":"text"},{"type":"codeVoice","code":"DiceGameTracker"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"which adopts the "},{"type":"codeVoice","code":"DiceGameDelegate"},{"text":" protocol:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["class DiceGameTracker: DiceGameDelegate {","    var numberOfTurns = 0","    func gameDidStart(_ game: DiceGame) {","        numberOfTurns = 0","        if game is SnakesAndLadders {","            print(\"Started a new game of Snakes and Ladders\")","        }","        print(\"The game is using a \\(game.dice.sides)-sided dice\")","    }","    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {","        numberOfTurns += 1","        print(\"Rolled a \\(diceRoll)\")","    }","    func gameDidEnd(_ game: DiceGame) {","        print(\"The game lasted for \\(numberOfTurns) turns\")","    }","}"]},{"inlineContent":[{"code":"DiceGameTracker","type":"codeVoice"},{"text":" implements all three methods required by ","type":"text"},{"code":"DiceGameDelegate","type":"codeVoice"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"It uses these methods to keep track of the number of turns a game has taken."},{"type":"text","text":" "},{"type":"text","text":"It resets a "},{"type":"codeVoice","code":"numberOfTurns"},{"type":"text","text":" property to zero when the game starts,"},{"text":" ","type":"text"},{"text":"increments it each time a new turn begins,","type":"text"},{"text":" ","type":"text"},{"text":"and prints out the total number of turns once the game has ended.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The implementation of "},{"type":"codeVoice","code":"gameDidStart(_:)"},{"type":"text","text":" shown above uses the "},{"code":"game","type":"codeVoice"},{"text":" parameter","type":"text"},{"text":" ","type":"text"},{"text":"to print some introductory information about the game that’s about to be played.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The "},{"code":"game","type":"codeVoice"},{"text":" parameter has a type of ","type":"text"},{"type":"codeVoice","code":"DiceGame"},{"type":"text","text":", not "},{"code":"SnakesAndLadders","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"and so ","type":"text"},{"code":"gameDidStart(_:)","type":"codeVoice"},{"type":"text","text":" can access and use only methods and properties that"},{"type":"text","text":" "},{"type":"text","text":"are implemented as part of the "},{"type":"codeVoice","code":"DiceGame"},{"text":" protocol.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"However, the method is still able to use type casting to"},{"type":"text","text":" "},{"type":"text","text":"query the type of the underlying instance."},{"text":" ","type":"text"},{"type":"text","text":"In this example, it checks whether "},{"type":"codeVoice","code":"game"},{"text":" is actually","type":"text"},{"type":"text","text":" "},{"type":"text","text":"an instance of "},{"code":"SnakesAndLadders","type":"codeVoice"},{"type":"text","text":" behind the scenes,"},{"text":" ","type":"text"},{"type":"text","text":"and prints an appropriate message if so."}]},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"gameDidStart(_:)"},{"text":" method also accesses the ","type":"text"},{"code":"dice","type":"codeVoice"},{"text":" property of the passed ","type":"text"},{"type":"codeVoice","code":"game"},{"text":" parameter.","type":"text"},{"type":"text","text":" "},{"text":"Because ","type":"text"},{"type":"codeVoice","code":"game"},{"type":"text","text":" is known to conform to the "},{"type":"codeVoice","code":"DiceGame"},{"type":"text","text":" protocol,"},{"text":" ","type":"text"},{"type":"text","text":"it’s guaranteed to have a "},{"code":"dice","type":"codeVoice"},{"type":"text","text":" property,"},{"type":"text","text":" "},{"type":"text","text":"and so the "},{"type":"codeVoice","code":"gameDidStart(_:)"},{"text":" method is able to access and print the dice’s ","type":"text"},{"type":"codeVoice","code":"sides"},{"text":" property,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"regardless of what kind of game is being played."}],"type":"paragraph"},{"inlineContent":[{"text":"Here’s how ","type":"text"},{"code":"DiceGameTracker","type":"codeVoice"},{"type":"text","text":" looks in action:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let tracker = DiceGameTracker()","let game = SnakesAndLadders()","game.delegate = tracker","game.play()","\/\/ Started a new game of Snakes and Ladders","\/\/ The game is using a 6-sided dice","\/\/ Rolled a 3","\/\/ Rolled a 5","\/\/ Rolled a 4","\/\/ Rolled a 5","\/\/ The game lasted for 4 turns"]},{"anchor":"Adding-Protocol-Conformance-with-an-Extension","level":2,"text":"Adding Protocol Conformance with an Extension","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"You can extend an existing type to adopt and conform to a new protocol,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"even if you don’t have access to the source code for the existing type."},{"type":"text","text":" "},{"type":"text","text":"Extensions can add new properties, methods, and subscripts to an existing type,"},{"text":" ","type":"text"},{"type":"text","text":"and are therefore able to add any requirements that a protocol may demand."},{"type":"text","text":" "},{"type":"text","text":"For more about extensions, see "},{"isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Extensions","type":"reference"},{"text":".","type":"text"}]},{"style":"note","name":"Note","content":[{"inlineContent":[{"type":"text","text":"Existing instances of a type automatically adopt and conform to a protocol"},{"text":" ","type":"text"},{"type":"text","text":"when that conformance is added to the instance’s type in an extension."}],"type":"paragraph"}],"type":"aside"},{"inlineContent":[{"type":"text","text":"For example, this protocol, called "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":", can be implemented by"},{"type":"text","text":" "},{"type":"text","text":"any type that has a way to be represented as text."},{"type":"text","text":" "},{"type":"text","text":"This might be a description of itself, or a text version of its current state:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["protocol TextRepresentable {","    var textualDescription: String { get }","}"]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"Dice"},{"text":" class from above can be extended to adopt and conform to ","type":"text"},{"type":"codeVoice","code":"TextRepresentable"},{"text":":","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["extension Dice: TextRepresentable {","    var textualDescription: String {","        return \"A \\(sides)-sided dice\"","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"This extension adopts the new protocol in exactly the same way","type":"text"},{"type":"text","text":" "},{"type":"text","text":"as if "},{"type":"codeVoice","code":"Dice"},{"text":" had provided it in its original implementation.","type":"text"},{"type":"text","text":" "},{"text":"The protocol name is provided after the type name, separated by a colon,","type":"text"},{"text":" ","type":"text"},{"text":"and an implementation of all requirements of the protocol","type":"text"},{"text":" ","type":"text"},{"text":"is provided within the extension’s curly braces.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Any "},{"type":"codeVoice","code":"Dice"},{"type":"text","text":" instance can now be treated as "},{"type":"codeVoice","code":"TextRepresentable"},{"text":":","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["let d12 = Dice(sides: 12, generator: LinearCongruentialGenerator())","print(d12.textualDescription)","\/\/ Prints \"A 12-sided dice\""]},{"inlineContent":[{"type":"text","text":"Similarly, the "},{"type":"codeVoice","code":"SnakesAndLadders"},{"text":" game class can be extended to","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"adopt and conform to the "},{"type":"codeVoice","code":"TextRepresentable"},{"text":" protocol:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["extension SnakesAndLadders: TextRepresentable {","    var textualDescription: String {","        return \"A game of Snakes and Ladders with \\(finalSquare) squares\"","    }","}","print(game.textualDescription)","\/\/ Prints \"A game of Snakes and Ladders with 25 squares\""],"syntax":"swift"},{"anchor":"Conditionally-Conforming-to-a-Protocol","text":"Conditionally Conforming to a Protocol","level":3,"type":"heading"},{"type":"paragraph","inlineContent":[{"text":"A generic type may be able to satisfy the requirements of a protocol","type":"text"},{"type":"text","text":" "},{"text":"only under certain conditions,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"such as when the type’s generic parameter conforms to the protocol."},{"type":"text","text":" "},{"type":"text","text":"You can make a generic type conditionally conform to a protocol"},{"type":"text","text":" "},{"type":"text","text":"by listing constraints when extending the type."},{"type":"text","text":" "},{"type":"text","text":"Write these constraints after the name of the protocol you’re adopting"},{"text":" ","type":"text"},{"text":"by writing a generic ","type":"text"},{"code":"where","type":"codeVoice"},{"type":"text","text":" clause."},{"type":"text","text":" "},{"text":"For more about generic ","type":"text"},{"code":"where","type":"codeVoice"},{"type":"text","text":" clauses, see "},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics#Generic-Where-Clauses"},{"type":"text","text":"."}]},{"inlineContent":[{"type":"text","text":"The following extension"},{"type":"text","text":" "},{"type":"text","text":"makes "},{"code":"Array","type":"codeVoice"},{"type":"text","text":" instances conform to the "},{"type":"codeVoice","code":"TextRepresentable"},{"text":" protocol","type":"text"},{"type":"text","text":" "},{"text":"whenever they store elements of a type that conforms to ","type":"text"},{"code":"TextRepresentable","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"codeListing","code":["extension Array: TextRepresentable where Element: TextRepresentable {","    var textualDescription: String {","        let itemsAsText = self.map { $0.textualDescription }","        return \"[\" + itemsAsText.joined(separator: \", \") + \"]\"","    }","}","let myDice = [d6, d12]","print(myDice.textualDescription)","\/\/ Prints \"[A 6-sided dice, A 12-sided dice]\""],"syntax":"swift"},{"text":"Declaring Protocol Adoption with an Extension","anchor":"Declaring-Protocol-Adoption-with-an-Extension","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"text":"If a type already conforms to all of the requirements of a protocol,","type":"text"},{"type":"text","text":" "},{"text":"but hasn’t yet stated that it adopts that protocol,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"you can make it adopt the protocol with an empty extension:"}]},{"syntax":"swift","code":["struct Hamster {","    var name: String","    var textualDescription: String {","        return \"A hamster named \\(name)\"","    }","}","extension Hamster: TextRepresentable {}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Instances of "},{"code":"Hamster","type":"codeVoice"},{"text":" can now be used wherever ","type":"text"},{"code":"TextRepresentable","type":"codeVoice"},{"text":" is the required type:","type":"text"}]},{"code":["let simonTheHamster = Hamster(name: \"Simon\")","let somethingTextRepresentable: TextRepresentable = simonTheHamster","print(somethingTextRepresentable.textualDescription)","\/\/ Prints \"A hamster named Simon\""],"type":"codeListing","syntax":"swift"},{"content":[{"inlineContent":[{"text":"Types don’t automatically adopt a protocol just by satisfying its requirements.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"They must always explicitly declare their adoption of the protocol."}],"type":"paragraph"}],"type":"aside","name":"Note","style":"note"},{"level":2,"anchor":"Adopting-a-Protocol-Using-a-Synthesized-Implementation","type":"heading","text":"Adopting a Protocol Using a Synthesized Implementation"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift can automatically provide the protocol conformance"},{"text":" ","type":"text"},{"type":"text","text":"for "},{"type":"codeVoice","code":"Equatable"},{"text":", ","type":"text"},{"code":"Hashable","type":"codeVoice"},{"type":"text","text":", and "},{"type":"codeVoice","code":"Comparable"},{"text":" ","type":"text"},{"type":"text","text":"in many simple cases."},{"text":" ","type":"text"},{"text":"Using this synthesized implementation","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"means you don’t have to write repetitive boilerplate code"},{"type":"text","text":" "},{"type":"text","text":"to implement the protocol requirements yourself."}]},{"type":"paragraph","inlineContent":[{"text":"Swift provides a synthesized implementation of ","type":"text"},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" "},{"type":"text","text":"for the following kinds of custom types:"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Structures that have only stored properties that conform to the ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"type":"text","text":" protocol"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Enumerations that have only associated types that conform to the ","type":"text"},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" protocol"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Enumerations that have no associated types"}]}]}]},{"type":"paragraph","inlineContent":[{"text":"To receive a synthesized implementation of ","type":"text"},{"type":"codeVoice","code":"=="},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"declare conformance to ","type":"text"},{"type":"codeVoice","code":"Equatable"},{"text":" ","type":"text"},{"text":"in the file that contains the original declaration,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"without implementing an "},{"type":"codeVoice","code":"=="},{"type":"text","text":" operator yourself."},{"type":"text","text":" "},{"text":"The ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"type":"text","text":" protocol provides a default implementation of "},{"code":"!=","type":"codeVoice"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The example below defines a ","type":"text"},{"code":"Vector3D","type":"codeVoice"},{"text":" structure","type":"text"},{"type":"text","text":" "},{"text":"for a three-dimensional position vector ","type":"text"},{"code":"(x, y, z)","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"similar to the "},{"type":"codeVoice","code":"Vector2D"},{"text":" structure.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Because the "},{"type":"codeVoice","code":"x"},{"text":", ","type":"text"},{"code":"y","type":"codeVoice"},{"text":", and ","type":"text"},{"type":"codeVoice","code":"z"},{"text":" properties are all of an ","type":"text"},{"type":"codeVoice","code":"Equatable"},{"text":" type,","type":"text"},{"type":"text","text":" "},{"code":"Vector3D","type":"codeVoice"},{"text":" receives synthesized implementations","type":"text"},{"type":"text","text":" "},{"text":"of the equivalence operators.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["struct Vector3D: Equatable {","    var x = 0.0, y = 0.0, z = 0.0","}","","let twoThreeFour = Vector3D(x: 2.0, y: 3.0, z: 4.0)","let anotherTwoThreeFour = Vector3D(x: 2.0, y: 3.0, z: 4.0)","if twoThreeFour == anotherTwoThreeFour {","    print(\"These two vectors are also equivalent.\")","}","\/\/ Prints \"These two vectors are also equivalent.\""]},{"type":"paragraph","inlineContent":[{"text":"Swift provides a synthesized implementation of ","type":"text"},{"code":"Hashable","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"for the following kinds of custom types:"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Structures that have only stored properties that conform to the ","type":"text"},{"type":"codeVoice","code":"Hashable"},{"text":" protocol","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Enumerations that have only associated types that conform to the "},{"type":"codeVoice","code":"Hashable"},{"text":" protocol","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Enumerations that have no associated types"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To receive a synthesized implementation of "},{"code":"hash(into:)","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"declare conformance to "},{"type":"codeVoice","code":"Hashable"},{"text":" ","type":"text"},{"text":"in the file that contains the original declaration,","type":"text"},{"type":"text","text":" "},{"text":"without implementing a ","type":"text"},{"code":"hash(into:)","type":"codeVoice"},{"type":"text","text":" method yourself."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift provides a synthesized implementation of "},{"type":"codeVoice","code":"Comparable"},{"type":"text","text":" "},{"type":"text","text":"for enumerations that don’t have a raw value."},{"type":"text","text":" "},{"type":"text","text":"If the enumeration has associated types,"},{"type":"text","text":" "},{"text":"they must all conform to the ","type":"text"},{"type":"codeVoice","code":"Comparable"},{"text":" protocol.","type":"text"},{"type":"text","text":" "},{"text":"To receive a synthesized implementation of ","type":"text"},{"type":"codeVoice","code":"<"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"declare conformance to "},{"type":"codeVoice","code":"Comparable"},{"type":"text","text":" "},{"type":"text","text":"in the file that contains the original enumeration declaration,"},{"type":"text","text":" "},{"type":"text","text":"without implementing a "},{"code":"<","type":"codeVoice"},{"type":"text","text":" operator yourself."},{"text":" ","type":"text"},{"type":"text","text":"The "},{"type":"codeVoice","code":"Comparable"},{"type":"text","text":" protocol’s default implementation"},{"type":"text","text":" "},{"text":"of ","type":"text"},{"type":"codeVoice","code":"<="},{"text":", ","type":"text"},{"type":"codeVoice","code":">"},{"type":"text","text":", and "},{"type":"codeVoice","code":">="},{"text":" provides the remaining comparison operators.","type":"text"}]},{"inlineContent":[{"type":"text","text":"The example below defines a "},{"type":"codeVoice","code":"SkillLevel"},{"type":"text","text":" enumeration"},{"type":"text","text":" "},{"text":"with cases for beginners, intermediates, and experts.","type":"text"},{"type":"text","text":" "},{"text":"Experts are additionally ranked by the number of stars they have.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["enum SkillLevel: Comparable {","    case beginner","    case intermediate","    case expert(stars: Int)","}","var levels = [SkillLevel.intermediate, SkillLevel.beginner,","              SkillLevel.expert(stars: 5), SkillLevel.expert(stars: 3)]","for level in levels.sorted() {","    print(level)","}","\/\/ Prints \"beginner\"","\/\/ Prints \"intermediate\"","\/\/ Prints \"expert(stars: 3)\"","\/\/ Prints \"expert(stars: 5)\""]},{"text":"Collections of Protocol Types","anchor":"Collections-of-Protocol-Types","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"A protocol can be used as the type to be stored in"},{"type":"text","text":" "},{"type":"text","text":"a collection such as an array or a dictionary,"},{"text":" ","type":"text"},{"type":"text","text":"as mentioned in "},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Protocols-as-Types","isActive":true},{"type":"text","text":"."},{"text":" ","type":"text"},{"text":"This example creates an array of ","type":"text"},{"code":"TextRepresentable","type":"codeVoice"},{"type":"text","text":" things:"}]},{"type":"codeListing","syntax":"swift","code":["let things: [TextRepresentable] = [game, d12, simonTheHamster]"]},{"inlineContent":[{"type":"text","text":"It’s now possible to iterate over the items in the array,"},{"type":"text","text":" "},{"text":"and print each item’s textual description:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["for thing in things {","    print(thing.textualDescription)","}","\/\/ A game of Snakes and Ladders with 25 squares","\/\/ A 12-sided dice","\/\/ A hamster named Simon"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"Note that the "},{"type":"codeVoice","code":"thing"},{"type":"text","text":" constant is of type "},{"code":"TextRepresentable","type":"codeVoice"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"It’s not of type "},{"type":"codeVoice","code":"Dice"},{"text":", or ","type":"text"},{"code":"DiceGame","type":"codeVoice"},{"type":"text","text":", or "},{"type":"codeVoice","code":"Hamster"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"even if the actual instance behind the scenes is of one of those types.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Nonetheless, because it’s of type "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"and anything that’s "},{"code":"TextRepresentable","type":"codeVoice"},{"type":"text","text":" is known to have a "},{"type":"codeVoice","code":"textualDescription"},{"type":"text","text":" property,"},{"text":" ","type":"text"},{"type":"text","text":"it’s safe to access "},{"type":"codeVoice","code":"thing.textualDescription"},{"type":"text","text":" each time through the loop."}],"type":"paragraph"},{"level":2,"anchor":"Protocol-Inheritance","type":"heading","text":"Protocol Inheritance"},{"inlineContent":[{"text":"A protocol can ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"inherit"}]},{"text":" one or more other protocols","type":"text"},{"type":"text","text":" "},{"text":"and can add further requirements on top of the requirements it inherits.","type":"text"},{"type":"text","text":" "},{"text":"The syntax for protocol inheritance is similar to the syntax for class inheritance,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"but with the option to list multiple inherited protocols, separated by commas:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["protocol InheritingProtocol: SomeProtocol, AnotherProtocol {","    \/\/ protocol definition goes here","}"]},{"inlineContent":[{"type":"text","text":"Here’s an example of a protocol that inherits"},{"type":"text","text":" "},{"text":"the ","type":"text"},{"type":"codeVoice","code":"TextRepresentable"},{"text":" protocol from above:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["protocol PrettyTextRepresentable: TextRepresentable {","    var prettyTextualDescription: String { get }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example defines a new protocol, "},{"code":"PrettyTextRepresentable","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"which inherits from "},{"code":"TextRepresentable","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Anything that adopts "},{"type":"codeVoice","code":"PrettyTextRepresentable"},{"type":"text","text":" must satisfy all of the requirements"},{"type":"text","text":" "},{"text":"enforced by ","type":"text"},{"code":"TextRepresentable","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"plus","type":"text"}]},{"text":" the additional requirements enforced by ","type":"text"},{"code":"PrettyTextRepresentable","type":"codeVoice"},{"text":".","type":"text"},{"type":"text","text":" "},{"text":"In this example, ","type":"text"},{"code":"PrettyTextRepresentable","type":"codeVoice"},{"type":"text","text":" adds a single requirement"},{"text":" ","type":"text"},{"text":"to provide a gettable property called ","type":"text"},{"type":"codeVoice","code":"prettyTextualDescription"},{"text":" that returns a ","type":"text"},{"code":"String","type":"codeVoice"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"SnakesAndLadders"},{"type":"text","text":" class can be extended to adopt and conform to "},{"code":"PrettyTextRepresentable","type":"codeVoice"},{"type":"text","text":":"}]},{"code":["extension SnakesAndLadders: PrettyTextRepresentable {","    var prettyTextualDescription: String {","        var output = textualDescription + \":\\n\"","        for index in 1...finalSquare {","            switch board[index] {","            case let ladder where ladder > 0:","                output += \"▲ \"","            case let snake where snake < 0:","                output += \"▼ \"","            default:","                output += \"○ \"","            }","        }","        return output","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"This extension states that it adopts the "},{"type":"codeVoice","code":"PrettyTextRepresentable"},{"type":"text","text":" protocol"},{"type":"text","text":" "},{"type":"text","text":"and provides an implementation of the "},{"code":"prettyTextualDescription","type":"codeVoice"},{"type":"text","text":" property"},{"type":"text","text":" "},{"text":"for the ","type":"text"},{"type":"codeVoice","code":"SnakesAndLadders"},{"text":" type.","type":"text"},{"type":"text","text":" "},{"text":"Anything that’s ","type":"text"},{"code":"PrettyTextRepresentable","type":"codeVoice"},{"text":" must also be ","type":"text"},{"code":"TextRepresentable","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and so the implementation of "},{"type":"codeVoice","code":"prettyTextualDescription"},{"type":"text","text":" starts"},{"type":"text","text":" "},{"type":"text","text":"by accessing the "},{"code":"textualDescription","type":"codeVoice"},{"type":"text","text":" property"},{"text":" ","type":"text"},{"text":"from the ","type":"text"},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":" protocol to begin an output string."},{"text":" ","type":"text"},{"text":"It appends a colon and a line break,","type":"text"},{"text":" ","type":"text"},{"text":"and uses this as the start of its pretty text representation.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"It then iterates through the array of board squares,"},{"type":"text","text":" "},{"type":"text","text":"and appends a geometric shape to represent the contents of each square:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If the square’s value is greater than "},{"type":"codeVoice","code":"0"},{"type":"text","text":", it’s the base of a ladder,"},{"type":"text","text":" "},{"type":"text","text":"and is represented by "},{"type":"codeVoice","code":"▲"},{"text":".","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"If the square’s value is less than ","type":"text"},{"type":"codeVoice","code":"0"},{"type":"text","text":", it’s the head of a snake,"},{"type":"text","text":" "},{"text":"and is represented by ","type":"text"},{"code":"▼","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Otherwise, the square’s value is "},{"code":"0","type":"codeVoice"},{"text":", and it’s a “free” square,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"represented by "},{"type":"codeVoice","code":"○"},{"text":".","type":"text"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"prettyTextualDescription","type":"codeVoice"},{"type":"text","text":" property can now be used to print a pretty text description"},{"text":" ","type":"text"},{"text":"of any ","type":"text"},{"type":"codeVoice","code":"SnakesAndLadders"},{"text":" instance:","type":"text"}]},{"code":["print(game.prettyTextualDescription)","\/\/ A game of Snakes and Ladders with 25 squares:","\/\/ ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○"],"type":"codeListing","syntax":"swift"},{"type":"heading","anchor":"Class-Only-Protocols","level":2,"text":"Class-Only Protocols"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can limit protocol adoption to class types (and not structures or enumerations)"},{"type":"text","text":" "},{"type":"text","text":"by adding the "},{"code":"AnyObject","type":"codeVoice"},{"type":"text","text":" protocol to a protocol’s inheritance list."}]},{"code":["protocol SomeClassOnlyProtocol: AnyObject, SomeInheritedProtocol {","    \/\/ class-only protocol definition goes here","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the example above, "},{"type":"codeVoice","code":"SomeClassOnlyProtocol"},{"text":" can only be adopted by class types.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"It’s a compile-time error to write a structure or enumeration definition"},{"type":"text","text":" "},{"type":"text","text":"that tries to adopt "},{"code":"SomeClassOnlyProtocol","type":"codeVoice"},{"type":"text","text":"."}]},{"name":"Note","content":[{"inlineContent":[{"type":"text","text":"Use a class-only protocol when the behavior defined by that protocol’s requirements"},{"type":"text","text":" "},{"type":"text","text":"assumes or requires that a conforming type has"},{"text":" ","type":"text"},{"type":"text","text":"reference semantics rather than value semantics."},{"text":" ","type":"text"},{"text":"For more about reference and value semantics,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"see "},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ClassesAndStructures#Structures-and-Enumerations-Are-Value-Types","type":"reference","isActive":true},{"text":" ","type":"text"},{"text":"and ","type":"text"},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ClassesAndStructures#Classes-Are-Reference-Types","isActive":true,"type":"reference"},{"type":"text","text":"."}],"type":"paragraph"}],"type":"aside","style":"note"},{"text":"Protocol Composition","level":2,"anchor":"Protocol-Composition","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"It can be useful to require a type to conform to multiple protocols at the same time."},{"text":" ","type":"text"},{"type":"text","text":"You can combine multiple protocols into a single requirement"},{"type":"text","text":" "},{"type":"text","text":"with a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"protocol composition"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Protocol compositions behave as if you"},{"type":"text","text":" "},{"type":"text","text":"defined a temporary local protocol that has the combined requirements"},{"text":" ","type":"text"},{"text":"of all protocols in the composition.","type":"text"},{"text":" ","type":"text"},{"text":"Protocol compositions don’t define any new protocol types.","type":"text"}]},{"inlineContent":[{"text":"Protocol compositions have the form ","type":"text"},{"type":"codeVoice","code":"SomeProtocol & AnotherProtocol"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"You can list as many protocols as you need,"},{"type":"text","text":" "},{"text":"separating them with ampersands (","type":"text"},{"code":"&","type":"codeVoice"},{"text":").","type":"text"},{"type":"text","text":" "},{"text":"In addition to its list of protocols,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"a protocol composition can also contain one class type,"},{"type":"text","text":" "},{"text":"which you can use to specify a required superclass.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Here’s an example that combines two protocols called ","type":"text"},{"type":"codeVoice","code":"Named"},{"text":" and ","type":"text"},{"code":"Aged","type":"codeVoice"},{"type":"text","text":" "},{"text":"into a single protocol composition requirement on a function parameter:","type":"text"}],"type":"paragraph"},{"code":["protocol Named {","    var name: String { get }","}","protocol Aged {","    var age: Int { get }","}","struct Person: Named, Aged {","    var name: String","    var age: Int","}","func wishHappyBirthday(to celebrator: Named & Aged) {","    print(\"Happy birthday, \\(celebrator.name), you're \\(celebrator.age)!\")","}","let birthdayPerson = Person(name: \"Malcolm\", age: 21)","wishHappyBirthday(to: birthdayPerson)","\/\/ Prints \"Happy birthday, Malcolm, you're 21!\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"In this example,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"code":"Named","type":"codeVoice"},{"type":"text","text":" protocol"},{"text":" ","type":"text"},{"type":"text","text":"has a single requirement for a gettable "},{"code":"String","type":"codeVoice"},{"text":" property called ","type":"text"},{"type":"codeVoice","code":"name"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"Aged"},{"text":" protocol","type":"text"},{"type":"text","text":" "},{"type":"text","text":"has a single requirement for a gettable "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" property called "},{"type":"codeVoice","code":"age"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"Both protocols are adopted by a structure called ","type":"text"},{"code":"Person","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The example also defines a "},{"type":"codeVoice","code":"wishHappyBirthday(to:)"},{"text":" function.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The type of the "},{"code":"celebrator","type":"codeVoice"},{"type":"text","text":" parameter is "},{"code":"Named & Aged","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"which means “any type that conforms to both the "},{"type":"codeVoice","code":"Named"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Aged"},{"text":" protocols.”","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"It doesn’t matter which specific type is passed to the function,"},{"type":"text","text":" "},{"type":"text","text":"as long as it conforms to both of the required protocols."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example then creates a new "},{"code":"Person","type":"codeVoice"},{"type":"text","text":" instance called "},{"code":"birthdayPerson","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"and passes this new instance to the "},{"code":"wishHappyBirthday(to:)","type":"codeVoice"},{"text":" function.","type":"text"},{"text":" ","type":"text"},{"text":"Because ","type":"text"},{"type":"codeVoice","code":"Person"},{"type":"text","text":" conforms to both protocols, this call is valid,"},{"text":" ","type":"text"},{"type":"text","text":"and the "},{"code":"wishHappyBirthday(to:)","type":"codeVoice"},{"type":"text","text":" function can print its birthday greeting."}]},{"type":"paragraph","inlineContent":[{"text":"Here’s an example that combines","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the "},{"type":"codeVoice","code":"Named"},{"text":" protocol from the previous example","type":"text"},{"type":"text","text":" "},{"type":"text","text":"with a "},{"type":"codeVoice","code":"Location"},{"type":"text","text":" class:"}]},{"syntax":"swift","type":"codeListing","code":["class Location {","    var latitude: Double","    var longitude: Double","    init(latitude: Double, longitude: Double) {","        self.latitude = latitude","        self.longitude = longitude","    }","}","class City: Location, Named {","    var name: String","    init(name: String, latitude: Double, longitude: Double) {","        self.name = name","        super.init(latitude: latitude, longitude: longitude)","    }","}","func beginConcert(in location: Location & Named) {","    print(\"Hello, \\(location.name)!\")","}","","let seattle = City(name: \"Seattle\", latitude: 47.6, longitude: -122.3)","beginConcert(in: seattle)","\/\/ Prints \"Hello, Seattle!\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"beginConcert(in:)"},{"type":"text","text":" function takes"},{"text":" ","type":"text"},{"type":"text","text":"a parameter of type "},{"type":"codeVoice","code":"Location & Named"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"which means “any type that’s a subclass of "},{"type":"codeVoice","code":"Location"},{"text":" ","type":"text"},{"type":"text","text":"and that conforms to the "},{"type":"codeVoice","code":"Named"},{"text":" protocol.”","type":"text"},{"type":"text","text":" "},{"type":"text","text":"In this case, "},{"type":"codeVoice","code":"City"},{"text":" satisfies both requirements.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Passing ","type":"text"},{"code":"birthdayPerson","type":"codeVoice"},{"type":"text","text":" to the "},{"type":"codeVoice","code":"beginConcert(in:)"},{"type":"text","text":" function"},{"type":"text","text":" "},{"text":"is invalid because ","type":"text"},{"code":"Person","type":"codeVoice"},{"text":" isn’t a subclass of ","type":"text"},{"type":"codeVoice","code":"Location"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"Likewise,"},{"text":" ","type":"text"},{"text":"if you made a subclass of ","type":"text"},{"code":"Location","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"that didn’t conform to the "},{"type":"codeVoice","code":"Named"},{"text":" protocol,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"calling "},{"type":"codeVoice","code":"beginConcert(in:)"},{"type":"text","text":" with an instance of that type"},{"text":" ","type":"text"},{"type":"text","text":"is also invalid."}]},{"type":"heading","text":"Checking for Protocol Conformance","anchor":"Checking-for-Protocol-Conformance","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use the "},{"type":"codeVoice","code":"is"},{"text":" and ","type":"text"},{"code":"as","type":"codeVoice"},{"type":"text","text":" operators described in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting"},{"type":"text","text":" "},{"type":"text","text":"to check for protocol conformance, and to cast to a specific protocol."},{"type":"text","text":" "},{"text":"Checking for and casting to a protocol","type":"text"},{"type":"text","text":" "},{"text":"follows exactly the same syntax as checking for and casting to a type:","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"The "},{"code":"is","type":"codeVoice"},{"type":"text","text":" operator returns "},{"type":"codeVoice","code":"true"},{"type":"text","text":" if an instance conforms to a protocol"},{"text":" ","type":"text"},{"type":"text","text":"and returns "},{"type":"codeVoice","code":"false"},{"text":" if it doesn’t.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"as?"},{"type":"text","text":" version of the downcast operator returns"},{"type":"text","text":" "},{"text":"an optional value of the protocol’s type,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and this value is "},{"type":"codeVoice","code":"nil"},{"text":" if the instance doesn’t conform to that protocol.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"as!"},{"text":" version of the downcast operator forces the downcast to the protocol type","type":"text"},{"text":" ","type":"text"},{"text":"and triggers a runtime error if the downcast doesn’t succeed.","type":"text"}]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"This example defines a protocol called "},{"type":"codeVoice","code":"HasArea"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"with a single property requirement of a gettable ","type":"text"},{"type":"codeVoice","code":"Double"},{"type":"text","text":" property called "},{"type":"codeVoice","code":"area"},{"type":"text","text":":"}],"type":"paragraph"},{"code":["protocol HasArea {","    var area: Double { get }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Here are two classes, ","type":"text"},{"type":"codeVoice","code":"Circle"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Country"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"both of which conform to the ","type":"text"},{"code":"HasArea","type":"codeVoice"},{"type":"text","text":" protocol:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["class Circle: HasArea {","    let pi = 3.1415927","    var radius: Double","    var area: Double { return pi * radius * radius }","    init(radius: Double) { self.radius = radius }","}","class Country: HasArea {","    var area: Double","    init(area: Double) { self.area = area }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Circle"},{"type":"text","text":" class implements the "},{"code":"area","type":"codeVoice"},{"type":"text","text":" property requirement"},{"type":"text","text":" "},{"text":"as a computed property, based on a stored ","type":"text"},{"code":"radius","type":"codeVoice"},{"text":" property.","type":"text"},{"type":"text","text":" "},{"text":"The ","type":"text"},{"code":"Country","type":"codeVoice"},{"text":" class implements the ","type":"text"},{"code":"area","type":"codeVoice"},{"type":"text","text":" requirement directly as a stored property."},{"text":" ","type":"text"},{"text":"Both classes correctly conform to the ","type":"text"},{"type":"codeVoice","code":"HasArea"},{"type":"text","text":" protocol."}]},{"inlineContent":[{"text":"Here’s a class called ","type":"text"},{"code":"Animal","type":"codeVoice"},{"type":"text","text":", which doesn’t conform to the "},{"type":"codeVoice","code":"HasArea"},{"type":"text","text":" protocol:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["class Animal {","    var legs: Int","    init(legs: Int) { self.legs = legs }","}"]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"Circle"},{"text":", ","type":"text"},{"type":"codeVoice","code":"Country"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Animal"},{"text":" classes don’t have a shared base class.","type":"text"},{"type":"text","text":" "},{"text":"Nonetheless, they’re all classes, and so instances of all three types","type":"text"},{"type":"text","text":" "},{"type":"text","text":"can be used to initialize an array that stores values of type "},{"code":"AnyObject","type":"codeVoice"},{"text":":","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["let objects: [AnyObject] = [","    Circle(radius: 2.0),","    Country(area: 243_610),","    Animal(legs: 4)","]"]},{"inlineContent":[{"type":"text","text":"The "},{"code":"objects","type":"codeVoice"},{"text":" array is initialized with an array literal containing","type":"text"},{"type":"text","text":" "},{"text":"a ","type":"text"},{"code":"Circle","type":"codeVoice"},{"type":"text","text":" instance with a radius of 2 units;"},{"type":"text","text":" "},{"text":"a ","type":"text"},{"code":"Country","type":"codeVoice"},{"type":"text","text":" instance initialized with"},{"type":"text","text":" "},{"type":"text","text":"the surface area of the United Kingdom in square kilometers;"},{"text":" ","type":"text"},{"type":"text","text":"and an "},{"code":"Animal","type":"codeVoice"},{"type":"text","text":" instance with four legs."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"objects","type":"codeVoice"},{"type":"text","text":" array can now be iterated,"},{"text":" ","type":"text"},{"type":"text","text":"and each object in the array can be checked to see if"},{"text":" ","type":"text"},{"text":"it conforms to the ","type":"text"},{"code":"HasArea","type":"codeVoice"},{"text":" protocol:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["for object in objects {","    if let objectWithArea = object as? HasArea {","        print(\"Area is \\(objectWithArea.area)\")","    } else {","        print(\"Something that doesn't have an area\")","    }","}","\/\/ Area is 12.5663708","\/\/ Area is 243610.0","\/\/ Something that doesn't have an area"]},{"type":"paragraph","inlineContent":[{"text":"Whenever an object in the array conforms to the ","type":"text"},{"type":"codeVoice","code":"HasArea"},{"type":"text","text":" protocol,"},{"type":"text","text":" "},{"text":"the optional value returned by the ","type":"text"},{"code":"as?","type":"codeVoice"},{"type":"text","text":" operator is unwrapped with optional binding"},{"text":" ","type":"text"},{"text":"into a constant called ","type":"text"},{"type":"codeVoice","code":"objectWithArea"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The "},{"code":"objectWithArea","type":"codeVoice"},{"text":" constant is known to be of type ","type":"text"},{"code":"HasArea","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and so its "},{"code":"area","type":"codeVoice"},{"type":"text","text":" property can be accessed and printed in a type-safe way."}]},{"inlineContent":[{"type":"text","text":"Note that the underlying objects aren’t changed by the casting process."},{"type":"text","text":" "},{"type":"text","text":"They continue to be a "},{"code":"Circle","type":"codeVoice"},{"type":"text","text":", a "},{"code":"Country","type":"codeVoice"},{"type":"text","text":" and an "},{"code":"Animal","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"However, at the point that they’re stored in the ","type":"text"},{"type":"codeVoice","code":"objectWithArea"},{"type":"text","text":" constant,"},{"text":" ","type":"text"},{"text":"they’re only known to be of type ","type":"text"},{"type":"codeVoice","code":"HasArea"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"and so only their ","type":"text"},{"code":"area","type":"codeVoice"},{"type":"text","text":" property can be accessed."}],"type":"paragraph"},{"text":"Optional Protocol Requirements","anchor":"Optional-Protocol-Requirements","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"You can define "},{"inlineContent":[{"text":"optional requirements","type":"text"}],"type":"emphasis"},{"type":"text","text":" for protocols."},{"text":" ","type":"text"},{"type":"text","text":"These requirements don’t have to be implemented by types that conform to the protocol."},{"text":" ","type":"text"},{"text":"Optional requirements are prefixed by the ","type":"text"},{"type":"codeVoice","code":"optional"},{"type":"text","text":" modifier"},{"type":"text","text":" "},{"type":"text","text":"as part of the protocol’s definition."},{"type":"text","text":" "},{"type":"text","text":"Optional requirements are available so that you can write code"},{"type":"text","text":" "},{"text":"that interoperates with Objective-C.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Both the protocol and the optional requirement"},{"text":" ","type":"text"},{"text":"must be marked with the ","type":"text"},{"type":"codeVoice","code":"@objc"},{"type":"text","text":" attribute."},{"type":"text","text":" "},{"type":"text","text":"Note that "},{"code":"@objc","type":"codeVoice"},{"text":" protocols can be adopted only by classes,","type":"text"},{"type":"text","text":" "},{"text":"not by structures or enumerations.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"When you use a method or property in an optional requirement,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"its type automatically becomes an optional."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"text":" ","type":"text"},{"text":"a method of type ","type":"text"},{"code":"(Int) -> String","type":"codeVoice"},{"text":" becomes ","type":"text"},{"code":"((Int) -> String)?","type":"codeVoice"},{"type":"text","text":"."},{"text":" ","type":"text"},{"text":"Note that the entire function type","type":"text"},{"type":"text","text":" "},{"type":"text","text":"is wrapped in the optional,"},{"type":"text","text":" "},{"type":"text","text":"not the method’s return value."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"An optional protocol requirement can be called with optional chaining,"},{"type":"text","text":" "},{"text":"to account for the possibility that the requirement was not implemented","type":"text"},{"text":" ","type":"text"},{"text":"by a type that conforms to the protocol.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"You check for an implementation of an optional method"},{"text":" ","type":"text"},{"type":"text","text":"by writing a question mark after the name of the method when it’s called,"},{"type":"text","text":" "},{"text":"such as ","type":"text"},{"code":"someOptionalMethod?(someArgument)","type":"codeVoice"},{"type":"text","text":"."},{"text":" ","type":"text"},{"text":"For information on optional chaining, see ","type":"text"},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OptionalChaining","type":"reference","isActive":true},{"text":".","type":"text"}]},{"inlineContent":[{"type":"text","text":"The following example defines an integer-counting class called "},{"code":"Counter","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"which uses an external data source to provide its increment amount."},{"text":" ","type":"text"},{"text":"This data source is defined by the ","type":"text"},{"code":"CounterDataSource","type":"codeVoice"},{"text":" protocol,","type":"text"},{"text":" ","type":"text"},{"text":"which has two optional requirements:","type":"text"}],"type":"paragraph"},{"code":["@objc protocol CounterDataSource {","    @objc optional func increment(forCount count: Int) -> Int","    @objc optional var fixedIncrement: Int { get }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"CounterDataSource"},{"type":"text","text":" protocol defines"},{"text":" ","type":"text"},{"type":"text","text":"an optional method requirement called "},{"code":"increment(forCount:)","type":"codeVoice"},{"text":" ","type":"text"},{"text":"and an optional property requirement called ","type":"text"},{"code":"fixedIncrement","type":"codeVoice"},{"type":"text","text":"."},{"text":" ","type":"text"},{"text":"These requirements define two different ways for data sources to provide","type":"text"},{"text":" ","type":"text"},{"text":"an appropriate increment amount for a ","type":"text"},{"type":"codeVoice","code":"Counter"},{"type":"text","text":" instance."}]},{"style":"note","name":"Note","content":[{"inlineContent":[{"type":"text","text":"Strictly speaking, you can write a custom class"},{"text":" ","type":"text"},{"text":"that conforms to ","type":"text"},{"type":"codeVoice","code":"CounterDataSource"},{"type":"text","text":" without implementing"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"either","type":"text"}]},{"text":" protocol requirement.","type":"text"},{"type":"text","text":" "},{"text":"They’re both optional, after all.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Although technically allowed, this wouldn’t make for a very good data source."}],"type":"paragraph"}],"type":"aside"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"Counter"},{"text":" class, defined below,","type":"text"},{"type":"text","text":" "},{"text":"has an optional ","type":"text"},{"code":"dataSource","type":"codeVoice"},{"type":"text","text":" property of type "},{"code":"CounterDataSource?","type":"codeVoice"},{"type":"text","text":":"}]},{"syntax":"swift","code":["class Counter {","    var count = 0","    var dataSource: CounterDataSource?","    func increment() {","        if let amount = dataSource?.increment?(forCount: count) {","            count += amount","        } else if let amount = dataSource?.fixedIncrement {","            count += amount","        }","    }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Counter"},{"type":"text","text":" class stores its current value in a variable property called "},{"code":"count","type":"codeVoice"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"Counter"},{"type":"text","text":" class also defines a method called "},{"type":"codeVoice","code":"increment"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"which increments the "},{"type":"codeVoice","code":"count"},{"type":"text","text":" property every time the method is called."}]},{"inlineContent":[{"type":"text","text":"The "},{"code":"increment()","type":"codeVoice"},{"text":" method first tries to retrieve an increment amount","type":"text"},{"type":"text","text":" "},{"text":"by looking for an implementation of the ","type":"text"},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":" method on its data source."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"increment()"},{"type":"text","text":" method uses optional chaining to try to call "},{"type":"codeVoice","code":"increment(forCount:)"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and passes the current "},{"type":"codeVoice","code":"count"},{"type":"text","text":" value as the method’s single argument."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that "},{"type":"emphasis","inlineContent":[{"text":"two","type":"text"}]},{"text":" levels of optional chaining are at play here.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"First, it’s possible that "},{"type":"codeVoice","code":"dataSource"},{"type":"text","text":" may be "},{"code":"nil","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"and so ","type":"text"},{"code":"dataSource","type":"codeVoice"},{"text":" has a question mark after its name to indicate that","type":"text"},{"type":"text","text":" "},{"code":"increment(forCount:)","type":"codeVoice"},{"text":" should be called only if ","type":"text"},{"code":"dataSource","type":"codeVoice"},{"text":" isn’t ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Second, even if "},{"code":"dataSource","type":"codeVoice"},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"does"}],"type":"emphasis"},{"type":"text","text":" exist,"},{"text":" ","type":"text"},{"type":"text","text":"there’s no guarantee that it implements "},{"code":"increment(forCount:)","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"because it’s an optional requirement."},{"text":" ","type":"text"},{"type":"text","text":"Here, the possibility that "},{"type":"codeVoice","code":"increment(forCount:)"},{"text":" might not be implemented","type":"text"},{"text":" ","type":"text"},{"text":"is also handled by optional chaining.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The call to "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":" happens"},{"text":" ","type":"text"},{"text":"only if ","type":"text"},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":" exists —"},{"type":"text","text":" "},{"type":"text","text":"that is, if it isn’t "},{"code":"nil","type":"codeVoice"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"This is why "},{"type":"codeVoice","code":"increment(forCount:)"},{"text":" is also written with a question mark after its name.","type":"text"}]},{"inlineContent":[{"text":"Because the call to ","type":"text"},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":" can fail for either of these two reasons,"},{"text":" ","type":"text"},{"text":"the call returns an ","type":"text"},{"inlineContent":[{"type":"text","text":"optional"}],"type":"emphasis"},{"text":" ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":" value."},{"text":" ","type":"text"},{"text":"This is true even though ","type":"text"},{"code":"increment(forCount:)","type":"codeVoice"},{"type":"text","text":" is defined as returning"},{"type":"text","text":" "},{"type":"text","text":"a non-optional "},{"type":"codeVoice","code":"Int"},{"text":" value in the definition of ","type":"text"},{"type":"codeVoice","code":"CounterDataSource"},{"type":"text","text":"."},{"text":" ","type":"text"},{"text":"Even though there are two optional chaining operations,","type":"text"},{"text":" ","type":"text"},{"text":"one after another,","type":"text"},{"type":"text","text":" "},{"text":"the result is still wrapped in a single optional.","type":"text"},{"text":" ","type":"text"},{"text":"For more information about using multiple optional chaining operations,","type":"text"},{"type":"text","text":" "},{"text":"see ","type":"text"},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OptionalChaining#Linking-Multiple-Levels-of-Chaining","isActive":true,"type":"reference"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"After calling "},{"code":"increment(forCount:)","type":"codeVoice"},{"type":"text","text":", the optional "},{"code":"Int","type":"codeVoice"},{"text":" that it returns","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"is unwrapped into a constant called "},{"code":"amount","type":"codeVoice"},{"type":"text","text":", using optional binding."},{"text":" ","type":"text"},{"text":"If the optional ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":" does contain a value —"},{"text":" ","type":"text"},{"type":"text","text":"that is, if the delegate and method both exist,"},{"type":"text","text":" "},{"type":"text","text":"and the method returned a value —"},{"type":"text","text":" "},{"type":"text","text":"the unwrapped "},{"code":"amount","type":"codeVoice"},{"type":"text","text":" is added onto the stored "},{"code":"count","type":"codeVoice"},{"text":" property,","type":"text"},{"text":" ","type":"text"},{"text":"and incrementation is complete.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If it’s "},{"type":"emphasis","inlineContent":[{"text":"not","type":"text"}]},{"text":" possible to retrieve a value from the ","type":"text"},{"code":"increment(forCount:)","type":"codeVoice"},{"text":" method —","type":"text"},{"type":"text","text":" "},{"type":"text","text":"either because "},{"type":"codeVoice","code":"dataSource"},{"type":"text","text":" is nil,"},{"text":" ","type":"text"},{"type":"text","text":"or because the data source doesn’t implement "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":" —"},{"type":"text","text":" "},{"text":"then the ","type":"text"},{"code":"increment()","type":"codeVoice"},{"type":"text","text":" method tries to retrieve a value"},{"text":" ","type":"text"},{"text":"from the data source’s ","type":"text"},{"type":"codeVoice","code":"fixedIncrement"},{"type":"text","text":" property instead."},{"text":" ","type":"text"},{"type":"text","text":"The "},{"code":"fixedIncrement","type":"codeVoice"},{"type":"text","text":" property is also an optional requirement,"},{"text":" ","type":"text"},{"text":"so its value is an optional ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":" value,","type":"text"},{"text":" ","type":"text"},{"text":"even though ","type":"text"},{"code":"fixedIncrement","type":"codeVoice"},{"text":" is defined as a non-optional ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":" property","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"as part of the "},{"type":"codeVoice","code":"CounterDataSource"},{"text":" protocol definition.","type":"text"}]},{"inlineContent":[{"text":"Here’s a simple ","type":"text"},{"type":"codeVoice","code":"CounterDataSource"},{"text":" implementation where the data source","type":"text"},{"type":"text","text":" "},{"type":"text","text":"returns a constant value of "},{"code":"3","type":"codeVoice"},{"text":" every time it’s queried.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"It does this by implementing the optional "},{"code":"fixedIncrement","type":"codeVoice"},{"type":"text","text":" property requirement:"}],"type":"paragraph"},{"syntax":"swift","code":["class ThreeSource: NSObject, CounterDataSource {","    let fixedIncrement = 3","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"You can use an instance of "},{"code":"ThreeSource","type":"codeVoice"},{"text":" as the data source for a new ","type":"text"},{"code":"Counter","type":"codeVoice"},{"text":" instance:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["var counter = Counter()","counter.dataSource = ThreeSource()","for _ in 1...4 {","    counter.increment()","    print(counter.count)","}","\/\/ 3","\/\/ 6","\/\/ 9","\/\/ 12"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The code above creates a new "},{"type":"codeVoice","code":"Counter"},{"text":" instance;","type":"text"},{"type":"text","text":" "},{"text":"sets its data source to be a new ","type":"text"},{"code":"ThreeSource","type":"codeVoice"},{"type":"text","text":" instance;"},{"text":" ","type":"text"},{"type":"text","text":"and calls the counter’s "},{"code":"increment()","type":"codeVoice"},{"type":"text","text":" method four times."},{"text":" ","type":"text"},{"text":"As expected, the counter’s ","type":"text"},{"type":"codeVoice","code":"count"},{"text":" property increases by three","type":"text"},{"type":"text","text":" "},{"text":"each time ","type":"text"},{"type":"codeVoice","code":"increment()"},{"type":"text","text":" is called."}]},{"type":"paragraph","inlineContent":[{"text":"Here’s a more complex data source called ","type":"text"},{"type":"codeVoice","code":"TowardsZeroSource"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"which makes a "},{"code":"Counter","type":"codeVoice"},{"type":"text","text":" instance count up or down towards zero"},{"text":" ","type":"text"},{"text":"from its current ","type":"text"},{"code":"count","type":"codeVoice"},{"text":" value:","type":"text"}]},{"syntax":"swift","code":["class TowardsZeroSource: NSObject, CounterDataSource {","    func increment(forCount count: Int) -> Int {","        if count == 0 {","            return 0","        } else if count < 0 {","            return 1","        } else {","            return -1","        }","    }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"TowardsZeroSource","type":"codeVoice"},{"type":"text","text":" class implements"},{"type":"text","text":" "},{"type":"text","text":"the optional "},{"code":"increment(forCount:)","type":"codeVoice"},{"type":"text","text":" method from the "},{"code":"CounterDataSource","type":"codeVoice"},{"type":"text","text":" protocol"},{"type":"text","text":" "},{"text":"and uses the ","type":"text"},{"type":"codeVoice","code":"count"},{"text":" argument value to work out which direction to count in.","type":"text"},{"type":"text","text":" "},{"text":"If ","type":"text"},{"type":"codeVoice","code":"count"},{"text":" is already zero, the method returns ","type":"text"},{"type":"codeVoice","code":"0"},{"text":" ","type":"text"},{"text":"to indicate that no further counting should take place.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"You can use an instance of ","type":"text"},{"code":"TowardsZeroSource","type":"codeVoice"},{"text":" with the existing ","type":"text"},{"type":"codeVoice","code":"Counter"},{"text":" instance","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"to count from "},{"type":"codeVoice","code":"-4"},{"text":" to zero.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Once the counter reaches zero, no more counting takes place:"}]},{"code":["counter.count = -4","counter.dataSource = TowardsZeroSource()","for _ in 1...5 {","    counter.increment()","    print(counter.count)","}","\/\/ -3","\/\/ -2","\/\/ -1","\/\/ 0","\/\/ 0"],"syntax":"swift","type":"codeListing"},{"level":2,"type":"heading","anchor":"Protocol-Extensions","text":"Protocol Extensions"},{"inlineContent":[{"type":"text","text":"Protocols can be extended to provide method,"},{"type":"text","text":" "},{"type":"text","text":"initializer, subscript, and computed property implementations"},{"text":" ","type":"text"},{"text":"to conforming types.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This allows you to define behavior on protocols themselves,"},{"type":"text","text":" "},{"type":"text","text":"rather than in each type’s individual conformance or in a global function."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, the "},{"type":"codeVoice","code":"RandomNumberGenerator"},{"type":"text","text":" protocol can be extended"},{"type":"text","text":" "},{"type":"text","text":"to provide a "},{"code":"randomBool()","type":"codeVoice"},{"text":" method,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"which uses the result of the required "},{"code":"random()","type":"codeVoice"},{"text":" method","type":"text"},{"type":"text","text":" "},{"text":"to return a random ","type":"text"},{"type":"codeVoice","code":"Bool"},{"text":" value:","type":"text"}]},{"syntax":"swift","code":["extension RandomNumberGenerator {","    func randomBool() -> Bool {","        return random() > 0.5","    }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"By creating an extension on the protocol,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"all conforming types automatically gain this method implementation"},{"text":" ","type":"text"},{"text":"without any additional modification.","type":"text"}]},{"code":["let generator = LinearCongruentialGenerator()","print(\"Here's a random number: \\(generator.random())\")","\/\/ Prints \"Here's a random number: 0.3746499199817101\"","print(\"And here's a random Boolean: \\(generator.randomBool())\")","\/\/ Prints \"And here's a random Boolean: true\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Protocol extensions can add implementations to conforming types"},{"type":"text","text":" "},{"text":"but can’t make a protocol extend or inherit from another protocol.","type":"text"},{"type":"text","text":" "},{"text":"Protocol inheritance is always specified in the protocol declaration itself.","type":"text"}],"type":"paragraph"},{"type":"heading","anchor":"Providing-Default-Implementations","text":"Providing Default Implementations","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use protocol extensions to provide a default implementation"},{"text":" ","type":"text"},{"type":"text","text":"to any method or computed property requirement of that protocol."},{"type":"text","text":" "},{"type":"text","text":"If a conforming type provides its own implementation of a required method or property,"},{"type":"text","text":" "},{"text":"that implementation will be used instead of the one provided by the extension.","type":"text"}]},{"style":"note","name":"Note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Protocol requirements with default implementations provided by extensions"},{"type":"text","text":" "},{"text":"are distinct from optional protocol requirements.","type":"text"},{"type":"text","text":" "},{"text":"Although conforming types don’t have to provide their own implementation of either,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"requirements with default implementations can be called without optional chaining."}]}],"type":"aside"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, the "},{"type":"codeVoice","code":"PrettyTextRepresentable"},{"text":" protocol,","type":"text"},{"type":"text","text":" "},{"text":"which inherits the ","type":"text"},{"code":"TextRepresentable","type":"codeVoice"},{"type":"text","text":" protocol"},{"text":" ","type":"text"},{"text":"can provide a default implementation of its required ","type":"text"},{"type":"codeVoice","code":"prettyTextualDescription"},{"type":"text","text":" property"},{"text":" ","type":"text"},{"type":"text","text":"to simply return the result of accessing the "},{"type":"codeVoice","code":"textualDescription"},{"type":"text","text":" property:"}]},{"code":["extension PrettyTextRepresentable  {","    var prettyTextualDescription: String {","        return textualDescription","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"heading","level":3,"anchor":"Adding-Constraints-to-Protocol-Extensions","text":"Adding Constraints to Protocol Extensions"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When you define a protocol extension,"},{"type":"text","text":" "},{"text":"you can specify constraints that conforming types","type":"text"},{"text":" ","type":"text"},{"text":"must satisfy before the methods and properties of the extension are available.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"You write these constraints after the name of the protocol you’re extending"},{"type":"text","text":" "},{"type":"text","text":"by writing a generic "},{"code":"where","type":"codeVoice"},{"text":" clause.","type":"text"},{"text":" ","type":"text"},{"text":"For more about generic ","type":"text"},{"type":"codeVoice","code":"where"},{"text":" clauses, see ","type":"text"},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics#Generic-Where-Clauses","isActive":true},{"text":".","type":"text"}]},{"inlineContent":[{"text":"For example,","type":"text"},{"type":"text","text":" "},{"text":"you can define an extension to the ","type":"text"},{"type":"codeVoice","code":"Collection"},{"text":" protocol","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"that applies to any collection whose elements conform"},{"text":" ","type":"text"},{"type":"text","text":"to the "},{"code":"Equatable","type":"codeVoice"},{"text":" protocol.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"By constraining a collection’s elements to the "},{"type":"codeVoice","code":"Equatable"},{"text":" protocol,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"a part of the Swift standard library,"},{"text":" ","type":"text"},{"text":"you can use the ","type":"text"},{"code":"==","type":"codeVoice"},{"type":"text","text":" and "},{"code":"!=","type":"codeVoice"},{"text":" operators to check for equality and inequality between two elements.","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["extension Collection where Element: Equatable {","    func allEqual() -> Bool {","        for element in self {","            if element != self.first {","                return false","            }","        }","        return true","    }","}"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"The "},{"code":"allEqual()","type":"codeVoice"},{"text":" method returns ","type":"text"},{"type":"codeVoice","code":"true"},{"text":" ","type":"text"},{"text":"only if all the elements in the collection are equal.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Consider two arrays of integers,"},{"text":" ","type":"text"},{"type":"text","text":"one where all the elements are the same,"},{"text":" ","type":"text"},{"type":"text","text":"and one where they aren’t:"}],"type":"paragraph"},{"syntax":"swift","code":["let equalNumbers = [100, 100, 100, 100, 100]","let differentNumbers = [100, 100, 200, 100, 200]"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because arrays conform to "},{"code":"Collection","type":"codeVoice"},{"type":"text","text":" "},{"text":"and integers conform to ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"equalNumbers"},{"text":" and ","type":"text"},{"code":"differentNumbers","type":"codeVoice"},{"text":" can use the ","type":"text"},{"code":"allEqual()","type":"codeVoice"},{"type":"text","text":" method:"}]},{"code":["print(equalNumbers.allEqual())","\/\/ Prints \"true\"","print(differentNumbers.allEqual())","\/\/ Prints \"false\""],"syntax":"swift","type":"codeListing"},{"style":"note","name":"Note","content":[{"inlineContent":[{"type":"text","text":"If a conforming type satisfies the requirements for multiple constrained extensions"},{"type":"text","text":" "},{"text":"that provide implementations for the same method or property,","type":"text"},{"text":" ","type":"text"},{"text":"Swift uses the implementation corresponding to the most specialized constraints.","type":"text"}],"type":"paragraph"}],"type":"aside"}],"kind":"content"}],"kind":"article","identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols","interfaceLanguage":"swift"},"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Generics":{"title":"Generics","role":"article","abstract":[{"text":"Write code that works for multiple types and specify requirements for those types.","type":"text"}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","url":"\/documentation\/the-swift-programming-language\/generics","kind":"article","type":"topic"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Inheritance#Preventing-Overrides":{"url":"\/documentation\/the-swift-programming-language\/inheritance#Preventing-Overrides","title":"Preventing Overrides","type":"topic","abstract":[],"kind":"section","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Inheritance#Preventing-Overrides"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/OptionalChaining#Linking-Multiple-Levels-of-Chaining":{"title":"Linking Multiple Levels of Chaining","abstract":[],"kind":"section","url":"\/documentation\/the-swift-programming-language\/optionalchaining#Linking-Multiple-Levels-of-Chaining","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OptionalChaining#Linking-Multiple-Levels-of-Chaining"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/OptionalChaining":{"type":"topic","kind":"article","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OptionalChaining","role":"article","url":"\/documentation\/the-swift-programming-language\/optionalchaining","abstract":[{"type":"text","text":"Access members of an optional value without unwrapping."}],"title":"Optional Chaining"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AutomaticReferenceCounting#Strong-Reference-Cycles-Between-Class-Instances":{"url":"\/documentation\/the-swift-programming-language\/automaticreferencecounting#Strong-Reference-Cycles-Between-Class-Instances","kind":"section","title":"Strong Reference Cycles Between Class Instances","type":"topic","abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting#Strong-Reference-Cycles-Between-Class-Instances"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Initialization#Failable-Initializers":{"url":"\/documentation\/the-swift-programming-language\/initialization#Failable-Initializers","title":"Failable Initializers","type":"topic","abstract":[],"kind":"section","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization#Failable-Initializers"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Generics#Generic-Where-Clauses":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics#Generic-Where-Clauses","kind":"section","type":"topic","url":"\/documentation\/the-swift-programming-language\/generics#Generic-Where-Clauses","abstract":[],"title":"Generic Where Clauses"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ClassesAndStructures#Structures-and-Enumerations-Are-Value-Types":{"type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ClassesAndStructures#Structures-and-Enumerations-Are-Value-Types","url":"\/documentation\/the-swift-programming-language\/classesandstructures#Structures-and-Enumerations-Are-Value-Types","kind":"section","abstract":[],"title":"Structures and Enumerations Are Value Types"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Protocols#Class-Only-Protocols":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Class-Only-Protocols","url":"\/documentation\/the-swift-programming-language\/protocols#Class-Only-Protocols","abstract":[],"kind":"section","title":"Class-Only Protocols","type":"topic"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Methods#Modifying-Value-Types-from-Within-Instance-Methods":{"title":"Modifying Value Types from Within Instance Methods","abstract":[],"kind":"section","url":"\/documentation\/the-swift-programming-language\/methods#Modifying-Value-Types-from-Within-Instance-Methods","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Methods#Modifying-Value-Types-from-Within-Instance-Methods"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/OpaqueTypes":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes","type":"topic","kind":"article","abstract":[{"type":"text","text":"Hide implementation details about a value’s type."}],"title":"Opaque and Boxed Types","role":"article","url":"\/documentation\/the-swift-programming-language\/opaquetypes"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"abstract":[],"role":"collection","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language","kind":"article","type":"topic","title":"The Swift Programming Language (5.9.2)","url":"\/documentation\/the-swift-programming-language"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Protocols#Protocols-as-Types":{"url":"\/documentation\/the-swift-programming-language\/protocols#Protocols-as-Types","title":"Protocols as Types","type":"topic","abstract":[],"kind":"section","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Protocols-as-Types"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ControlFlow":{"url":"\/documentation\/the-swift-programming-language\/controlflow","abstract":[{"text":"Structure code with branches, loops, and early exits.","type":"text"}],"title":"Control Flow","type":"topic","role":"article","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow","kind":"article"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Extensions":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Extensions","role":"article","title":"Extensions","kind":"article","abstract":[{"type":"text","text":"Add functionality to an existing type."}],"type":"topic","url":"\/documentation\/the-swift-programming-language\/extensions"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ControlFlow#Break":{"kind":"section","type":"topic","abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow#Break","title":"Break","url":"\/documentation\/the-swift-programming-language\/controlflow#Break"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Initialization#Required-Initializers":{"url":"\/documentation\/the-swift-programming-language\/initialization#Required-Initializers","title":"Required Initializers","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization#Required-Initializers","abstract":[]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TypeCasting":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting","role":"article","title":"Type Casting","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language\/typecasting","abstract":[{"text":"Determine a value’s runtime type and give it more specific type information.","type":"text"}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ClassesAndStructures#Classes-Are-Reference-Types":{"title":"Classes Are Reference Types","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ClassesAndStructures#Classes-Are-Reference-Types","url":"\/documentation\/the-swift-programming-language\/classesandstructures#Classes-Are-Reference-Types","kind":"section","abstract":[]}}}