{"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes"},"sections":[],"kind":"article","abstract":[{"text":"Hide implementation details about a value’s type.","type":"text"}],"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"schemaVersion":{"major":0,"minor":3,"patch":0},"metadata":{"title":"Opaque and Boxed Types"},"primaryContentSections":[{"kind":"content","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift provides two ways to hide details about a value’s type:"},{"text":" ","type":"text"},{"type":"text","text":"opaque types and boxed protocol types."},{"text":" ","type":"text"},{"text":"Hiding type information","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"is useful at boundaries between"},{"type":"text","text":" "},{"type":"text","text":"a module and code that calls into the module,"},{"text":" ","type":"text"},{"text":"because the underlying type of the return value can remain private.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"A function or method that returns an opaque type","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"hides its return value’s type information."},{"text":" ","type":"text"},{"text":"Instead of providing a concrete type as the function’s return type,","type":"text"},{"text":" ","type":"text"},{"text":"the return value is described in terms of the protocols it supports.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Opaque types preserve type identity —"},{"text":" ","type":"text"},{"type":"text","text":"the compiler has access to the type information,"},{"text":" ","type":"text"},{"text":"but clients of the module don’t.","type":"text"}]},{"inlineContent":[{"type":"text","text":"A boxed protocol type can store an instance of any type"},{"type":"text","text":" "},{"type":"text","text":"that conforms to the given protocol."},{"type":"text","text":" "},{"type":"text","text":"Boxed protocol types don’t preserve type identity —"},{"text":" ","type":"text"},{"type":"text","text":"the value’s specific type isn’t known until runtime,"},{"type":"text","text":" "},{"text":"and it can change over time as different values are stored.","type":"text"}],"type":"paragraph"},{"level":2,"anchor":"The-Problem-That-Opaque-Types-Solve","type":"heading","text":"The Problem That Opaque Types Solve"},{"inlineContent":[{"type":"text","text":"For example,"},{"text":" ","type":"text"},{"type":"text","text":"suppose you’re writing a module that draws ASCII art shapes."},{"type":"text","text":" "},{"type":"text","text":"The basic characteristic of an ASCII art shape"},{"text":" ","type":"text"},{"text":"is a ","type":"text"},{"code":"draw()","type":"codeVoice"},{"text":" function that returns the string representation of that shape,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"which you can use as the requirement for the "},{"code":"Shape","type":"codeVoice"},{"text":" protocol:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["protocol Shape {","    func draw() -> String","}","","struct Triangle: Shape {","    var size: Int","    func draw() -> String {","       var result: [String] = []","       for length in 1...size {","           result.append(String(repeating: \"*\", count: length))","       }","       return result.joined(separator: \"\\n\")","    }","}","let smallTriangle = Triangle(size: 3)","print(smallTriangle.draw())","\/\/ *","\/\/ **","\/\/ ***"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"You could use generics to implement operations like flipping a shape vertically,","type":"text"},{"text":" ","type":"text"},{"text":"as shown in the code below.","type":"text"},{"text":" ","type":"text"},{"text":"However, there’s an important limitation to this approach:","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The flipped result exposes the exact generic types"},{"type":"text","text":" "},{"type":"text","text":"that were used to create it."}]},{"syntax":"swift","type":"codeListing","code":["struct FlippedShape<T: Shape>: Shape {","    var shape: T","    func draw() -> String {","        let lines = shape.draw().split(separator: \"\\n\")","        return lines.reversed().joined(separator: \"\\n\")","    }","}","let flippedTriangle = FlippedShape(shape: smallTriangle)","print(flippedTriangle.draw())","\/\/ ***","\/\/ **","\/\/ *"]},{"inlineContent":[{"type":"text","text":"This approach to defining a "},{"type":"codeVoice","code":"JoinedShape<T: Shape, U: Shape>"},{"text":" structure","type":"text"},{"type":"text","text":" "},{"text":"that joins two shapes together vertically, like the code below shows,","type":"text"},{"type":"text","text":" "},{"text":"results in types like ","type":"text"},{"code":"JoinedShape<FlippedShape<Triangle>, Triangle>","type":"codeVoice"},{"text":" ","type":"text"},{"text":"from joining a flipped triangle with another triangle.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct JoinedShape<T: Shape, U: Shape>: Shape {","    var top: T","    var bottom: U","    func draw() -> String {","       return top.draw() + \"\\n\" + bottom.draw()","    }","}","let joinedTriangles = JoinedShape(top: smallTriangle, bottom: flippedTriangle)","print(joinedTriangles.draw())","\/\/ *","\/\/ **","\/\/ ***","\/\/ ***","\/\/ **","\/\/ *"]},{"type":"paragraph","inlineContent":[{"text":"Exposing detailed information about the creation of a shape","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"allows types that aren’t meant to be"},{"text":" ","type":"text"},{"text":"part of the ASCII art module’s public interface","type":"text"},{"type":"text","text":" "},{"text":"to leak out because of the need to state the full return type.","type":"text"},{"type":"text","text":" "},{"text":"The code inside the module","type":"text"},{"type":"text","text":" "},{"type":"text","text":"could build up the same shape in a variety of ways,"},{"text":" ","type":"text"},{"text":"and other code outside the module","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"that uses the shape shouldn’t have to account for"},{"type":"text","text":" "},{"type":"text","text":"the implementation details about the list of transformations."},{"type":"text","text":" "},{"type":"text","text":"Wrapper types like "},{"type":"codeVoice","code":"JoinedShape"},{"type":"text","text":" and "},{"type":"codeVoice","code":"FlippedShape"},{"text":" ","type":"text"},{"text":"don’t matter to the module’s users,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and they shouldn’t be visible."},{"text":" ","type":"text"},{"type":"text","text":"The module’s public interface"},{"text":" ","type":"text"},{"type":"text","text":"consists of operations like joining and flipping a shape,"},{"type":"text","text":" "},{"type":"text","text":"and those operations return another "},{"code":"Shape","type":"codeVoice"},{"type":"text","text":" value."}]},{"text":"Returning an Opaque Type","anchor":"Returning-an-Opaque-Type","type":"heading","level":2},{"inlineContent":[{"text":"You can think of an opaque type like being the reverse of a generic type.","type":"text"},{"text":" ","type":"text"},{"text":"Generic types let the code that calls a function","type":"text"},{"type":"text","text":" "},{"type":"text","text":"pick the type for that function’s parameters and return value"},{"type":"text","text":" "},{"text":"in a way that’s abstracted away from the function implementation.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For example, the function in the following code"},{"text":" ","type":"text"},{"type":"text","text":"returns a type that depends on its caller:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["func max<T>(_ x: T, _ y: T) -> T where T: Comparable { ... }"]},{"inlineContent":[{"type":"text","text":"The code that calls "},{"type":"codeVoice","code":"max(_:_:)"},{"text":" chooses the values for ","type":"text"},{"type":"codeVoice","code":"x"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"y"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and the type of those values determines the concrete type of "},{"type":"codeVoice","code":"T"},{"text":".","type":"text"},{"type":"text","text":" "},{"text":"The calling code can use any type","type":"text"},{"type":"text","text":" "},{"text":"that conforms to the ","type":"text"},{"type":"codeVoice","code":"Comparable"},{"type":"text","text":" protocol."},{"type":"text","text":" "},{"type":"text","text":"The code inside the function is written in a general way"},{"text":" ","type":"text"},{"type":"text","text":"so it can handle whatever type the caller provides."},{"text":" ","type":"text"},{"type":"text","text":"The implementation of "},{"code":"max(_:_:)","type":"codeVoice"},{"type":"text","text":" uses only functionality"},{"type":"text","text":" "},{"type":"text","text":"that all "},{"code":"Comparable","type":"codeVoice"},{"text":" types share.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Those roles are reversed for a function with an opaque return type."},{"text":" ","type":"text"},{"type":"text","text":"An opaque type lets the function implementation"},{"text":" ","type":"text"},{"type":"text","text":"pick the type for the value it returns"},{"type":"text","text":" "},{"text":"in a way that’s abstracted away from the code that calls the function.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For example, the function in the following example returns a trapezoid"},{"type":"text","text":" "},{"type":"text","text":"without exposing the underlying type of that shape."}]},{"type":"codeListing","syntax":"swift","code":["struct Square: Shape {","    var size: Int","    func draw() -> String {","        let line = String(repeating: \"*\", count: size)","        let result = Array<String>(repeating: line, count: size)","        return result.joined(separator: \"\\n\")","    }","}","","func makeTrapezoid() -> some Shape {","    let top = Triangle(size: 2)","    let middle = Square(size: 2)","    let bottom = FlippedShape(shape: top)","    let trapezoid = JoinedShape(","        top: top,","        bottom: JoinedShape(top: middle, bottom: bottom)","    )","    return trapezoid","}","let trapezoid = makeTrapezoid()","print(trapezoid.draw())","\/\/ *","\/\/ **","\/\/ **","\/\/ **","\/\/ **","\/\/ *"]},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"makeTrapezoid()"},{"text":" function in this example","type":"text"},{"text":" ","type":"text"},{"text":"declares its return type as ","type":"text"},{"type":"codeVoice","code":"some Shape"},{"type":"text","text":";"},{"type":"text","text":" "},{"type":"text","text":"as a result, the function"},{"type":"text","text":" "},{"type":"text","text":"returns a value of some given type that conforms to the "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" protocol,"},{"type":"text","text":" "},{"text":"without specifying any particular concrete type.","type":"text"},{"text":" ","type":"text"},{"text":"Writing ","type":"text"},{"code":"makeTrapezoid()","type":"codeVoice"},{"type":"text","text":" this way lets it express"},{"text":" ","type":"text"},{"text":"the fundamental aspect of its public interface —","type":"text"},{"text":" ","type":"text"},{"text":"the value it returns is a shape —","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"without making the specific types that the shape is made from"},{"type":"text","text":" "},{"text":"a part of its public interface.","type":"text"},{"type":"text","text":" "},{"text":"This implementation uses two triangles and a square,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"but the function could be rewritten to draw a trapezoid"},{"text":" ","type":"text"},{"type":"text","text":"in a variety of other ways"},{"type":"text","text":" "},{"type":"text","text":"without changing its return type."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"This example highlights the way that an opaque return type","type":"text"},{"text":" ","type":"text"},{"text":"is like the reverse of a generic type.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The code inside "},{"code":"makeTrapezoid()","type":"codeVoice"},{"text":" can return any type it needs to,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"as long as that type conforms to the "},{"code":"Shape","type":"codeVoice"},{"type":"text","text":" protocol,"},{"type":"text","text":" "},{"text":"like the calling code does for a generic function.","type":"text"},{"type":"text","text":" "},{"text":"The code that calls the function needs to be written in a general way,","type":"text"},{"type":"text","text":" "},{"text":"like the implementation of a generic function,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"so that it can work with any "},{"code":"Shape","type":"codeVoice"},{"type":"text","text":" value"},{"type":"text","text":" "},{"text":"that’s returned by ","type":"text"},{"type":"codeVoice","code":"makeTrapezoid()"},{"type":"text","text":"."}]},{"inlineContent":[{"type":"text","text":"You can also combine opaque return types with generics."},{"type":"text","text":" "},{"type":"text","text":"The functions in the following code both return a value"},{"type":"text","text":" "},{"type":"text","text":"of some type that conforms to the "},{"type":"codeVoice","code":"Shape"},{"text":" protocol.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["func flip<T: Shape>(_ shape: T) -> some Shape {","    return FlippedShape(shape: shape)","}","func join<T: Shape, U: Shape>(_ top: T, _ bottom: U) -> some Shape {","    JoinedShape(top: top, bottom: bottom)","}","","let opaqueJoinedTriangles = join(smallTriangle, flip(smallTriangle))","print(opaqueJoinedTriangles.draw())","\/\/ *","\/\/ **","\/\/ ***","\/\/ ***","\/\/ **","\/\/ *"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The value of "},{"type":"codeVoice","code":"opaqueJoinedTriangles"},{"type":"text","text":" in this example"},{"text":" ","type":"text"},{"type":"text","text":"is the same as "},{"code":"joinedTriangles","type":"codeVoice"},{"type":"text","text":" in the generics example"},{"type":"text","text":" "},{"type":"text","text":"in the "},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes#The-Problem-That-Opaque-Types-Solve","isActive":true,"type":"reference"},{"type":"text","text":" section earlier in this chapter."},{"type":"text","text":" "},{"text":"However, unlike the value in that example,","type":"text"},{"type":"text","text":" "},{"code":"flip(_:)","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"join(_:_:)","type":"codeVoice"},{"type":"text","text":" wrap the underlying types"},{"text":" ","type":"text"},{"text":"that the generic shape operations return","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"in an opaque return type,"},{"text":" ","type":"text"},{"type":"text","text":"which prevents those types from being visible."},{"text":" ","type":"text"},{"text":"Both functions are generic because the types they rely on are generic,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and the type parameters to the function"},{"type":"text","text":" "},{"text":"pass along the type information needed by ","type":"text"},{"code":"FlippedShape","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"JoinedShape"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"If a function with an opaque return type","type":"text"},{"type":"text","text":" "},{"text":"returns from multiple places,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"all of the possible return values must have the same type."},{"type":"text","text":" "},{"type":"text","text":"For a generic function,"},{"text":" ","type":"text"},{"type":"text","text":"that return type can use the function’s generic type parameters,"},{"type":"text","text":" "},{"text":"but it must still be a single type.","type":"text"},{"type":"text","text":" "},{"text":"For example,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"here’s an "},{"inlineContent":[{"text":"invalid","type":"text"}],"type":"emphasis"},{"type":"text","text":" version of the shape-flipping function"},{"type":"text","text":" "},{"type":"text","text":"that includes a special case for squares:"}]},{"code":["func invalidFlip<T: Shape>(_ shape: T) -> some Shape {","    if shape is Square {","        return shape \/\/ Error: return types don't match","    }","    return FlippedShape(shape: shape) \/\/ Error: return types don't match","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"If you call this function with a "},{"type":"codeVoice","code":"Square"},{"text":", it returns a ","type":"text"},{"code":"Square","type":"codeVoice"},{"type":"text","text":";"},{"text":" ","type":"text"},{"type":"text","text":"otherwise, it returns a "},{"code":"FlippedShape","type":"codeVoice"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This violates the requirement to return values of only one type"},{"text":" ","type":"text"},{"type":"text","text":"and makes "},{"type":"codeVoice","code":"invalidFlip(_:)"},{"type":"text","text":" invalid code."},{"type":"text","text":" "},{"text":"One way to fix ","type":"text"},{"type":"codeVoice","code":"invalidFlip(_:)"},{"text":" is to move the special case for squares","type":"text"},{"type":"text","text":" "},{"type":"text","text":"into the implementation of "},{"type":"codeVoice","code":"FlippedShape"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"which lets this function always return a ","type":"text"},{"type":"codeVoice","code":"FlippedShape"},{"text":" value:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["struct FlippedShape<T: Shape>: Shape {","    var shape: T","    func draw() -> String {","        if shape is Square {","           return shape.draw()","        }","        let lines = shape.draw().split(separator: \"\\n\")","        return lines.reversed().joined(separator: \"\\n\")","    }","}"]},{"inlineContent":[{"text":"The requirement to always return a single type","type":"text"},{"type":"text","text":" "},{"type":"text","text":"doesn’t prevent you from using generics in an opaque return type."},{"type":"text","text":" "},{"type":"text","text":"Here’s an example of a function that incorporates its type parameter"},{"text":" ","type":"text"},{"text":"into the underlying type of the value it returns:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["func `repeat`<T: Shape>(shape: T, count: Int) -> some Collection {","    return Array<T>(repeating: shape, count: count)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this case,"},{"type":"text","text":" "},{"text":"the underlying type of the return value","type":"text"},{"type":"text","text":" "},{"type":"text","text":"varies depending on "},{"type":"codeVoice","code":"T"},{"type":"text","text":":"},{"type":"text","text":" "},{"type":"text","text":"Whatever shape is passed it,"},{"type":"text","text":" "},{"type":"codeVoice","code":"repeat(shape:count:)"},{"type":"text","text":" creates and returns an array of that shape."},{"type":"text","text":" "},{"type":"text","text":"Nevertheless,"},{"type":"text","text":" "},{"type":"text","text":"the return value always has the same underlying type of "},{"code":"[T]","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"so it follows the requirement that functions with opaque return types"},{"type":"text","text":" "},{"text":"must return values of only a single type.","type":"text"}]},{"anchor":"Boxed-Protocol-Types","text":"Boxed Protocol Types","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"text":"A boxed protocol type is also sometimes called an ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"existential type"}]},{"type":"text","text":","},{"type":"text","text":" "},{"text":"which comes from the phrase","type":"text"},{"type":"text","text":" "},{"type":"text","text":"“there exists a type "},{"inlineContent":[{"type":"text","text":"T"}],"type":"emphasis"},{"type":"text","text":" such that "},{"inlineContent":[{"type":"text","text":"T"}],"type":"emphasis"},{"type":"text","text":" conforms to the protocol”."},{"type":"text","text":" "},{"text":"To make a boxed protocol type,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"write "},{"code":"any","type":"codeVoice"},{"type":"text","text":" before the name of a protocol."},{"type":"text","text":" "},{"type":"text","text":"Here’s an example:"}]},{"syntax":"swift","type":"codeListing","code":["struct VerticalShapes: Shape {","    var shapes: [any Shape]","    func draw() -> String {","        return shapes.map { $0.draw() }.joined(separator: \"\\n\\n\")","    }","}","","let largeTriangle = Triangle(size: 5)","let largeSquare = Square(size: 5)","let vertical = VerticalShapes(shapes: [largeTriangle, largeSquare])","print(vertical.draw())"]},{"inlineContent":[{"type":"text","text":"In the example above,"},{"type":"text","text":" "},{"type":"codeVoice","code":"VerticalShapes"},{"text":" declares the type of ","type":"text"},{"type":"codeVoice","code":"shapes"},{"type":"text","text":" as "},{"code":"[any Shape]","type":"codeVoice"},{"text":" —","type":"text"},{"type":"text","text":" "},{"type":"text","text":"an array of boxed "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" elements."},{"type":"text","text":" "},{"type":"text","text":"Each element in the array can be a different type,"},{"text":" ","type":"text"},{"type":"text","text":"and each of those types must conform to the "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" protocol."},{"text":" ","type":"text"},{"type":"text","text":"To support this runtime flexibility,"},{"type":"text","text":" "},{"text":"Swift adds a level of indirection when necessary —","type":"text"},{"type":"text","text":" "},{"text":"this indirection is called a ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"box"}]},{"type":"text","text":","},{"type":"text","text":" "},{"text":"and it has a performance cost.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Within the ","type":"text"},{"type":"codeVoice","code":"VerticalShapes"},{"type":"text","text":" type,"},{"text":" ","type":"text"},{"type":"text","text":"the code can use methods, properties, and subscripts"},{"type":"text","text":" "},{"text":"that are required by the ","type":"text"},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" protocol."},{"text":" ","type":"text"},{"type":"text","text":"For example, the "},{"code":"draw()","type":"codeVoice"},{"type":"text","text":" method of "},{"type":"codeVoice","code":"VerticalShapes"},{"text":" ","type":"text"},{"type":"text","text":"calls the "},{"type":"codeVoice","code":"draw()"},{"type":"text","text":" method on each element of the array."},{"type":"text","text":" "},{"type":"text","text":"This method is available because "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" requires a "},{"type":"codeVoice","code":"draw()"},{"type":"text","text":" method."},{"type":"text","text":" "},{"type":"text","text":"In contrast,"},{"text":" ","type":"text"},{"type":"text","text":"trying to access the "},{"code":"size","type":"codeVoice"},{"text":" property of the triangle,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"or any other properties or methods that aren’t required by "},{"code":"Shape","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"produces an error.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Contrast the three types you could use for "},{"type":"codeVoice","code":"shapes"},{"type":"text","text":":"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Using generics,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"by writing "},{"type":"codeVoice","code":"struct VerticalShapes<S: Shape>"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"var shapes: [S]"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"makes an array whose elements are some specific shape type,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and where the identity of that specific type"},{"text":" ","type":"text"},{"text":"is visible to any code that interacts with the array.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Using an opaque type,"},{"type":"text","text":" "},{"text":"by writing ","type":"text"},{"code":"var shapes: [some Shape]","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"makes an array whose elements are some specific shape type,"},{"type":"text","text":" "},{"type":"text","text":"and where that specific type’s identity is hidden."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Using a boxed protocol type,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"by writing "},{"type":"codeVoice","code":"var shapes: [any Shape]"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"makes an array that can store elements of different types,"},{"type":"text","text":" "},{"text":"and where those types’ identities are hidden.","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this case,"},{"type":"text","text":" "},{"type":"text","text":"a boxed protocol type is the only approach"},{"text":" ","type":"text"},{"text":"that lets callers of ","type":"text"},{"code":"VerticalShapes","type":"codeVoice"},{"text":" mix different kinds of shapes together.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"You can use an ","type":"text"},{"type":"codeVoice","code":"as"},{"type":"text","text":" cast"},{"text":" ","type":"text"},{"type":"text","text":"when you know the underlying type of a boxed value."},{"type":"text","text":" "},{"text":"For example:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["if let downcastTriangle = vertical.shapes[0] as? Triangle {","    print(downcastTriangle.size)","}","\/\/ Prints \"5\""]},{"type":"paragraph","inlineContent":[{"text":"For more information, see ","type":"text"},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting#Downcasting","type":"reference","isActive":true},{"text":".","type":"text"}]},{"anchor":"Differences-Between-Opaque-Types-and-Boxed-Protocol-Types","type":"heading","level":2,"text":"Differences Between Opaque Types and Boxed Protocol Types"},{"inlineContent":[{"text":"Returning an opaque type looks very similar","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to using a boxed protocol type as the return type of a function,"},{"type":"text","text":" "},{"text":"but these two kinds of return type differ in","type":"text"},{"type":"text","text":" "},{"type":"text","text":"whether they preserve type identity."},{"text":" ","type":"text"},{"type":"text","text":"An opaque type refers to one specific type,"},{"text":" ","type":"text"},{"type":"text","text":"although the caller of the function isn’t able to see which type;"},{"type":"text","text":" "},{"type":"text","text":"a boxed protocol type can refer to any type that conforms to the protocol."},{"type":"text","text":" "},{"text":"Generally speaking,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"boxed protocol types give you more flexibility"},{"type":"text","text":" "},{"type":"text","text":"about the underlying types of the values they store,"},{"text":" ","type":"text"},{"text":"and opaque types let you make stronger guarantees","type":"text"},{"type":"text","text":" "},{"type":"text","text":"about those underlying types."}],"type":"paragraph"},{"inlineContent":[{"text":"For example,","type":"text"},{"text":" ","type":"text"},{"text":"here’s a version of ","type":"text"},{"code":"flip(_:)","type":"codeVoice"},{"type":"text","text":" "},{"text":"that uses a boxed protocol type as its return type","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"instead of an opaque return type:"}],"type":"paragraph"},{"code":["func protoFlip<T: Shape>(_ shape: T) -> Shape {","    return FlippedShape(shape: shape)","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"This version of ","type":"text"},{"type":"codeVoice","code":"protoFlip(_:)"},{"type":"text","text":" "},{"type":"text","text":"has the same body as "},{"type":"codeVoice","code":"flip(_:)"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and it always returns a value of the same type."},{"type":"text","text":" "},{"type":"text","text":"Unlike "},{"type":"codeVoice","code":"flip(_:)"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"the value that ","type":"text"},{"code":"protoFlip(_:)","type":"codeVoice"},{"type":"text","text":" returns isn’t required"},{"text":" ","type":"text"},{"type":"text","text":"to always have the same type —"},{"type":"text","text":" "},{"text":"it just has to conform to the ","type":"text"},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" protocol."},{"text":" ","type":"text"},{"type":"text","text":"Put another way,"},{"type":"text","text":" "},{"code":"protoFlip(_:)","type":"codeVoice"},{"type":"text","text":" makes a much looser API contract with its caller"},{"text":" ","type":"text"},{"type":"text","text":"than "},{"code":"flip(_:)","type":"codeVoice"},{"text":" makes.","type":"text"},{"type":"text","text":" "},{"text":"It reserves the flexibility to return values of multiple types:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["func protoFlip<T: Shape>(_ shape: T) -> Shape {","    if shape is Square {","        return shape","    }","","    return FlippedShape(shape: shape)","}"],"type":"codeListing"},{"inlineContent":[{"text":"The revised version of the code returns","type":"text"},{"type":"text","text":" "},{"type":"text","text":"an instance of "},{"code":"Square","type":"codeVoice"},{"type":"text","text":" or an instance of "},{"type":"codeVoice","code":"FlippedShape"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"depending on what shape is passed in.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Two flipped shapes returned by this function"},{"text":" ","type":"text"},{"text":"might have completely different types.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Other valid versions of this function could return values of different types"},{"text":" ","type":"text"},{"type":"text","text":"when flipping multiple instances of the same shape."},{"text":" ","type":"text"},{"text":"The less specific return type information from ","type":"text"},{"code":"protoFlip(_:)","type":"codeVoice"},{"text":" means that","type":"text"},{"text":" ","type":"text"},{"text":"many operations that depend on type information","type":"text"},{"text":" ","type":"text"},{"text":"aren’t available on the returned value.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For example, it’s not possible to write an "},{"code":"==","type":"codeVoice"},{"text":" operator","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"comparing results returned by this function."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let protoFlippedTriangle = protoFlip(smallTriangle)","let sameThing = protoFlip(smallTriangle)","protoFlippedTriangle == sameThing  \/\/ Error"]},{"type":"paragraph","inlineContent":[{"text":"The error on the last line of the example occurs for several reasons.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The immediate issue is that the "},{"code":"Shape","type":"codeVoice"},{"text":" doesn’t include an ","type":"text"},{"code":"==","type":"codeVoice"},{"type":"text","text":" operator"},{"text":" ","type":"text"},{"text":"as part of its protocol requirements.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"If you try adding one, the next issue you’ll encounter"},{"type":"text","text":" "},{"type":"text","text":"is that the "},{"type":"codeVoice","code":"=="},{"type":"text","text":" operator needs to know"},{"text":" ","type":"text"},{"text":"the types of its left-hand and right-hand arguments.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"This sort of operator usually takes arguments of type "},{"type":"codeVoice","code":"Self"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"matching whatever concrete type adopts the protocol,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"but adding a "},{"code":"Self","type":"codeVoice"},{"type":"text","text":" requirement to the protocol"},{"type":"text","text":" "},{"text":"doesn’t allow for the type erasure that happens","type":"text"},{"type":"text","text":" "},{"text":"when you use the protocol as a type.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Using a boxed protocol type as the return type for a function"},{"type":"text","text":" "},{"type":"text","text":"gives you the flexibility to return any type that conforms to the protocol."},{"text":" ","type":"text"},{"type":"text","text":"However, the cost of that flexibility"},{"type":"text","text":" "},{"type":"text","text":"is that some operations aren’t possible on the returned values."},{"type":"text","text":" "},{"text":"The example shows how the ","type":"text"},{"type":"codeVoice","code":"=="},{"type":"text","text":" operator isn’t available —"},{"type":"text","text":" "},{"type":"text","text":"it depends on specific type information"},{"type":"text","text":" "},{"text":"that isn’t preserved by using a boxed protocol type.","type":"text"}]},{"inlineContent":[{"text":"Another problem with this approach is that the shape transformations don’t nest.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The result of flipping a triangle is a value of type "},{"code":"Shape","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"and the ","type":"text"},{"type":"codeVoice","code":"protoFlip(_:)"},{"type":"text","text":" function takes an argument"},{"type":"text","text":" "},{"type":"text","text":"of some type that conforms to the "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" protocol."},{"text":" ","type":"text"},{"type":"text","text":"However, a value of a boxed protocol type doesn’t conform to that protocol;"},{"type":"text","text":" "},{"text":"the value returned by ","type":"text"},{"code":"protoFlip(_:)","type":"codeVoice"},{"type":"text","text":" doesn’t conform to "},{"code":"Shape","type":"codeVoice"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"This means code like "},{"code":"protoFlip(protoFlip(smallTriangle))","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"that applies multiple transformations is invalid"},{"type":"text","text":" "},{"type":"text","text":"because the flipped shape isn’t a valid argument to "},{"type":"codeVoice","code":"protoFlip(_:)"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"In contrast,","type":"text"},{"text":" ","type":"text"},{"text":"opaque types preserve the identity of the underlying type.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Swift can infer associated types,"},{"text":" ","type":"text"},{"text":"which lets you use an opaque return value","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"in places where a boxed protocol type can’t be used as a return value."},{"type":"text","text":" "},{"text":"For example,","type":"text"},{"text":" ","type":"text"},{"text":"here’s a version of the ","type":"text"},{"code":"Container","type":"codeVoice"},{"type":"text","text":" protocol from "},{"isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","type":"reference"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["protocol Container {","    associatedtype Item","    var count: Int { get }","    subscript(i: Int) -> Item { get }","}","extension Array: Container { }"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can’t use "},{"code":"Container","type":"codeVoice"},{"type":"text","text":" as the return type of a function"},{"type":"text","text":" "},{"type":"text","text":"because that protocol has an associated type."},{"text":" ","type":"text"},{"type":"text","text":"You also can’t use it as constraint in a generic return type"},{"type":"text","text":" "},{"type":"text","text":"because there isn’t enough information outside the function body"},{"type":"text","text":" "},{"type":"text","text":"to infer what the generic type needs to be."}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Error: Protocol with associated types can't be used as a return type.","func makeProtocolContainer<T>(item: T) -> Container {","    return [item]","}","","\/\/ Error: Not enough information to infer C.","func makeProtocolContainer<T, C: Container>(item: T) -> C {","    return [item]","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Using the opaque type "},{"code":"some Container","type":"codeVoice"},{"text":" as a return type","type":"text"},{"text":" ","type":"text"},{"text":"expresses the desired API contract — the function returns a container,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"but declines to specify the container’s type:"}]},{"type":"codeListing","syntax":"swift","code":["func makeOpaqueContainer<T>(item: T) -> some Container {","    return [item]","}","let opaqueContainer = makeOpaqueContainer(item: 12)","let twelve = opaqueContainer[0]","print(type(of: twelve))","\/\/ Prints \"Int\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The type of "},{"type":"codeVoice","code":"twelve"},{"type":"text","text":" is inferred to be "},{"type":"codeVoice","code":"Int"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"which illustrates the fact that type inference works with opaque types.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"In the implementation of "},{"type":"codeVoice","code":"makeOpaqueContainer(item:)"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the underlying type of the opaque container is "},{"type":"codeVoice","code":"[T]"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"In this case, ","type":"text"},{"type":"codeVoice","code":"T"},{"type":"text","text":" is "},{"type":"codeVoice","code":"Int"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"so the return value is an array of integers","type":"text"},{"text":" ","type":"text"},{"text":"and the ","type":"text"},{"code":"Item","type":"codeVoice"},{"text":" associated type is inferred to be ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"The subscript on "},{"type":"codeVoice","code":"Container"},{"text":" returns ","type":"text"},{"type":"codeVoice","code":"Item"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"which means that the type of ","type":"text"},{"type":"codeVoice","code":"twelve"},{"text":" is also inferred to be ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":".","type":"text"}]}]}],"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TypeCasting#Downcasting":{"abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting#Downcasting","url":"\/documentation\/the-swift-programming-language\/typecasting#Downcasting","type":"topic","title":"Downcasting","kind":"section"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Generics":{"type":"topic","abstract":[{"type":"text","text":"Write code that works for multiple types and specify requirements for those types."}],"title":"Generics","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","kind":"article","url":"\/documentation\/the-swift-programming-language\/generics","role":"article"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"kind":"article","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language","role":"collection","url":"\/documentation\/the-swift-programming-language","abstract":[],"type":"topic","title":"The Swift Programming Language (5.9.2)"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/OpaqueTypes#The-Problem-That-Opaque-Types-Solve":{"title":"The Problem That Opaque Types Solve","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes#The-Problem-That-Opaque-Types-Solve","abstract":[],"url":"\/documentation\/the-swift-programming-language\/opaquetypes#The-Problem-That-Opaque-Types-Solve","kind":"section"}}}