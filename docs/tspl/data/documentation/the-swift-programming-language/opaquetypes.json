{"sections":[],"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes","interfaceLanguage":"swift"},"metadata":{"title":"Opaque and Boxed Types"},"primaryContentSections":[{"kind":"content","content":[{"type":"paragraph","inlineContent":[{"text":"Swift provides two ways to hide details about a value’s type:","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"opaque types and boxed protocol types."},{"text":" ","type":"text"},{"type":"text","text":"Hiding type information"},{"type":"text","text":" "},{"type":"text","text":"is useful at boundaries between"},{"type":"text","text":" "},{"type":"text","text":"a module and code that calls into the module,"},{"type":"text","text":" "},{"type":"text","text":"because the underlying type of the return value can remain private."}]},{"type":"paragraph","inlineContent":[{"text":"A function or method that returns an opaque type","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"hides its return value’s type information."},{"type":"text","text":" "},{"type":"text","text":"Instead of providing a concrete type as the function’s return type,"},{"text":" ","type":"text"},{"type":"text","text":"the return value is described in terms of the protocols it supports."},{"type":"text","text":" "},{"text":"Opaque types preserve type identity —","type":"text"},{"type":"text","text":" "},{"text":"the compiler has access to the type information,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"but clients of the module don’t."}]},{"inlineContent":[{"type":"text","text":"A boxed protocol type can store an instance of any type"},{"text":" ","type":"text"},{"type":"text","text":"that conforms to the given protocol."},{"text":" ","type":"text"},{"text":"Boxed protocol types don’t preserve type identity —","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the value’s specific type isn’t known until runtime,"},{"text":" ","type":"text"},{"text":"and it can change over time as different values are stored.","type":"text"}],"type":"paragraph"},{"type":"heading","text":"The Problem That Opaque Types Solve","level":2,"anchor":"The-Problem-That-Opaque-Types-Solve"},{"inlineContent":[{"text":"For example,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"suppose you’re writing a module that draws ASCII art shapes."},{"type":"text","text":" "},{"text":"The basic characteristic of an ASCII art shape","type":"text"},{"type":"text","text":" "},{"type":"text","text":"is a "},{"type":"codeVoice","code":"draw()"},{"type":"text","text":" function that returns the string representation of that shape,"},{"text":" ","type":"text"},{"type":"text","text":"which you can use as the requirement for the "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" protocol:"}],"type":"paragraph"},{"syntax":"swift","code":["protocol Shape {","    func draw() -> String","}","","struct Triangle: Shape {","    var size: Int","    func draw() -> String {","       var result: [String] = []","       for length in 1...size {","           result.append(String(repeating: \"*\", count: length))","       }","       return result.joined(separator: \"\\n\")","    }","}","let smallTriangle = Triangle(size: 3)","print(smallTriangle.draw())","\/\/ *","\/\/ **","\/\/ ***"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"You could use generics to implement operations like flipping a shape vertically,"},{"text":" ","type":"text"},{"type":"text","text":"as shown in the code below."},{"type":"text","text":" "},{"type":"text","text":"However, there’s an important limitation to this approach:"},{"text":" ","type":"text"},{"type":"text","text":"The flipped result exposes the exact generic types"},{"type":"text","text":" "},{"type":"text","text":"that were used to create it."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["struct FlippedShape<T: Shape>: Shape {","    var shape: T","    func draw() -> String {","        let lines = shape.draw().split(separator: \"\\n\")","        return lines.reversed().joined(separator: \"\\n\")","    }","}","let flippedTriangle = FlippedShape(shape: smallTriangle)","print(flippedTriangle.draw())","\/\/ ***","\/\/ **","\/\/ *"]},{"inlineContent":[{"text":"This approach to defining a ","type":"text"},{"code":"JoinedShape<T: Shape, U: Shape>","type":"codeVoice"},{"type":"text","text":" structure"},{"type":"text","text":" "},{"type":"text","text":"that joins two shapes together vertically, like the code below shows,"},{"type":"text","text":" "},{"type":"text","text":"results in types like "},{"type":"codeVoice","code":"JoinedShape<FlippedShape<Triangle>, Triangle>"},{"text":" ","type":"text"},{"text":"from joining a flipped triangle with another triangle.","type":"text"}],"type":"paragraph"},{"code":["struct JoinedShape<T: Shape, U: Shape>: Shape {","    var top: T","    var bottom: U","    func draw() -> String {","       return top.draw() + \"\\n\" + bottom.draw()","    }","}","let joinedTriangles = JoinedShape(top: smallTriangle, bottom: flippedTriangle)","print(joinedTriangles.draw())","\/\/ *","\/\/ **","\/\/ ***","\/\/ ***","\/\/ **","\/\/ *"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Exposing detailed information about the creation of a shape"},{"type":"text","text":" "},{"text":"allows types that aren’t meant to be","type":"text"},{"text":" ","type":"text"},{"text":"part of the ASCII art module’s public interface","type":"text"},{"type":"text","text":" "},{"text":"to leak out because of the need to state the full return type.","type":"text"},{"text":" ","type":"text"},{"text":"The code inside the module","type":"text"},{"text":" ","type":"text"},{"text":"could build up the same shape in a variety of ways,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and other code outside the module"},{"type":"text","text":" "},{"type":"text","text":"that uses the shape shouldn’t have to account for"},{"type":"text","text":" "},{"type":"text","text":"the implementation details about the list of transformations."},{"type":"text","text":" "},{"type":"text","text":"Wrapper types like "},{"code":"JoinedShape","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"FlippedShape"},{"type":"text","text":" "},{"text":"don’t matter to the module’s users,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and they shouldn’t be visible."},{"type":"text","text":" "},{"text":"The module’s public interface","type":"text"},{"type":"text","text":" "},{"text":"consists of operations like joining and flipping a shape,","type":"text"},{"text":" ","type":"text"},{"text":"and those operations return another ","type":"text"},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" value."}],"type":"paragraph"},{"text":"Returning an Opaque Type","anchor":"Returning-an-Opaque-Type","level":2,"type":"heading"},{"inlineContent":[{"text":"You can think of an opaque type like being the reverse of a generic type.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Generic types let the code that calls a function"},{"type":"text","text":" "},{"text":"pick the type for that function’s parameters and return value","type":"text"},{"type":"text","text":" "},{"type":"text","text":"in a way that’s abstracted away from the function implementation."},{"type":"text","text":" "},{"type":"text","text":"For example, the function in the following code"},{"type":"text","text":" "},{"type":"text","text":"returns a type that depends on its caller:"}],"type":"paragraph"},{"code":["func max<T>(_ x: T, _ y: T) -> T where T: Comparable { ... }"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The code that calls "},{"code":"max(_:_:)","type":"codeVoice"},{"type":"text","text":" chooses the values for "},{"code":"x","type":"codeVoice"},{"type":"text","text":" and "},{"code":"y","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"and the type of those values determines the concrete type of ","type":"text"},{"type":"codeVoice","code":"T"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"The calling code can use any type","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that conforms to the "},{"code":"Comparable","type":"codeVoice"},{"type":"text","text":" protocol."},{"type":"text","text":" "},{"type":"text","text":"The code inside the function is written in a general way"},{"text":" ","type":"text"},{"text":"so it can handle whatever type the caller provides.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The implementation of "},{"type":"codeVoice","code":"max(_:_:)"},{"type":"text","text":" uses only functionality"},{"text":" ","type":"text"},{"type":"text","text":"that all "},{"type":"codeVoice","code":"Comparable"},{"text":" types share.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Those roles are reversed for a function with an opaque return type."},{"text":" ","type":"text"},{"type":"text","text":"An opaque type lets the function implementation"},{"text":" ","type":"text"},{"type":"text","text":"pick the type for the value it returns"},{"text":" ","type":"text"},{"text":"in a way that’s abstracted away from the code that calls the function.","type":"text"},{"type":"text","text":" "},{"text":"For example, the function in the following example returns a trapezoid","type":"text"},{"type":"text","text":" "},{"text":"without exposing the underlying type of that shape.","type":"text"}]},{"code":["struct Square: Shape {","    var size: Int","    func draw() -> String {","        let line = String(repeating: \"*\", count: size)","        let result = Array<String>(repeating: line, count: size)","        return result.joined(separator: \"\\n\")","    }","}","","func makeTrapezoid() -> some Shape {","    let top = Triangle(size: 2)","    let middle = Square(size: 2)","    let bottom = FlippedShape(shape: top)","    let trapezoid = JoinedShape(","        top: top,","        bottom: JoinedShape(top: middle, bottom: bottom)","    )","    return trapezoid","}","let trapezoid = makeTrapezoid()","print(trapezoid.draw())","\/\/ *","\/\/ **","\/\/ **","\/\/ **","\/\/ **","\/\/ *"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"makeTrapezoid()"},{"type":"text","text":" function in this example"},{"type":"text","text":" "},{"type":"text","text":"declares its return type as "},{"type":"codeVoice","code":"some Shape"},{"type":"text","text":";"},{"text":" ","type":"text"},{"type":"text","text":"as a result, the function"},{"type":"text","text":" "},{"type":"text","text":"returns a value of some given type that conforms to the "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" protocol,"},{"type":"text","text":" "},{"text":"without specifying any particular concrete type.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Writing "},{"code":"makeTrapezoid()","type":"codeVoice"},{"text":" this way lets it express","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the fundamental aspect of its public interface —"},{"type":"text","text":" "},{"type":"text","text":"the value it returns is a shape —"},{"text":" ","type":"text"},{"type":"text","text":"without making the specific types that the shape is made from"},{"type":"text","text":" "},{"text":"a part of its public interface.","type":"text"},{"text":" ","type":"text"},{"text":"This implementation uses two triangles and a square,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"but the function could be rewritten to draw a trapezoid"},{"type":"text","text":" "},{"type":"text","text":"in a variety of other ways"},{"text":" ","type":"text"},{"type":"text","text":"without changing its return type."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example highlights the way that an opaque return type"},{"text":" ","type":"text"},{"type":"text","text":"is like the reverse of a generic type."},{"type":"text","text":" "},{"type":"text","text":"The code inside "},{"type":"codeVoice","code":"makeTrapezoid()"},{"text":" can return any type it needs to,","type":"text"},{"text":" ","type":"text"},{"text":"as long as that type conforms to the ","type":"text"},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" protocol,"},{"type":"text","text":" "},{"type":"text","text":"like the calling code does for a generic function."},{"text":" ","type":"text"},{"type":"text","text":"The code that calls the function needs to be written in a general way,"},{"type":"text","text":" "},{"text":"like the implementation of a generic function,","type":"text"},{"type":"text","text":" "},{"text":"so that it can work with any ","type":"text"},{"code":"Shape","type":"codeVoice"},{"text":" value","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that’s returned by "},{"type":"codeVoice","code":"makeTrapezoid()"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"text":"You can also combine opaque return types with generics.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The functions in the following code both return a value"},{"type":"text","text":" "},{"type":"text","text":"of some type that conforms to the "},{"code":"Shape","type":"codeVoice"},{"text":" protocol.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["func flip<T: Shape>(_ shape: T) -> some Shape {","    return FlippedShape(shape: shape)","}","func join<T: Shape, U: Shape>(_ top: T, _ bottom: U) -> some Shape {","    JoinedShape(top: top, bottom: bottom)","}","","let opaqueJoinedTriangles = join(smallTriangle, flip(smallTriangle))","print(opaqueJoinedTriangles.draw())","\/\/ *","\/\/ **","\/\/ ***","\/\/ ***","\/\/ **","\/\/ *"]},{"inlineContent":[{"text":"The value of ","type":"text"},{"code":"opaqueJoinedTriangles","type":"codeVoice"},{"text":" in this example","type":"text"},{"type":"text","text":" "},{"text":"is the same as ","type":"text"},{"type":"codeVoice","code":"joinedTriangles"},{"text":" in the generics example","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"in the "},{"isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes#The-Problem-That-Opaque-Types-Solve","type":"reference"},{"text":" section earlier in this chapter.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"However, unlike the value in that example,"},{"type":"text","text":" "},{"type":"codeVoice","code":"flip(_:)"},{"type":"text","text":" and "},{"type":"codeVoice","code":"join(_:_:)"},{"type":"text","text":" wrap the underlying types"},{"text":" ","type":"text"},{"type":"text","text":"that the generic shape operations return"},{"type":"text","text":" "},{"type":"text","text":"in an opaque return type,"},{"type":"text","text":" "},{"type":"text","text":"which prevents those types from being visible."},{"type":"text","text":" "},{"type":"text","text":"Both functions are generic because the types they rely on are generic,"},{"type":"text","text":" "},{"text":"and the type parameters to the function","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"pass along the type information needed by "},{"type":"codeVoice","code":"FlippedShape"},{"text":" and ","type":"text"},{"code":"JoinedShape","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a function with an opaque return type"},{"type":"text","text":" "},{"type":"text","text":"returns from multiple places,"},{"type":"text","text":" "},{"text":"all of the possible return values must have the same type.","type":"text"},{"text":" ","type":"text"},{"text":"For a generic function,","type":"text"},{"type":"text","text":" "},{"text":"that return type can use the function’s generic type parameters,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"but it must still be a single type."},{"text":" ","type":"text"},{"text":"For example,","type":"text"},{"type":"text","text":" "},{"text":"here’s an ","type":"text"},{"inlineContent":[{"type":"text","text":"invalid"}],"type":"emphasis"},{"type":"text","text":" version of the shape-flipping function"},{"type":"text","text":" "},{"type":"text","text":"that includes a special case for squares:"}]},{"syntax":"swift","code":["func invalidFlip<T: Shape>(_ shape: T) -> some Shape {","    if shape is Square {","        return shape \/\/ Error: return types don't match","    }","    return FlippedShape(shape: shape) \/\/ Error: return types don't match","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you call this function with a "},{"type":"codeVoice","code":"Square"},{"type":"text","text":", it returns a "},{"type":"codeVoice","code":"Square"},{"type":"text","text":";"},{"type":"text","text":" "},{"type":"text","text":"otherwise, it returns a "},{"type":"codeVoice","code":"FlippedShape"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"This violates the requirement to return values of only one type","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and makes "},{"type":"codeVoice","code":"invalidFlip(_:)"},{"type":"text","text":" invalid code."},{"text":" ","type":"text"},{"type":"text","text":"One way to fix "},{"code":"invalidFlip(_:)","type":"codeVoice"},{"type":"text","text":" is to move the special case for squares"},{"text":" ","type":"text"},{"text":"into the implementation of ","type":"text"},{"code":"FlippedShape","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"which lets this function always return a ","type":"text"},{"type":"codeVoice","code":"FlippedShape"},{"type":"text","text":" value:"}]},{"code":["struct FlippedShape<T: Shape>: Shape {","    var shape: T","    func draw() -> String {","        if shape is Square {","           return shape.draw()","        }","        let lines = shape.draw().split(separator: \"\\n\")","        return lines.reversed().joined(separator: \"\\n\")","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"The requirement to always return a single type"},{"type":"text","text":" "},{"text":"doesn’t prevent you from using generics in an opaque return type.","type":"text"},{"text":" ","type":"text"},{"text":"Here’s an example of a function that incorporates its type parameter","type":"text"},{"type":"text","text":" "},{"text":"into the underlying type of the value it returns:","type":"text"}],"type":"paragraph"},{"code":["func `repeat`<T: Shape>(shape: T, count: Int) -> some Collection {","    return Array<T>(repeating: shape, count: count)","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"In this case,","type":"text"},{"type":"text","text":" "},{"text":"the underlying type of the return value","type":"text"},{"type":"text","text":" "},{"text":"varies depending on ","type":"text"},{"type":"codeVoice","code":"T"},{"text":":","type":"text"},{"type":"text","text":" "},{"text":"Whatever shape is passed it,","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"repeat(shape:count:)"},{"type":"text","text":" creates and returns an array of that shape."},{"text":" ","type":"text"},{"type":"text","text":"Nevertheless,"},{"type":"text","text":" "},{"text":"the return value always has the same underlying type of ","type":"text"},{"code":"[T]","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"so it follows the requirement that functions with opaque return types"},{"type":"text","text":" "},{"text":"must return values of only a single type.","type":"text"}]},{"anchor":"Boxed-Protocol-Types","text":"Boxed Protocol Types","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"A boxed protocol type is also sometimes called an "},{"inlineContent":[{"text":"existential type","type":"text"}],"type":"emphasis"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"which comes from the phrase","type":"text"},{"type":"text","text":" "},{"type":"text","text":"“there exists a type "},{"inlineContent":[{"text":"T","type":"text"}],"type":"emphasis"},{"type":"text","text":" such that "},{"type":"emphasis","inlineContent":[{"type":"text","text":"T"}]},{"type":"text","text":" conforms to the protocol”."},{"type":"text","text":" "},{"type":"text","text":"To make a boxed protocol type,"},{"type":"text","text":" "},{"type":"text","text":"write "},{"code":"any","type":"codeVoice"},{"text":" before the name of a protocol.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Here’s an example:"}],"type":"paragraph"},{"type":"codeListing","code":["struct VerticalShapes: Shape {","    var shapes: [any Shape]","    func draw() -> String {","        return shapes.map { $0.draw() }.joined(separator: \"\\n\\n\")","    }","}","","let largeTriangle = Triangle(size: 5)","let largeSquare = Square(size: 5)","let vertical = VerticalShapes(shapes: [largeTriangle, largeSquare])","print(vertical.draw())"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"In the example above,","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"VerticalShapes"},{"text":" declares the type of ","type":"text"},{"type":"codeVoice","code":"shapes"},{"type":"text","text":" as "},{"code":"[any Shape]","type":"codeVoice"},{"type":"text","text":" —"},{"text":" ","type":"text"},{"type":"text","text":"an array of boxed "},{"code":"Shape","type":"codeVoice"},{"text":" elements.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Each element in the array can be a different type,"},{"text":" ","type":"text"},{"text":"and each of those types must conform to the ","type":"text"},{"code":"Shape","type":"codeVoice"},{"text":" protocol.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"To support this runtime flexibility,"},{"type":"text","text":" "},{"text":"Swift adds a level of indirection when necessary —","type":"text"},{"type":"text","text":" "},{"text":"this indirection is called a ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"box"}]},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"and it has a performance cost.","type":"text"}]},{"inlineContent":[{"type":"text","text":"Within the "},{"type":"codeVoice","code":"VerticalShapes"},{"type":"text","text":" type,"},{"type":"text","text":" "},{"text":"the code can use methods, properties, and subscripts","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that are required by the "},{"code":"Shape","type":"codeVoice"},{"text":" protocol.","type":"text"},{"type":"text","text":" "},{"text":"For example, the ","type":"text"},{"type":"codeVoice","code":"draw()"},{"type":"text","text":" method of "},{"code":"VerticalShapes","type":"codeVoice"},{"type":"text","text":" "},{"text":"calls the ","type":"text"},{"code":"draw()","type":"codeVoice"},{"text":" method on each element of the array.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"This method is available because "},{"type":"codeVoice","code":"Shape"},{"text":" requires a ","type":"text"},{"code":"draw()","type":"codeVoice"},{"text":" method.","type":"text"},{"text":" ","type":"text"},{"text":"In contrast,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"trying to access the "},{"type":"codeVoice","code":"size"},{"text":" property of the triangle,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"or any other properties or methods that aren’t required by "},{"code":"Shape","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"produces an error."}],"type":"paragraph"},{"inlineContent":[{"text":"Contrast the three types you could use for ","type":"text"},{"type":"codeVoice","code":"shapes"},{"type":"text","text":":"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Using generics,"},{"type":"text","text":" "},{"type":"text","text":"by writing "},{"type":"codeVoice","code":"struct VerticalShapes<S: Shape>"},{"type":"text","text":" and "},{"code":"var shapes: [S]","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"makes an array whose elements are some specific shape type,","type":"text"},{"text":" ","type":"text"},{"text":"and where the identity of that specific type","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"is visible to any code that interacts with the array."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Using an opaque type,"},{"type":"text","text":" "},{"text":"by writing ","type":"text"},{"type":"codeVoice","code":"var shapes: [some Shape]"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"makes an array whose elements are some specific shape type,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and where that specific type’s identity is hidden."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Using a boxed protocol type,"},{"text":" ","type":"text"},{"text":"by writing ","type":"text"},{"code":"var shapes: [any Shape]","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"makes an array that can store elements of different types,","type":"text"},{"text":" ","type":"text"},{"text":"and where those types’ identities are hidden.","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"text":"In this case,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"a boxed protocol type is the only approach"},{"text":" ","type":"text"},{"type":"text","text":"that lets callers of "},{"type":"codeVoice","code":"VerticalShapes"},{"type":"text","text":" mix different kinds of shapes together."}]},{"inlineContent":[{"type":"text","text":"You can use an "},{"code":"as","type":"codeVoice"},{"text":" cast","type":"text"},{"text":" ","type":"text"},{"text":"when you know the underlying type of a boxed value.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For example:"}],"type":"paragraph"},{"syntax":"swift","code":["if let downcastTriangle = vertical.shapes[0] as? Triangle {","    print(downcastTriangle.size)","}","\/\/ Prints \"5\""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"For more information, see ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting#Downcasting"},{"type":"text","text":"."}]},{"level":2,"type":"heading","anchor":"Differences-Between-Opaque-Types-and-Boxed-Protocol-Types","text":"Differences Between Opaque Types and Boxed Protocol Types"},{"inlineContent":[{"type":"text","text":"Returning an opaque type looks very similar"},{"text":" ","type":"text"},{"type":"text","text":"to using a boxed protocol type as the return type of a function,"},{"text":" ","type":"text"},{"text":"but these two kinds of return type differ in","type":"text"},{"type":"text","text":" "},{"type":"text","text":"whether they preserve type identity."},{"type":"text","text":" "},{"type":"text","text":"An opaque type refers to one specific type,"},{"type":"text","text":" "},{"type":"text","text":"although the caller of the function isn’t able to see which type;"},{"text":" ","type":"text"},{"type":"text","text":"a boxed protocol type can refer to any type that conforms to the protocol."},{"type":"text","text":" "},{"type":"text","text":"Generally speaking,"},{"type":"text","text":" "},{"text":"boxed protocol types give you more flexibility","type":"text"},{"text":" ","type":"text"},{"text":"about the underlying types of the values they store,","type":"text"},{"type":"text","text":" "},{"text":"and opaque types let you make stronger guarantees","type":"text"},{"type":"text","text":" "},{"text":"about those underlying types.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"For example,","type":"text"},{"type":"text","text":" "},{"text":"here’s a version of ","type":"text"},{"type":"codeVoice","code":"flip(_:)"},{"text":" ","type":"text"},{"type":"text","text":"that uses a boxed protocol type as its return type"},{"text":" ","type":"text"},{"type":"text","text":"instead of an opaque return type:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["func protoFlip<T: Shape>(_ shape: T) -> Shape {","    return FlippedShape(shape: shape)","}"]},{"type":"paragraph","inlineContent":[{"text":"This version of ","type":"text"},{"type":"codeVoice","code":"protoFlip(_:)"},{"type":"text","text":" "},{"type":"text","text":"has the same body as "},{"type":"codeVoice","code":"flip(_:)"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"and it always returns a value of the same type.","type":"text"},{"type":"text","text":" "},{"text":"Unlike ","type":"text"},{"type":"codeVoice","code":"flip(_:)"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"the value that "},{"code":"protoFlip(_:)","type":"codeVoice"},{"type":"text","text":" returns isn’t required"},{"type":"text","text":" "},{"text":"to always have the same type —","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"it just has to conform to the "},{"code":"Shape","type":"codeVoice"},{"text":" protocol.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Put another way,"},{"text":" ","type":"text"},{"type":"codeVoice","code":"protoFlip(_:)"},{"text":" makes a much looser API contract with its caller","type":"text"},{"text":" ","type":"text"},{"text":"than ","type":"text"},{"code":"flip(_:)","type":"codeVoice"},{"text":" makes.","type":"text"},{"text":" ","type":"text"},{"text":"It reserves the flexibility to return values of multiple types:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["func protoFlip<T: Shape>(_ shape: T) -> Shape {","    if shape is Square {","        return shape","    }","","    return FlippedShape(shape: shape)","}"]},{"type":"paragraph","inlineContent":[{"text":"The revised version of the code returns","type":"text"},{"text":" ","type":"text"},{"text":"an instance of ","type":"text"},{"code":"Square","type":"codeVoice"},{"text":" or an instance of ","type":"text"},{"type":"codeVoice","code":"FlippedShape"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"depending on what shape is passed in.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Two flipped shapes returned by this function"},{"text":" ","type":"text"},{"type":"text","text":"might have completely different types."},{"type":"text","text":" "},{"text":"Other valid versions of this function could return values of different types","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"when flipping multiple instances of the same shape."},{"text":" ","type":"text"},{"type":"text","text":"The less specific return type information from "},{"code":"protoFlip(_:)","type":"codeVoice"},{"text":" means that","type":"text"},{"type":"text","text":" "},{"type":"text","text":"many operations that depend on type information"},{"type":"text","text":" "},{"type":"text","text":"aren’t available on the returned value."},{"type":"text","text":" "},{"text":"For example, it’s not possible to write an ","type":"text"},{"type":"codeVoice","code":"=="},{"text":" operator","type":"text"},{"type":"text","text":" "},{"type":"text","text":"comparing results returned by this function."}]},{"syntax":"swift","type":"codeListing","code":["let protoFlippedTriangle = protoFlip(smallTriangle)","let sameThing = protoFlip(smallTriangle)","protoFlippedTriangle == sameThing  \/\/ Error"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The error on the last line of the example occurs for several reasons."},{"text":" ","type":"text"},{"text":"The immediate issue is that the ","type":"text"},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" doesn’t include an "},{"code":"==","type":"codeVoice"},{"text":" operator","type":"text"},{"type":"text","text":" "},{"type":"text","text":"as part of its protocol requirements."},{"text":" ","type":"text"},{"type":"text","text":"If you try adding one, the next issue you’ll encounter"},{"type":"text","text":" "},{"type":"text","text":"is that the "},{"code":"==","type":"codeVoice"},{"type":"text","text":" operator needs to know"},{"type":"text","text":" "},{"type":"text","text":"the types of its left-hand and right-hand arguments."},{"text":" ","type":"text"},{"type":"text","text":"This sort of operator usually takes arguments of type "},{"type":"codeVoice","code":"Self"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"matching whatever concrete type adopts the protocol,","type":"text"},{"text":" ","type":"text"},{"text":"but adding a ","type":"text"},{"type":"codeVoice","code":"Self"},{"text":" requirement to the protocol","type":"text"},{"type":"text","text":" "},{"type":"text","text":"doesn’t allow for the type erasure that happens"},{"type":"text","text":" "},{"type":"text","text":"when you use the protocol as a type."}]},{"inlineContent":[{"type":"text","text":"Using a boxed protocol type as the return type for a function"},{"type":"text","text":" "},{"type":"text","text":"gives you the flexibility to return any type that conforms to the protocol."},{"text":" ","type":"text"},{"type":"text","text":"However, the cost of that flexibility"},{"type":"text","text":" "},{"text":"is that some operations aren’t possible on the returned values.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The example shows how the "},{"type":"codeVoice","code":"=="},{"text":" operator isn’t available —","type":"text"},{"type":"text","text":" "},{"type":"text","text":"it depends on specific type information"},{"type":"text","text":" "},{"text":"that isn’t preserved by using a boxed protocol type.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Another problem with this approach is that the shape transformations don’t nest.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The result of flipping a triangle is a value of type "},{"type":"codeVoice","code":"Shape"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and the "},{"type":"codeVoice","code":"protoFlip(_:)"},{"text":" function takes an argument","type":"text"},{"text":" ","type":"text"},{"text":"of some type that conforms to the ","type":"text"},{"code":"Shape","type":"codeVoice"},{"type":"text","text":" protocol."},{"type":"text","text":" "},{"type":"text","text":"However, a value of a boxed protocol type doesn’t conform to that protocol;"},{"type":"text","text":" "},{"type":"text","text":"the value returned by "},{"code":"protoFlip(_:)","type":"codeVoice"},{"text":" doesn’t conform to ","type":"text"},{"type":"codeVoice","code":"Shape"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"This means code like "},{"type":"codeVoice","code":"protoFlip(protoFlip(smallTriangle))"},{"type":"text","text":" "},{"text":"that applies multiple transformations is invalid","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"because the flipped shape isn’t a valid argument to "},{"code":"protoFlip(_:)","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"In contrast,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"opaque types preserve the identity of the underlying type."},{"type":"text","text":" "},{"text":"Swift can infer associated types,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"which lets you use an opaque return value"},{"text":" ","type":"text"},{"type":"text","text":"in places where a boxed protocol type can’t be used as a return value."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"here’s a version of the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol from "},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics"},{"text":":","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["protocol Container {","    associatedtype Item","    var count: Int { get }","    subscript(i: Int) -> Item { get }","}","extension Array: Container { }"]},{"inlineContent":[{"type":"text","text":"You can’t use "},{"type":"codeVoice","code":"Container"},{"text":" as the return type of a function","type":"text"},{"text":" ","type":"text"},{"text":"because that protocol has an associated type.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"You also can’t use it as constraint in a generic return type"},{"text":" ","type":"text"},{"type":"text","text":"because there isn’t enough information outside the function body"},{"type":"text","text":" "},{"text":"to infer what the generic type needs to be.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/ Error: Protocol with associated types can't be used as a return type.","func makeProtocolContainer<T>(item: T) -> Container {","    return [item]","}","","\/\/ Error: Not enough information to infer C.","func makeProtocolContainer<T, C: Container>(item: T) -> C {","    return [item]","}"]},{"inlineContent":[{"type":"text","text":"Using the opaque type "},{"type":"codeVoice","code":"some Container"},{"text":" as a return type","type":"text"},{"type":"text","text":" "},{"type":"text","text":"expresses the desired API contract — the function returns a container,"},{"type":"text","text":" "},{"type":"text","text":"but declines to specify the container’s type:"}],"type":"paragraph"},{"code":["func makeOpaqueContainer<T>(item: T) -> some Container {","    return [item]","}","let opaqueContainer = makeOpaqueContainer(item: 12)","let twelve = opaqueContainer[0]","print(type(of: twelve))","\/\/ Prints \"Int\""],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The type of ","type":"text"},{"type":"codeVoice","code":"twelve"},{"text":" is inferred to be ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"which illustrates the fact that type inference works with opaque types."},{"type":"text","text":" "},{"text":"In the implementation of ","type":"text"},{"code":"makeOpaqueContainer(item:)","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"the underlying type of the opaque container is ","type":"text"},{"code":"[T]","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"In this case, ","type":"text"},{"type":"codeVoice","code":"T"},{"type":"text","text":" is "},{"type":"codeVoice","code":"Int"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"so the return value is an array of integers","type":"text"},{"type":"text","text":" "},{"text":"and the ","type":"text"},{"type":"codeVoice","code":"Item"},{"text":" associated type is inferred to be ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The subscript on "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" returns "},{"code":"Item","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"which means that the type of ","type":"text"},{"type":"codeVoice","code":"twelve"},{"type":"text","text":" is also inferred to be "},{"code":"Int","type":"codeVoice"},{"type":"text","text":"."}]}]}],"kind":"article","abstract":[{"type":"text","text":"Hide implementation details about a value’s type."}],"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"schemaVersion":{"minor":3,"major":0,"patch":0},"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Generics":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","type":"topic","abstract":[{"type":"text","text":"Write code that works for multiple types and specify requirements for those types."}],"title":"Generics","kind":"article","role":"article","url":"\/documentation\/the-swift-programming-language\/generics"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/OpaqueTypes#The-Problem-That-Opaque-Types-Solve":{"type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes#The-Problem-That-Opaque-Types-Solve","url":"\/documentation\/the-swift-programming-language\/opaquetypes#The-Problem-That-Opaque-Types-Solve","abstract":[],"kind":"section","title":"The Problem That Opaque Types Solve"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TypeCasting#Downcasting":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting#Downcasting","abstract":[],"title":"Downcasting","type":"topic","url":"\/documentation\/the-swift-programming-language\/typecasting#Downcasting","kind":"section"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language","title":"The Swift Programming Language (5.9.2)","url":"\/documentation\/the-swift-programming-language","role":"collection","kind":"article","abstract":[]}}}