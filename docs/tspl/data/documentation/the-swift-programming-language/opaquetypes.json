{"sections":[],"kind":"article","metadata":{"title":"Opaque and Boxed Types"},"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes","interfaceLanguage":"swift"},"primaryContentSections":[{"kind":"content","content":[{"inlineContent":[{"type":"text","text":"Swift provides two ways to hide details about a value’s type:"},{"text":" ","type":"text"},{"type":"text","text":"opaque types and boxed protocol types."},{"type":"text","text":" "},{"type":"text","text":"Hiding type information"},{"type":"text","text":" "},{"text":"is useful at boundaries between","type":"text"},{"type":"text","text":" "},{"type":"text","text":"a module and code that calls into the module,"},{"text":" ","type":"text"},{"text":"because the underlying type of the return value can remain private.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"A function or method that returns an opaque type","type":"text"},{"type":"text","text":" "},{"type":"text","text":"hides its return value’s type information."},{"type":"text","text":" "},{"text":"Instead of providing a concrete type as the function’s return type,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the return value is described in terms of the protocols it supports."},{"type":"text","text":" "},{"type":"text","text":"Opaque types preserve type identity —"},{"type":"text","text":" "},{"text":"the compiler has access to the type information,","type":"text"},{"type":"text","text":" "},{"text":"but clients of the module don’t.","type":"text"}]},{"inlineContent":[{"type":"text","text":"A boxed protocol type can store an instance of any type"},{"type":"text","text":" "},{"type":"text","text":"that conforms to the given protocol."},{"type":"text","text":" "},{"text":"Boxed protocol types don’t preserve type identity —","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the value’s specific type isn’t known until runtime,"},{"type":"text","text":" "},{"text":"and it can change over time as different values are stored.","type":"text"}],"type":"paragraph"},{"type":"heading","text":"The Problem That Opaque Types Solve","anchor":"The-Problem-That-Opaque-Types-Solve","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example,"},{"type":"text","text":" "},{"text":"suppose you’re writing a module that draws ASCII art shapes.","type":"text"},{"text":" ","type":"text"},{"text":"The basic characteristic of an ASCII art shape","type":"text"},{"type":"text","text":" "},{"text":"is a ","type":"text"},{"code":"draw()","type":"codeVoice"},{"text":" function that returns the string representation of that shape,","type":"text"},{"type":"text","text":" "},{"text":"which you can use as the requirement for the ","type":"text"},{"code":"Shape","type":"codeVoice"},{"text":" protocol:","type":"text"}]},{"code":["protocol Shape {","    func draw() -> String","}","","struct Triangle: Shape {","    var size: Int","    func draw() -> String {","       var result: [String] = []","       for length in 1...size {","           result.append(String(repeating: \"*\", count: length))","       }","       return result.joined(separator: \"\\n\")","    }","}","let smallTriangle = Triangle(size: 3)","print(smallTriangle.draw())","\/\/ *","\/\/ **","\/\/ ***"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"You could use generics to implement operations like flipping a shape vertically,"},{"type":"text","text":" "},{"text":"as shown in the code below.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"However, there’s an important limitation to this approach:"},{"type":"text","text":" "},{"type":"text","text":"The flipped result exposes the exact generic types"},{"text":" ","type":"text"},{"text":"that were used to create it.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["struct FlippedShape<T: Shape>: Shape {","    var shape: T","    func draw() -> String {","        let lines = shape.draw().split(separator: \"\\n\")","        return lines.reversed().joined(separator: \"\\n\")","    }","}","let flippedTriangle = FlippedShape(shape: smallTriangle)","print(flippedTriangle.draw())","\/\/ ***","\/\/ **","\/\/ *"],"type":"codeListing"},{"inlineContent":[{"text":"This approach to defining a ","type":"text"},{"code":"JoinedShape<T: Shape, U: Shape>","type":"codeVoice"},{"text":" structure","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that joins two shapes together vertically, like the code below shows,"},{"type":"text","text":" "},{"text":"results in types like ","type":"text"},{"code":"JoinedShape<FlippedShape<Triangle>, Triangle>","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"from joining a flipped triangle with another triangle."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["struct JoinedShape<T: Shape, U: Shape>: Shape {","    var top: T","    var bottom: U","    func draw() -> String {","       return top.draw() + \"\\n\" + bottom.draw()","    }","}","let joinedTriangles = JoinedShape(top: smallTriangle, bottom: flippedTriangle)","print(joinedTriangles.draw())","\/\/ *","\/\/ **","\/\/ ***","\/\/ ***","\/\/ **","\/\/ *"]},{"inlineContent":[{"text":"Exposing detailed information about the creation of a shape","type":"text"},{"type":"text","text":" "},{"type":"text","text":"allows types that aren’t meant to be"},{"type":"text","text":" "},{"type":"text","text":"part of the ASCII art module’s public interface"},{"type":"text","text":" "},{"type":"text","text":"to leak out because of the need to state the full return type."},{"type":"text","text":" "},{"type":"text","text":"The code inside the module"},{"type":"text","text":" "},{"text":"could build up the same shape in a variety of ways,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and other code outside the module"},{"type":"text","text":" "},{"text":"that uses the shape shouldn’t have to account for","type":"text"},{"text":" ","type":"text"},{"text":"the implementation details about the list of transformations.","type":"text"},{"type":"text","text":" "},{"text":"Wrapper types like ","type":"text"},{"type":"codeVoice","code":"JoinedShape"},{"type":"text","text":" and "},{"type":"codeVoice","code":"FlippedShape"},{"type":"text","text":" "},{"type":"text","text":"don’t matter to the module’s users,"},{"text":" ","type":"text"},{"text":"and they shouldn’t be visible.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The module’s public interface"},{"type":"text","text":" "},{"text":"consists of operations like joining and flipping a shape,","type":"text"},{"text":" ","type":"text"},{"text":"and those operations return another ","type":"text"},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" value."}],"type":"paragraph"},{"text":"Returning an Opaque Type","level":2,"anchor":"Returning-an-Opaque-Type","type":"heading"},{"inlineContent":[{"text":"You can think of an opaque type like being the reverse of a generic type.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Generic types let the code that calls a function"},{"type":"text","text":" "},{"text":"pick the type for that function’s parameters and return value","type":"text"},{"text":" ","type":"text"},{"text":"in a way that’s abstracted away from the function implementation.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For example, the function in the following code"},{"type":"text","text":" "},{"type":"text","text":"returns a type that depends on its caller:"}],"type":"paragraph"},{"type":"codeListing","code":["func max<T>(_ x: T, _ y: T) -> T where T: Comparable { ... }"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The code that calls ","type":"text"},{"type":"codeVoice","code":"max(_:_:)"},{"text":" chooses the values for ","type":"text"},{"code":"x","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"y","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and the type of those values determines the concrete type of "},{"code":"T","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"The calling code can use any type","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"that conforms to the "},{"type":"codeVoice","code":"Comparable"},{"text":" protocol.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The code inside the function is written in a general way"},{"type":"text","text":" "},{"type":"text","text":"so it can handle whatever type the caller provides."},{"text":" ","type":"text"},{"type":"text","text":"The implementation of "},{"code":"max(_:_:)","type":"codeVoice"},{"type":"text","text":" uses only functionality"},{"text":" ","type":"text"},{"text":"that all ","type":"text"},{"code":"Comparable","type":"codeVoice"},{"type":"text","text":" types share."}]},{"type":"paragraph","inlineContent":[{"text":"Those roles are reversed for a function with an opaque return type.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"An opaque type lets the function implementation"},{"type":"text","text":" "},{"text":"pick the type for the value it returns","type":"text"},{"type":"text","text":" "},{"type":"text","text":"in a way that’s abstracted away from the code that calls the function."},{"type":"text","text":" "},{"text":"For example, the function in the following example returns a trapezoid","type":"text"},{"type":"text","text":" "},{"type":"text","text":"without exposing the underlying type of that shape."}]},{"type":"codeListing","syntax":"swift","code":["struct Square: Shape {","    var size: Int","    func draw() -> String {","        let line = String(repeating: \"*\", count: size)","        let result = Array<String>(repeating: line, count: size)","        return result.joined(separator: \"\\n\")","    }","}","","func makeTrapezoid() -> some Shape {","    let top = Triangle(size: 2)","    let middle = Square(size: 2)","    let bottom = FlippedShape(shape: top)","    let trapezoid = JoinedShape(","        top: top,","        bottom: JoinedShape(top: middle, bottom: bottom)","    )","    return trapezoid","}","let trapezoid = makeTrapezoid()","print(trapezoid.draw())","\/\/ *","\/\/ **","\/\/ **","\/\/ **","\/\/ **","\/\/ *"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"makeTrapezoid()"},{"text":" function in this example","type":"text"},{"type":"text","text":" "},{"type":"text","text":"declares its return type as "},{"type":"codeVoice","code":"some Shape"},{"text":";","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"as a result, the function"},{"text":" ","type":"text"},{"text":"returns a value of some given type that conforms to the ","type":"text"},{"code":"Shape","type":"codeVoice"},{"type":"text","text":" protocol,"},{"text":" ","type":"text"},{"text":"without specifying any particular concrete type.","type":"text"},{"type":"text","text":" "},{"text":"Writing ","type":"text"},{"type":"codeVoice","code":"makeTrapezoid()"},{"text":" this way lets it express","type":"text"},{"text":" ","type":"text"},{"text":"the fundamental aspect of its public interface —","type":"text"},{"type":"text","text":" "},{"text":"the value it returns is a shape —","type":"text"},{"type":"text","text":" "},{"text":"without making the specific types that the shape is made from","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"a part of its public interface."},{"type":"text","text":" "},{"text":"This implementation uses two triangles and a square,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"but the function could be rewritten to draw a trapezoid"},{"type":"text","text":" "},{"type":"text","text":"in a variety of other ways"},{"text":" ","type":"text"},{"text":"without changing its return type.","type":"text"}]},{"inlineContent":[{"text":"This example highlights the way that an opaque return type","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"is like the reverse of a generic type."},{"type":"text","text":" "},{"text":"The code inside ","type":"text"},{"type":"codeVoice","code":"makeTrapezoid()"},{"type":"text","text":" can return any type it needs to,"},{"text":" ","type":"text"},{"type":"text","text":"as long as that type conforms to the "},{"code":"Shape","type":"codeVoice"},{"type":"text","text":" protocol,"},{"type":"text","text":" "},{"type":"text","text":"like the calling code does for a generic function."},{"type":"text","text":" "},{"type":"text","text":"The code that calls the function needs to be written in a general way,"},{"text":" ","type":"text"},{"text":"like the implementation of a generic function,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"so that it can work with any "},{"code":"Shape","type":"codeVoice"},{"type":"text","text":" value"},{"type":"text","text":" "},{"type":"text","text":"that’s returned by "},{"code":"makeTrapezoid()","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can also combine opaque return types with generics."},{"type":"text","text":" "},{"type":"text","text":"The functions in the following code both return a value"},{"type":"text","text":" "},{"type":"text","text":"of some type that conforms to the "},{"type":"codeVoice","code":"Shape"},{"text":" protocol.","type":"text"}]},{"type":"codeListing","code":["func flip<T: Shape>(_ shape: T) -> some Shape {","    return FlippedShape(shape: shape)","}","func join<T: Shape, U: Shape>(_ top: T, _ bottom: U) -> some Shape {","    JoinedShape(top: top, bottom: bottom)","}","","let opaqueJoinedTriangles = join(smallTriangle, flip(smallTriangle))","print(opaqueJoinedTriangles.draw())","\/\/ *","\/\/ **","\/\/ ***","\/\/ ***","\/\/ **","\/\/ *"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The value of "},{"code":"opaqueJoinedTriangles","type":"codeVoice"},{"text":" in this example","type":"text"},{"type":"text","text":" "},{"text":"is the same as ","type":"text"},{"code":"joinedTriangles","type":"codeVoice"},{"type":"text","text":" in the generics example"},{"type":"text","text":" "},{"type":"text","text":"in the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes#The-Problem-That-Opaque-Types-Solve"},{"type":"text","text":" section earlier in this chapter."},{"type":"text","text":" "},{"text":"However, unlike the value in that example,","type":"text"},{"text":" ","type":"text"},{"code":"flip(_:)","type":"codeVoice"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"join(_:_:)"},{"type":"text","text":" wrap the underlying types"},{"type":"text","text":" "},{"type":"text","text":"that the generic shape operations return"},{"type":"text","text":" "},{"type":"text","text":"in an opaque return type,"},{"type":"text","text":" "},{"type":"text","text":"which prevents those types from being visible."},{"text":" ","type":"text"},{"text":"Both functions are generic because the types they rely on are generic,","type":"text"},{"type":"text","text":" "},{"text":"and the type parameters to the function","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"pass along the type information needed by "},{"code":"FlippedShape","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"JoinedShape"},{"text":".","type":"text"}]},{"inlineContent":[{"type":"text","text":"If a function with an opaque return type"},{"text":" ","type":"text"},{"text":"returns from multiple places,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"all of the possible return values must have the same type."},{"text":" ","type":"text"},{"type":"text","text":"For a generic function,"},{"type":"text","text":" "},{"type":"text","text":"that return type can use the function’s generic type parameters,"},{"text":" ","type":"text"},{"text":"but it must still be a single type.","type":"text"},{"text":" ","type":"text"},{"text":"For example,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"here’s an "},{"inlineContent":[{"text":"invalid","type":"text"}],"type":"emphasis"},{"type":"text","text":" version of the shape-flipping function"},{"text":" ","type":"text"},{"type":"text","text":"that includes a special case for squares:"}],"type":"paragraph"},{"type":"codeListing","code":["func invalidFlip<T: Shape>(_ shape: T) -> some Shape {","    if shape is Square {","        return shape \/\/ Error: return types don't match","    }","    return FlippedShape(shape: shape) \/\/ Error: return types don't match","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you call this function with a "},{"type":"codeVoice","code":"Square"},{"type":"text","text":", it returns a "},{"type":"codeVoice","code":"Square"},{"text":";","type":"text"},{"type":"text","text":" "},{"type":"text","text":"otherwise, it returns a "},{"type":"codeVoice","code":"FlippedShape"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"This violates the requirement to return values of only one type","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and makes "},{"code":"invalidFlip(_:)","type":"codeVoice"},{"type":"text","text":" invalid code."},{"text":" ","type":"text"},{"text":"One way to fix ","type":"text"},{"code":"invalidFlip(_:)","type":"codeVoice"},{"text":" is to move the special case for squares","type":"text"},{"text":" ","type":"text"},{"text":"into the implementation of ","type":"text"},{"code":"FlippedShape","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"which lets this function always return a "},{"type":"codeVoice","code":"FlippedShape"},{"text":" value:","type":"text"}]},{"code":["struct FlippedShape<T: Shape>: Shape {","    var shape: T","    func draw() -> String {","        if shape is Square {","           return shape.draw()","        }","        let lines = shape.draw().split(separator: \"\\n\")","        return lines.reversed().joined(separator: \"\\n\")","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"The requirement to always return a single type"},{"text":" ","type":"text"},{"type":"text","text":"doesn’t prevent you from using generics in an opaque return type."},{"type":"text","text":" "},{"type":"text","text":"Here’s an example of a function that incorporates its type parameter"},{"type":"text","text":" "},{"text":"into the underlying type of the value it returns:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["func `repeat`<T: Shape>(shape: T, count: Int) -> some Collection {","    return Array<T>(repeating: shape, count: count)","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this case,"},{"type":"text","text":" "},{"text":"the underlying type of the return value","type":"text"},{"type":"text","text":" "},{"text":"varies depending on ","type":"text"},{"type":"codeVoice","code":"T"},{"text":":","type":"text"},{"type":"text","text":" "},{"text":"Whatever shape is passed it,","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"repeat(shape:count:)"},{"text":" creates and returns an array of that shape.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Nevertheless,"},{"type":"text","text":" "},{"type":"text","text":"the return value always has the same underlying type of "},{"code":"[T]","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"so it follows the requirement that functions with opaque return types"},{"type":"text","text":" "},{"type":"text","text":"must return values of only a single type."}]},{"level":2,"type":"heading","anchor":"Boxed-Protocol-Types","text":"Boxed Protocol Types"},{"inlineContent":[{"type":"text","text":"A boxed protocol type is also sometimes called an "},{"inlineContent":[{"text":"existential type","type":"text"}],"type":"emphasis"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"which comes from the phrase"},{"type":"text","text":" "},{"text":"“there exists a type ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"T"}]},{"type":"text","text":" such that "},{"inlineContent":[{"type":"text","text":"T"}],"type":"emphasis"},{"text":" conforms to the protocol”.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"To make a boxed protocol type,"},{"text":" ","type":"text"},{"type":"text","text":"write "},{"type":"codeVoice","code":"any"},{"type":"text","text":" before the name of a protocol."},{"type":"text","text":" "},{"text":"Here’s an example:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["struct VerticalShapes: Shape {","    var shapes: [any Shape]","    func draw() -> String {","        return shapes.map { $0.draw() }.joined(separator: \"\\n\\n\")","    }","}","","let largeTriangle = Triangle(size: 5)","let largeSquare = Square(size: 5)","let vertical = VerticalShapes(shapes: [largeTriangle, largeSquare])","print(vertical.draw())"]},{"type":"paragraph","inlineContent":[{"text":"In the example above,","type":"text"},{"type":"text","text":" "},{"code":"VerticalShapes","type":"codeVoice"},{"type":"text","text":" declares the type of "},{"code":"shapes","type":"codeVoice"},{"text":" as ","type":"text"},{"type":"codeVoice","code":"[any Shape]"},{"type":"text","text":" —"},{"type":"text","text":" "},{"type":"text","text":"an array of boxed "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" elements."},{"type":"text","text":" "},{"type":"text","text":"Each element in the array can be a different type,"},{"text":" ","type":"text"},{"text":"and each of those types must conform to the ","type":"text"},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" protocol."},{"type":"text","text":" "},{"type":"text","text":"To support this runtime flexibility,"},{"type":"text","text":" "},{"type":"text","text":"Swift adds a level of indirection when necessary —"},{"text":" ","type":"text"},{"text":"this indirection is called a ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"box"}]},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"and it has a performance cost.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Within the ","type":"text"},{"code":"VerticalShapes","type":"codeVoice"},{"text":" type,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the code can use methods, properties, and subscripts"},{"type":"text","text":" "},{"text":"that are required by the ","type":"text"},{"type":"codeVoice","code":"Shape"},{"text":" protocol.","type":"text"},{"text":" ","type":"text"},{"text":"For example, the ","type":"text"},{"code":"draw()","type":"codeVoice"},{"text":" method of ","type":"text"},{"code":"VerticalShapes","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"calls the "},{"code":"draw()","type":"codeVoice"},{"text":" method on each element of the array.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This method is available because "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" requires a "},{"type":"codeVoice","code":"draw()"},{"type":"text","text":" method."},{"type":"text","text":" "},{"type":"text","text":"In contrast,"},{"type":"text","text":" "},{"type":"text","text":"trying to access the "},{"type":"codeVoice","code":"size"},{"type":"text","text":" property of the triangle,"},{"text":" ","type":"text"},{"text":"or any other properties or methods that aren’t required by ","type":"text"},{"type":"codeVoice","code":"Shape"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"produces an error."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Contrast the three types you could use for "},{"type":"codeVoice","code":"shapes"},{"text":":","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Using generics,"},{"text":" ","type":"text"},{"type":"text","text":"by writing "},{"code":"struct VerticalShapes<S: Shape>","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"var shapes: [S]"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"makes an array whose elements are some specific shape type,"},{"text":" ","type":"text"},{"text":"and where the identity of that specific type","type":"text"},{"type":"text","text":" "},{"text":"is visible to any code that interacts with the array.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Using an opaque type,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"by writing "},{"type":"codeVoice","code":"var shapes: [some Shape]"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"makes an array whose elements are some specific shape type,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and where that specific type’s identity is hidden."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Using a boxed protocol type,"},{"type":"text","text":" "},{"type":"text","text":"by writing "},{"code":"var shapes: [any Shape]","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"makes an array that can store elements of different types,"},{"type":"text","text":" "},{"text":"and where those types’ identities are hidden.","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this case,"},{"text":" ","type":"text"},{"type":"text","text":"a boxed protocol type is the only approach"},{"type":"text","text":" "},{"text":"that lets callers of ","type":"text"},{"type":"codeVoice","code":"VerticalShapes"},{"type":"text","text":" mix different kinds of shapes together."}]},{"type":"paragraph","inlineContent":[{"text":"You can use an ","type":"text"},{"code":"as","type":"codeVoice"},{"type":"text","text":" cast"},{"text":" ","type":"text"},{"type":"text","text":"when you know the underlying type of a boxed value."},{"text":" ","type":"text"},{"text":"For example:","type":"text"}]},{"syntax":"swift","code":["if let downcastTriangle = vertical.shapes[0] as? Triangle {","    print(downcastTriangle.size)","}","\/\/ Prints \"5\""],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"For more information, see "},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting#Downcasting","isActive":true,"type":"reference"},{"type":"text","text":"."}],"type":"paragraph"},{"text":"Differences Between Opaque Types and Boxed Protocol Types","level":2,"type":"heading","anchor":"Differences-Between-Opaque-Types-and-Boxed-Protocol-Types"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Returning an opaque type looks very similar"},{"type":"text","text":" "},{"text":"to using a boxed protocol type as the return type of a function,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"but these two kinds of return type differ in"},{"type":"text","text":" "},{"text":"whether they preserve type identity.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"An opaque type refers to one specific type,"},{"type":"text","text":" "},{"type":"text","text":"although the caller of the function isn’t able to see which type;"},{"text":" ","type":"text"},{"type":"text","text":"a boxed protocol type can refer to any type that conforms to the protocol."},{"type":"text","text":" "},{"text":"Generally speaking,","type":"text"},{"text":" ","type":"text"},{"text":"boxed protocol types give you more flexibility","type":"text"},{"type":"text","text":" "},{"text":"about the underlying types of the values they store,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and opaque types let you make stronger guarantees"},{"type":"text","text":" "},{"type":"text","text":"about those underlying types."}]},{"inlineContent":[{"type":"text","text":"For example,"},{"type":"text","text":" "},{"text":"here’s a version of ","type":"text"},{"type":"codeVoice","code":"flip(_:)"},{"type":"text","text":" "},{"type":"text","text":"that uses a boxed protocol type as its return type"},{"type":"text","text":" "},{"type":"text","text":"instead of an opaque return type:"}],"type":"paragraph"},{"code":["func protoFlip<T: Shape>(_ shape: T) -> Shape {","    return FlippedShape(shape: shape)","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"This version of ","type":"text"},{"type":"codeVoice","code":"protoFlip(_:)"},{"text":" ","type":"text"},{"type":"text","text":"has the same body as "},{"type":"codeVoice","code":"flip(_:)"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"and it always returns a value of the same type.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Unlike "},{"code":"flip(_:)","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"the value that ","type":"text"},{"type":"codeVoice","code":"protoFlip(_:)"},{"type":"text","text":" returns isn’t required"},{"text":" ","type":"text"},{"type":"text","text":"to always have the same type —"},{"text":" ","type":"text"},{"type":"text","text":"it just has to conform to the "},{"code":"Shape","type":"codeVoice"},{"type":"text","text":" protocol."},{"type":"text","text":" "},{"text":"Put another way,","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"protoFlip(_:)"},{"text":" makes a much looser API contract with its caller","type":"text"},{"type":"text","text":" "},{"type":"text","text":"than "},{"code":"flip(_:)","type":"codeVoice"},{"type":"text","text":" makes."},{"type":"text","text":" "},{"text":"It reserves the flexibility to return values of multiple types:","type":"text"}]},{"code":["func protoFlip<T: Shape>(_ shape: T) -> Shape {","    if shape is Square {","        return shape","    }","","    return FlippedShape(shape: shape)","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The revised version of the code returns"},{"type":"text","text":" "},{"text":"an instance of ","type":"text"},{"type":"codeVoice","code":"Square"},{"text":" or an instance of ","type":"text"},{"type":"codeVoice","code":"FlippedShape"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"depending on what shape is passed in."},{"type":"text","text":" "},{"type":"text","text":"Two flipped shapes returned by this function"},{"type":"text","text":" "},{"text":"might have completely different types.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Other valid versions of this function could return values of different types"},{"text":" ","type":"text"},{"type":"text","text":"when flipping multiple instances of the same shape."},{"text":" ","type":"text"},{"type":"text","text":"The less specific return type information from "},{"code":"protoFlip(_:)","type":"codeVoice"},{"type":"text","text":" means that"},{"text":" ","type":"text"},{"type":"text","text":"many operations that depend on type information"},{"type":"text","text":" "},{"type":"text","text":"aren’t available on the returned value."},{"text":" ","type":"text"},{"type":"text","text":"For example, it’s not possible to write an "},{"code":"==","type":"codeVoice"},{"text":" operator","type":"text"},{"type":"text","text":" "},{"text":"comparing results returned by this function.","type":"text"}]},{"type":"codeListing","code":["let protoFlippedTriangle = protoFlip(smallTriangle)","let sameThing = protoFlip(smallTriangle)","protoFlippedTriangle == sameThing  \/\/ Error"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The error on the last line of the example occurs for several reasons."},{"type":"text","text":" "},{"type":"text","text":"The immediate issue is that the "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" doesn’t include an "},{"type":"codeVoice","code":"=="},{"type":"text","text":" operator"},{"type":"text","text":" "},{"text":"as part of its protocol requirements.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"If you try adding one, the next issue you’ll encounter"},{"type":"text","text":" "},{"type":"text","text":"is that the "},{"type":"codeVoice","code":"=="},{"text":" operator needs to know","type":"text"},{"type":"text","text":" "},{"text":"the types of its left-hand and right-hand arguments.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"This sort of operator usually takes arguments of type "},{"code":"Self","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"matching whatever concrete type adopts the protocol,"},{"type":"text","text":" "},{"text":"but adding a ","type":"text"},{"type":"codeVoice","code":"Self"},{"text":" requirement to the protocol","type":"text"},{"type":"text","text":" "},{"text":"doesn’t allow for the type erasure that happens","type":"text"},{"type":"text","text":" "},{"text":"when you use the protocol as a type.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Using a boxed protocol type as the return type for a function"},{"text":" ","type":"text"},{"text":"gives you the flexibility to return any type that conforms to the protocol.","type":"text"},{"type":"text","text":" "},{"text":"However, the cost of that flexibility","type":"text"},{"text":" ","type":"text"},{"text":"is that some operations aren’t possible on the returned values.","type":"text"},{"text":" ","type":"text"},{"text":"The example shows how the ","type":"text"},{"code":"==","type":"codeVoice"},{"type":"text","text":" operator isn’t available —"},{"type":"text","text":" "},{"type":"text","text":"it depends on specific type information"},{"text":" ","type":"text"},{"text":"that isn’t preserved by using a boxed protocol type.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Another problem with this approach is that the shape transformations don’t nest.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The result of flipping a triangle is a value of type "},{"code":"Shape","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"and the ","type":"text"},{"type":"codeVoice","code":"protoFlip(_:)"},{"type":"text","text":" function takes an argument"},{"type":"text","text":" "},{"type":"text","text":"of some type that conforms to the "},{"code":"Shape","type":"codeVoice"},{"text":" protocol.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"However, a value of a boxed protocol type doesn’t conform to that protocol;"},{"type":"text","text":" "},{"text":"the value returned by ","type":"text"},{"code":"protoFlip(_:)","type":"codeVoice"},{"type":"text","text":" doesn’t conform to "},{"code":"Shape","type":"codeVoice"},{"text":".","type":"text"},{"type":"text","text":" "},{"text":"This means code like ","type":"text"},{"code":"protoFlip(protoFlip(smallTriangle))","type":"codeVoice"},{"text":" ","type":"text"},{"text":"that applies multiple transformations is invalid","type":"text"},{"type":"text","text":" "},{"type":"text","text":"because the flipped shape isn’t a valid argument to "},{"code":"protoFlip(_:)","type":"codeVoice"},{"type":"text","text":"."}]},{"inlineContent":[{"type":"text","text":"In contrast,"},{"type":"text","text":" "},{"text":"opaque types preserve the identity of the underlying type.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Swift can infer associated types,"},{"type":"text","text":" "},{"type":"text","text":"which lets you use an opaque return value"},{"type":"text","text":" "},{"text":"in places where a boxed protocol type can’t be used as a return value.","type":"text"},{"text":" ","type":"text"},{"text":"For example,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"here’s a version of the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol from "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics"},{"text":":","type":"text"}],"type":"paragraph"},{"code":["protocol Container {","    associatedtype Item","    var count: Int { get }","    subscript(i: Int) -> Item { get }","}","extension Array: Container { }"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"You can’t use ","type":"text"},{"type":"codeVoice","code":"Container"},{"text":" as the return type of a function","type":"text"},{"type":"text","text":" "},{"type":"text","text":"because that protocol has an associated type."},{"type":"text","text":" "},{"type":"text","text":"You also can’t use it as constraint in a generic return type"},{"text":" ","type":"text"},{"type":"text","text":"because there isn’t enough information outside the function body"},{"type":"text","text":" "},{"text":"to infer what the generic type needs to be.","type":"text"}],"type":"paragraph"},{"code":["\/\/ Error: Protocol with associated types can't be used as a return type.","func makeProtocolContainer<T>(item: T) -> Container {","    return [item]","}","","\/\/ Error: Not enough information to infer C.","func makeProtocolContainer<T, C: Container>(item: T) -> C {","    return [item]","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Using the opaque type ","type":"text"},{"type":"codeVoice","code":"some Container"},{"type":"text","text":" as a return type"},{"text":" ","type":"text"},{"type":"text","text":"expresses the desired API contract — the function returns a container,"},{"text":" ","type":"text"},{"type":"text","text":"but declines to specify the container’s type:"}]},{"type":"codeListing","code":["func makeOpaqueContainer<T>(item: T) -> some Container {","    return [item]","}","let opaqueContainer = makeOpaqueContainer(item: 12)","let twelve = opaqueContainer[0]","print(type(of: twelve))","\/\/ Prints \"Int\""],"syntax":"swift"},{"inlineContent":[{"text":"The type of ","type":"text"},{"type":"codeVoice","code":"twelve"},{"type":"text","text":" is inferred to be "},{"code":"Int","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"which illustrates the fact that type inference works with opaque types.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"In the implementation of "},{"code":"makeOpaqueContainer(item:)","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"the underlying type of the opaque container is ","type":"text"},{"code":"[T]","type":"codeVoice"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"In this case, "},{"type":"codeVoice","code":"T"},{"text":" is ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"so the return value is an array of integers","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and the "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" associated type is inferred to be "},{"type":"codeVoice","code":"Int"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"The subscript on ","type":"text"},{"code":"Container","type":"codeVoice"},{"type":"text","text":" returns "},{"type":"codeVoice","code":"Item"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"which means that the type of ","type":"text"},{"code":"twelve","type":"codeVoice"},{"type":"text","text":" is also inferred to be "},{"type":"codeVoice","code":"Int"},{"text":".","type":"text"}],"type":"paragraph"}]}],"schemaVersion":{"minor":3,"major":0,"patch":0},"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"abstract":[{"text":"Hide implementation details about a value’s type.","type":"text"}],"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Generics":{"title":"Generics","role":"article","abstract":[{"text":"Write code that works for multiple types and specify requirements for those types.","type":"text"}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","url":"\/documentation\/the-swift-programming-language\/generics","kind":"article","type":"topic"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"abstract":[],"role":"collection","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language","kind":"article","type":"topic","title":"The Swift Programming Language (5.9.2)","url":"\/documentation\/the-swift-programming-language"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/OpaqueTypes#The-Problem-That-Opaque-Types-Solve":{"abstract":[],"kind":"section","title":"The Problem That Opaque Types Solve","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes#The-Problem-That-Opaque-Types-Solve","url":"\/documentation\/the-swift-programming-language\/opaquetypes#The-Problem-That-Opaque-Types-Solve","type":"topic"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TypeCasting#Downcasting":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting#Downcasting","url":"\/documentation\/the-swift-programming-language\/typecasting#Downcasting","abstract":[],"kind":"section","title":"Downcasting","type":"topic"}}}