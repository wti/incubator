{"schemaVersion":{"major":0,"minor":3,"patch":0},"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes","interfaceLanguage":"swift"},"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"metadata":{"title":"Opaque and Boxed Types"},"sections":[],"abstract":[{"type":"text","text":"Hide implementation details about a value’s type."}],"primaryContentSections":[{"kind":"content","content":[{"inlineContent":[{"type":"text","text":"Swift provides two ways to hide details about a value’s type:"},{"type":"text","text":" "},{"type":"text","text":"opaque types and boxed protocol types."},{"type":"text","text":" "},{"text":"Hiding type information","type":"text"},{"text":" ","type":"text"},{"text":"is useful at boundaries between","type":"text"},{"type":"text","text":" "},{"text":"a module and code that calls into the module,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"because the underlying type of the return value can remain private."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A function or method that returns an opaque type"},{"type":"text","text":" "},{"type":"text","text":"hides its return value’s type information."},{"type":"text","text":" "},{"type":"text","text":"Instead of providing a concrete type as the function’s return type,"},{"type":"text","text":" "},{"type":"text","text":"the return value is described in terms of the protocols it supports."},{"type":"text","text":" "},{"type":"text","text":"Opaque types preserve type identity —"},{"type":"text","text":" "},{"text":"the compiler has access to the type information,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"but clients of the module don’t."}]},{"inlineContent":[{"text":"A boxed protocol type can store an instance of any type","type":"text"},{"type":"text","text":" "},{"text":"that conforms to the given protocol.","type":"text"},{"type":"text","text":" "},{"text":"Boxed protocol types don’t preserve type identity —","type":"text"},{"type":"text","text":" "},{"text":"the value’s specific type isn’t known until runtime,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and it can change over time as different values are stored."}],"type":"paragraph"},{"text":"The Problem That Opaque Types Solve","level":2,"anchor":"The-Problem-That-Opaque-Types-Solve","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example,"},{"text":" ","type":"text"},{"text":"suppose you’re writing a module that draws ASCII art shapes.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The basic characteristic of an ASCII art shape"},{"text":" ","type":"text"},{"type":"text","text":"is a "},{"type":"codeVoice","code":"draw()"},{"type":"text","text":" function that returns the string representation of that shape,"},{"type":"text","text":" "},{"type":"text","text":"which you can use as the requirement for the "},{"type":"codeVoice","code":"Shape"},{"text":" protocol:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["protocol Shape {","    func draw() -> String","}","","struct Triangle: Shape {","    var size: Int","    func draw() -> String {","       var result: [String] = []","       for length in 1...size {","           result.append(String(repeating: \"*\", count: length))","       }","       return result.joined(separator: \"\\n\")","    }","}","let smallTriangle = Triangle(size: 3)","print(smallTriangle.draw())","\/\/ *","\/\/ **","\/\/ ***"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You could use generics to implement operations like flipping a shape vertically,"},{"text":" ","type":"text"},{"text":"as shown in the code below.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"However, there’s an important limitation to this approach:"},{"text":" ","type":"text"},{"type":"text","text":"The flipped result exposes the exact generic types"},{"type":"text","text":" "},{"text":"that were used to create it.","type":"text"}]},{"code":["struct FlippedShape<T: Shape>: Shape {","    var shape: T","    func draw() -> String {","        let lines = shape.draw().split(separator: \"\\n\")","        return lines.reversed().joined(separator: \"\\n\")","    }","}","let flippedTriangle = FlippedShape(shape: smallTriangle)","print(flippedTriangle.draw())","\/\/ ***","\/\/ **","\/\/ *"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"This approach to defining a "},{"type":"codeVoice","code":"JoinedShape<T: Shape, U: Shape>"},{"type":"text","text":" structure"},{"text":" ","type":"text"},{"type":"text","text":"that joins two shapes together vertically, like the code below shows,"},{"text":" ","type":"text"},{"type":"text","text":"results in types like "},{"code":"JoinedShape<FlippedShape<Triangle>, Triangle>","type":"codeVoice"},{"type":"text","text":" "},{"text":"from joining a flipped triangle with another triangle.","type":"text"}],"type":"paragraph"},{"code":["struct JoinedShape<T: Shape, U: Shape>: Shape {","    var top: T","    var bottom: U","    func draw() -> String {","       return top.draw() + \"\\n\" + bottom.draw()","    }","}","let joinedTriangles = JoinedShape(top: smallTriangle, bottom: flippedTriangle)","print(joinedTriangles.draw())","\/\/ *","\/\/ **","\/\/ ***","\/\/ ***","\/\/ **","\/\/ *"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Exposing detailed information about the creation of a shape"},{"text":" ","type":"text"},{"type":"text","text":"allows types that aren’t meant to be"},{"type":"text","text":" "},{"type":"text","text":"part of the ASCII art module’s public interface"},{"type":"text","text":" "},{"type":"text","text":"to leak out because of the need to state the full return type."},{"text":" ","type":"text"},{"type":"text","text":"The code inside the module"},{"text":" ","type":"text"},{"text":"could build up the same shape in a variety of ways,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and other code outside the module"},{"type":"text","text":" "},{"text":"that uses the shape shouldn’t have to account for","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the implementation details about the list of transformations."},{"text":" ","type":"text"},{"type":"text","text":"Wrapper types like "},{"type":"codeVoice","code":"JoinedShape"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"FlippedShape"},{"text":" ","type":"text"},{"text":"don’t matter to the module’s users,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and they shouldn’t be visible."},{"type":"text","text":" "},{"type":"text","text":"The module’s public interface"},{"type":"text","text":" "},{"text":"consists of operations like joining and flipping a shape,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and those operations return another "},{"code":"Shape","type":"codeVoice"},{"type":"text","text":" value."}]},{"level":2,"anchor":"Returning-an-Opaque-Type","type":"heading","text":"Returning an Opaque Type"},{"type":"paragraph","inlineContent":[{"text":"You can think of an opaque type like being the reverse of a generic type.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Generic types let the code that calls a function"},{"type":"text","text":" "},{"type":"text","text":"pick the type for that function’s parameters and return value"},{"text":" ","type":"text"},{"text":"in a way that’s abstracted away from the function implementation.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For example, the function in the following code"},{"text":" ","type":"text"},{"text":"returns a type that depends on its caller:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["func max<T>(_ x: T, _ y: T) -> T where T: Comparable { ... }"]},{"inlineContent":[{"type":"text","text":"The code that calls "},{"code":"max(_:_:)","type":"codeVoice"},{"text":" chooses the values for ","type":"text"},{"type":"codeVoice","code":"x"},{"text":" and ","type":"text"},{"code":"y","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and the type of those values determines the concrete type of "},{"type":"codeVoice","code":"T"},{"type":"text","text":"."},{"text":" ","type":"text"},{"text":"The calling code can use any type","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"that conforms to the "},{"type":"codeVoice","code":"Comparable"},{"text":" protocol.","type":"text"},{"text":" ","type":"text"},{"text":"The code inside the function is written in a general way","type":"text"},{"type":"text","text":" "},{"type":"text","text":"so it can handle whatever type the caller provides."},{"text":" ","type":"text"},{"text":"The implementation of ","type":"text"},{"code":"max(_:_:)","type":"codeVoice"},{"type":"text","text":" uses only functionality"},{"type":"text","text":" "},{"type":"text","text":"that all "},{"code":"Comparable","type":"codeVoice"},{"type":"text","text":" types share."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Those roles are reversed for a function with an opaque return type."},{"text":" ","type":"text"},{"type":"text","text":"An opaque type lets the function implementation"},{"text":" ","type":"text"},{"text":"pick the type for the value it returns","type":"text"},{"type":"text","text":" "},{"type":"text","text":"in a way that’s abstracted away from the code that calls the function."},{"text":" ","type":"text"},{"type":"text","text":"For example, the function in the following example returns a trapezoid"},{"type":"text","text":" "},{"text":"without exposing the underlying type of that shape.","type":"text"}],"type":"paragraph"},{"code":["struct Square: Shape {","    var size: Int","    func draw() -> String {","        let line = String(repeating: \"*\", count: size)","        let result = Array<String>(repeating: line, count: size)","        return result.joined(separator: \"\\n\")","    }","}","","func makeTrapezoid() -> some Shape {","    let top = Triangle(size: 2)","    let middle = Square(size: 2)","    let bottom = FlippedShape(shape: top)","    let trapezoid = JoinedShape(","        top: top,","        bottom: JoinedShape(top: middle, bottom: bottom)","    )","    return trapezoid","}","let trapezoid = makeTrapezoid()","print(trapezoid.draw())","\/\/ *","\/\/ **","\/\/ **","\/\/ **","\/\/ **","\/\/ *"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"makeTrapezoid()"},{"text":" function in this example","type":"text"},{"type":"text","text":" "},{"type":"text","text":"declares its return type as "},{"code":"some Shape","type":"codeVoice"},{"type":"text","text":";"},{"type":"text","text":" "},{"type":"text","text":"as a result, the function"},{"type":"text","text":" "},{"text":"returns a value of some given type that conforms to the ","type":"text"},{"code":"Shape","type":"codeVoice"},{"text":" protocol,","type":"text"},{"text":" ","type":"text"},{"text":"without specifying any particular concrete type.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Writing "},{"code":"makeTrapezoid()","type":"codeVoice"},{"type":"text","text":" this way lets it express"},{"text":" ","type":"text"},{"type":"text","text":"the fundamental aspect of its public interface —"},{"type":"text","text":" "},{"text":"the value it returns is a shape —","type":"text"},{"type":"text","text":" "},{"text":"without making the specific types that the shape is made from","type":"text"},{"type":"text","text":" "},{"type":"text","text":"a part of its public interface."},{"text":" ","type":"text"},{"type":"text","text":"This implementation uses two triangles and a square,"},{"type":"text","text":" "},{"text":"but the function could be rewritten to draw a trapezoid","type":"text"},{"type":"text","text":" "},{"type":"text","text":"in a variety of other ways"},{"type":"text","text":" "},{"text":"without changing its return type.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example highlights the way that an opaque return type"},{"type":"text","text":" "},{"type":"text","text":"is like the reverse of a generic type."},{"text":" ","type":"text"},{"text":"The code inside ","type":"text"},{"type":"codeVoice","code":"makeTrapezoid()"},{"text":" can return any type it needs to,","type":"text"},{"text":" ","type":"text"},{"text":"as long as that type conforms to the ","type":"text"},{"code":"Shape","type":"codeVoice"},{"text":" protocol,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"like the calling code does for a generic function."},{"type":"text","text":" "},{"text":"The code that calls the function needs to be written in a general way,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"like the implementation of a generic function,"},{"type":"text","text":" "},{"text":"so that it can work with any ","type":"text"},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" value"},{"text":" ","type":"text"},{"text":"that’s returned by ","type":"text"},{"type":"codeVoice","code":"makeTrapezoid()"},{"type":"text","text":"."}]},{"inlineContent":[{"text":"You can also combine opaque return types with generics.","type":"text"},{"type":"text","text":" "},{"text":"The functions in the following code both return a value","type":"text"},{"type":"text","text":" "},{"text":"of some type that conforms to the ","type":"text"},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" protocol."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["func flip<T: Shape>(_ shape: T) -> some Shape {","    return FlippedShape(shape: shape)","}","func join<T: Shape, U: Shape>(_ top: T, _ bottom: U) -> some Shape {","    JoinedShape(top: top, bottom: bottom)","}","","let opaqueJoinedTriangles = join(smallTriangle, flip(smallTriangle))","print(opaqueJoinedTriangles.draw())","\/\/ *","\/\/ **","\/\/ ***","\/\/ ***","\/\/ **","\/\/ *"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The value of "},{"type":"codeVoice","code":"opaqueJoinedTriangles"},{"text":" in this example","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"is the same as "},{"code":"joinedTriangles","type":"codeVoice"},{"text":" in the generics example","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"in the "},{"isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes#The-Problem-That-Opaque-Types-Solve","type":"reference"},{"type":"text","text":" section earlier in this chapter."},{"type":"text","text":" "},{"text":"However, unlike the value in that example,","type":"text"},{"type":"text","text":" "},{"code":"flip(_:)","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"join(_:_:)","type":"codeVoice"},{"type":"text","text":" wrap the underlying types"},{"text":" ","type":"text"},{"type":"text","text":"that the generic shape operations return"},{"text":" ","type":"text"},{"type":"text","text":"in an opaque return type,"},{"type":"text","text":" "},{"type":"text","text":"which prevents those types from being visible."},{"text":" ","type":"text"},{"type":"text","text":"Both functions are generic because the types they rely on are generic,"},{"type":"text","text":" "},{"text":"and the type parameters to the function","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"pass along the type information needed by "},{"code":"FlippedShape","type":"codeVoice"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"JoinedShape"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"text":"If a function with an opaque return type","type":"text"},{"type":"text","text":" "},{"text":"returns from multiple places,","type":"text"},{"type":"text","text":" "},{"text":"all of the possible return values must have the same type.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For a generic function,"},{"text":" ","type":"text"},{"text":"that return type can use the function’s generic type parameters,","type":"text"},{"text":" ","type":"text"},{"text":"but it must still be a single type.","type":"text"},{"type":"text","text":" "},{"text":"For example,","type":"text"},{"type":"text","text":" "},{"text":"here’s an ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"invalid","type":"text"}]},{"type":"text","text":" version of the shape-flipping function"},{"text":" ","type":"text"},{"type":"text","text":"that includes a special case for squares:"}]},{"syntax":"swift","code":["func invalidFlip<T: Shape>(_ shape: T) -> some Shape {","    if shape is Square {","        return shape \/\/ Error: return types don't match","    }","    return FlippedShape(shape: shape) \/\/ Error: return types don't match","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"If you call this function with a "},{"code":"Square","type":"codeVoice"},{"text":", it returns a ","type":"text"},{"type":"codeVoice","code":"Square"},{"text":";","type":"text"},{"text":" ","type":"text"},{"text":"otherwise, it returns a ","type":"text"},{"code":"FlippedShape","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"This violates the requirement to return values of only one type","type":"text"},{"text":" ","type":"text"},{"text":"and makes ","type":"text"},{"code":"invalidFlip(_:)","type":"codeVoice"},{"text":" invalid code.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"One way to fix "},{"type":"codeVoice","code":"invalidFlip(_:)"},{"type":"text","text":" is to move the special case for squares"},{"text":" ","type":"text"},{"type":"text","text":"into the implementation of "},{"code":"FlippedShape","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"which lets this function always return a "},{"type":"codeVoice","code":"FlippedShape"},{"text":" value:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["struct FlippedShape<T: Shape>: Shape {","    var shape: T","    func draw() -> String {","        if shape is Square {","           return shape.draw()","        }","        let lines = shape.draw().split(separator: \"\\n\")","        return lines.reversed().joined(separator: \"\\n\")","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"The requirement to always return a single type","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"doesn’t prevent you from using generics in an opaque return type."},{"type":"text","text":" "},{"text":"Here’s an example of a function that incorporates its type parameter","type":"text"},{"text":" ","type":"text"},{"text":"into the underlying type of the value it returns:","type":"text"}]},{"type":"codeListing","code":["func `repeat`<T: Shape>(shape: T, count: Int) -> some Collection {","    return Array<T>(repeating: shape, count: count)","}"],"syntax":"swift"},{"inlineContent":[{"text":"In this case,","type":"text"},{"type":"text","text":" "},{"text":"the underlying type of the return value","type":"text"},{"type":"text","text":" "},{"type":"text","text":"varies depending on "},{"code":"T","type":"codeVoice"},{"text":":","type":"text"},{"type":"text","text":" "},{"text":"Whatever shape is passed it,","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"repeat(shape:count:)"},{"type":"text","text":" creates and returns an array of that shape."},{"type":"text","text":" "},{"type":"text","text":"Nevertheless,"},{"type":"text","text":" "},{"type":"text","text":"the return value always has the same underlying type of "},{"type":"codeVoice","code":"[T]"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"so it follows the requirement that functions with opaque return types","type":"text"},{"text":" ","type":"text"},{"text":"must return values of only a single type.","type":"text"}],"type":"paragraph"},{"level":2,"text":"Boxed Protocol Types","type":"heading","anchor":"Boxed-Protocol-Types"},{"type":"paragraph","inlineContent":[{"text":"A boxed protocol type is also sometimes called an ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"existential type","type":"text"}]},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which comes from the phrase"},{"text":" ","type":"text"},{"text":"“there exists a type ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"T"}]},{"type":"text","text":" such that "},{"inlineContent":[{"type":"text","text":"T"}],"type":"emphasis"},{"text":" conforms to the protocol”.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"To make a boxed protocol type,"},{"type":"text","text":" "},{"type":"text","text":"write "},{"code":"any","type":"codeVoice"},{"type":"text","text":" before the name of a protocol."},{"text":" ","type":"text"},{"text":"Here’s an example:","type":"text"}]},{"code":["struct VerticalShapes: Shape {","    var shapes: [any Shape]","    func draw() -> String {","        return shapes.map { $0.draw() }.joined(separator: \"\\n\\n\")","    }","}","","let largeTriangle = Triangle(size: 5)","let largeSquare = Square(size: 5)","let vertical = VerticalShapes(shapes: [largeTriangle, largeSquare])","print(vertical.draw())"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"In the example above,","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"VerticalShapes"},{"type":"text","text":" declares the type of "},{"type":"codeVoice","code":"shapes"},{"type":"text","text":" as "},{"type":"codeVoice","code":"[any Shape]"},{"type":"text","text":" —"},{"text":" ","type":"text"},{"text":"an array of boxed ","type":"text"},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" elements."},{"type":"text","text":" "},{"type":"text","text":"Each element in the array can be a different type,"},{"type":"text","text":" "},{"type":"text","text":"and each of those types must conform to the "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" protocol."},{"type":"text","text":" "},{"text":"To support this runtime flexibility,","type":"text"},{"type":"text","text":" "},{"text":"Swift adds a level of indirection when necessary —","type":"text"},{"type":"text","text":" "},{"type":"text","text":"this indirection is called a "},{"type":"emphasis","inlineContent":[{"text":"box","type":"text"}]},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"and it has a performance cost.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Within the "},{"type":"codeVoice","code":"VerticalShapes"},{"type":"text","text":" type,"},{"type":"text","text":" "},{"text":"the code can use methods, properties, and subscripts","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that are required by the "},{"code":"Shape","type":"codeVoice"},{"text":" protocol.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For example, the "},{"type":"codeVoice","code":"draw()"},{"type":"text","text":" method of "},{"type":"codeVoice","code":"VerticalShapes"},{"text":" ","type":"text"},{"type":"text","text":"calls the "},{"type":"codeVoice","code":"draw()"},{"type":"text","text":" method on each element of the array."},{"type":"text","text":" "},{"text":"This method is available because ","type":"text"},{"code":"Shape","type":"codeVoice"},{"type":"text","text":" requires a "},{"code":"draw()","type":"codeVoice"},{"text":" method.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"In contrast,"},{"text":" ","type":"text"},{"type":"text","text":"trying to access the "},{"type":"codeVoice","code":"size"},{"type":"text","text":" property of the triangle,"},{"text":" ","type":"text"},{"type":"text","text":"or any other properties or methods that aren’t required by "},{"code":"Shape","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"produces an error."}],"type":"paragraph"},{"inlineContent":[{"text":"Contrast the three types you could use for ","type":"text"},{"type":"codeVoice","code":"shapes"},{"text":":","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"Using generics,","type":"text"},{"type":"text","text":" "},{"text":"by writing ","type":"text"},{"type":"codeVoice","code":"struct VerticalShapes<S: Shape>"},{"text":" and ","type":"text"},{"code":"var shapes: [S]","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"makes an array whose elements are some specific shape type,"},{"text":" ","type":"text"},{"text":"and where the identity of that specific type","type":"text"},{"type":"text","text":" "},{"type":"text","text":"is visible to any code that interacts with the array."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Using an opaque type,"},{"type":"text","text":" "},{"type":"text","text":"by writing "},{"code":"var shapes: [some Shape]","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"makes an array whose elements are some specific shape type,"},{"text":" ","type":"text"},{"type":"text","text":"and where that specific type’s identity is hidden."}]}]},{"content":[{"inlineContent":[{"text":"Using a boxed protocol type,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"by writing "},{"code":"var shapes: [any Shape]","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"makes an array that can store elements of different types,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and where those types’ identities are hidden."}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"In this case,","type":"text"},{"text":" ","type":"text"},{"text":"a boxed protocol type is the only approach","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"that lets callers of "},{"type":"codeVoice","code":"VerticalShapes"},{"type":"text","text":" mix different kinds of shapes together."}]},{"inlineContent":[{"type":"text","text":"You can use an "},{"type":"codeVoice","code":"as"},{"text":" cast","type":"text"},{"type":"text","text":" "},{"text":"when you know the underlying type of a boxed value.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For example:"}],"type":"paragraph"},{"syntax":"swift","code":["if let downcastTriangle = vertical.shapes[0] as? Triangle {","    print(downcastTriangle.size)","}","\/\/ Prints \"5\""],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"For more information, see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting#Downcasting"},{"text":".","type":"text"}],"type":"paragraph"},{"anchor":"Differences-Between-Opaque-Types-and-Boxed-Protocol-Types","level":2,"type":"heading","text":"Differences Between Opaque Types and Boxed Protocol Types"},{"type":"paragraph","inlineContent":[{"text":"Returning an opaque type looks very similar","type":"text"},{"text":" ","type":"text"},{"text":"to using a boxed protocol type as the return type of a function,","type":"text"},{"type":"text","text":" "},{"text":"but these two kinds of return type differ in","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"whether they preserve type identity."},{"text":" ","type":"text"},{"text":"An opaque type refers to one specific type,","type":"text"},{"text":" ","type":"text"},{"text":"although the caller of the function isn’t able to see which type;","type":"text"},{"text":" ","type":"text"},{"text":"a boxed protocol type can refer to any type that conforms to the protocol.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Generally speaking,"},{"text":" ","type":"text"},{"type":"text","text":"boxed protocol types give you more flexibility"},{"text":" ","type":"text"},{"type":"text","text":"about the underlying types of the values they store,"},{"text":" ","type":"text"},{"text":"and opaque types let you make stronger guarantees","type":"text"},{"type":"text","text":" "},{"type":"text","text":"about those underlying types."}]},{"inlineContent":[{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"here’s a version of "},{"type":"codeVoice","code":"flip(_:)"},{"type":"text","text":" "},{"text":"that uses a boxed protocol type as its return type","type":"text"},{"type":"text","text":" "},{"text":"instead of an opaque return type:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["func protoFlip<T: Shape>(_ shape: T) -> Shape {","    return FlippedShape(shape: shape)","}"]},{"type":"paragraph","inlineContent":[{"text":"This version of ","type":"text"},{"type":"codeVoice","code":"protoFlip(_:)"},{"type":"text","text":" "},{"type":"text","text":"has the same body as "},{"type":"codeVoice","code":"flip(_:)"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"and it always returns a value of the same type."},{"type":"text","text":" "},{"text":"Unlike ","type":"text"},{"type":"codeVoice","code":"flip(_:)"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the value that "},{"code":"protoFlip(_:)","type":"codeVoice"},{"type":"text","text":" returns isn’t required"},{"type":"text","text":" "},{"text":"to always have the same type —","type":"text"},{"type":"text","text":" "},{"type":"text","text":"it just has to conform to the "},{"code":"Shape","type":"codeVoice"},{"text":" protocol.","type":"text"},{"type":"text","text":" "},{"text":"Put another way,","type":"text"},{"type":"text","text":" "},{"code":"protoFlip(_:)","type":"codeVoice"},{"text":" makes a much looser API contract with its caller","type":"text"},{"type":"text","text":" "},{"type":"text","text":"than "},{"code":"flip(_:)","type":"codeVoice"},{"text":" makes.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"It reserves the flexibility to return values of multiple types:"}]},{"code":["func protoFlip<T: Shape>(_ shape: T) -> Shape {","    if shape is Square {","        return shape","    }","","    return FlippedShape(shape: shape)","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The revised version of the code returns"},{"text":" ","type":"text"},{"type":"text","text":"an instance of "},{"code":"Square","type":"codeVoice"},{"text":" or an instance of ","type":"text"},{"code":"FlippedShape","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"depending on what shape is passed in."},{"type":"text","text":" "},{"type":"text","text":"Two flipped shapes returned by this function"},{"type":"text","text":" "},{"type":"text","text":"might have completely different types."},{"text":" ","type":"text"},{"type":"text","text":"Other valid versions of this function could return values of different types"},{"text":" ","type":"text"},{"text":"when flipping multiple instances of the same shape.","type":"text"},{"text":" ","type":"text"},{"text":"The less specific return type information from ","type":"text"},{"code":"protoFlip(_:)","type":"codeVoice"},{"type":"text","text":" means that"},{"type":"text","text":" "},{"type":"text","text":"many operations that depend on type information"},{"type":"text","text":" "},{"type":"text","text":"aren’t available on the returned value."},{"type":"text","text":" "},{"text":"For example, it’s not possible to write an ","type":"text"},{"type":"codeVoice","code":"=="},{"text":" operator","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"comparing results returned by this function."}]},{"syntax":"swift","type":"codeListing","code":["let protoFlippedTriangle = protoFlip(smallTriangle)","let sameThing = protoFlip(smallTriangle)","protoFlippedTriangle == sameThing  \/\/ Error"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The error on the last line of the example occurs for several reasons."},{"text":" ","type":"text"},{"type":"text","text":"The immediate issue is that the "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" doesn’t include an "},{"code":"==","type":"codeVoice"},{"type":"text","text":" operator"},{"type":"text","text":" "},{"type":"text","text":"as part of its protocol requirements."},{"type":"text","text":" "},{"text":"If you try adding one, the next issue you’ll encounter","type":"text"},{"type":"text","text":" "},{"text":"is that the ","type":"text"},{"type":"codeVoice","code":"=="},{"type":"text","text":" operator needs to know"},{"text":" ","type":"text"},{"type":"text","text":"the types of its left-hand and right-hand arguments."},{"type":"text","text":" "},{"text":"This sort of operator usually takes arguments of type ","type":"text"},{"code":"Self","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"matching whatever concrete type adopts the protocol,"},{"text":" ","type":"text"},{"type":"text","text":"but adding a "},{"code":"Self","type":"codeVoice"},{"type":"text","text":" requirement to the protocol"},{"text":" ","type":"text"},{"text":"doesn’t allow for the type erasure that happens","type":"text"},{"type":"text","text":" "},{"text":"when you use the protocol as a type.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Using a boxed protocol type as the return type for a function"},{"type":"text","text":" "},{"text":"gives you the flexibility to return any type that conforms to the protocol.","type":"text"},{"type":"text","text":" "},{"text":"However, the cost of that flexibility","type":"text"},{"type":"text","text":" "},{"type":"text","text":"is that some operations aren’t possible on the returned values."},{"type":"text","text":" "},{"text":"The example shows how the ","type":"text"},{"code":"==","type":"codeVoice"},{"type":"text","text":" operator isn’t available —"},{"text":" ","type":"text"},{"text":"it depends on specific type information","type":"text"},{"text":" ","type":"text"},{"text":"that isn’t preserved by using a boxed protocol type.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Another problem with this approach is that the shape transformations don’t nest."},{"text":" ","type":"text"},{"text":"The result of flipping a triangle is a value of type ","type":"text"},{"type":"codeVoice","code":"Shape"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"and the ","type":"text"},{"type":"codeVoice","code":"protoFlip(_:)"},{"type":"text","text":" function takes an argument"},{"type":"text","text":" "},{"type":"text","text":"of some type that conforms to the "},{"code":"Shape","type":"codeVoice"},{"type":"text","text":" protocol."},{"type":"text","text":" "},{"text":"However, a value of a boxed protocol type doesn’t conform to that protocol;","type":"text"},{"type":"text","text":" "},{"text":"the value returned by ","type":"text"},{"type":"codeVoice","code":"protoFlip(_:)"},{"text":" doesn’t conform to ","type":"text"},{"type":"codeVoice","code":"Shape"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"This means code like "},{"type":"codeVoice","code":"protoFlip(protoFlip(smallTriangle))"},{"type":"text","text":" "},{"type":"text","text":"that applies multiple transformations is invalid"},{"text":" ","type":"text"},{"type":"text","text":"because the flipped shape isn’t a valid argument to "},{"type":"codeVoice","code":"protoFlip(_:)"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In contrast,"},{"type":"text","text":" "},{"text":"opaque types preserve the identity of the underlying type.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Swift can infer associated types,"},{"text":" ","type":"text"},{"type":"text","text":"which lets you use an opaque return value"},{"type":"text","text":" "},{"type":"text","text":"in places where a boxed protocol type can’t be used as a return value."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"text":"here’s a version of the ","type":"text"},{"code":"Container","type":"codeVoice"},{"type":"text","text":" protocol from "},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","isActive":true},{"type":"text","text":":"}]},{"syntax":"swift","type":"codeListing","code":["protocol Container {","    associatedtype Item","    var count: Int { get }","    subscript(i: Int) -> Item { get }","}","extension Array: Container { }"]},{"inlineContent":[{"type":"text","text":"You can’t use "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" as the return type of a function"},{"type":"text","text":" "},{"type":"text","text":"because that protocol has an associated type."},{"text":" ","type":"text"},{"text":"You also can’t use it as constraint in a generic return type","type":"text"},{"type":"text","text":" "},{"type":"text","text":"because there isn’t enough information outside the function body"},{"type":"text","text":" "},{"type":"text","text":"to infer what the generic type needs to be."}],"type":"paragraph"},{"code":["\/\/ Error: Protocol with associated types can't be used as a return type.","func makeProtocolContainer<T>(item: T) -> Container {","    return [item]","}","","\/\/ Error: Not enough information to infer C.","func makeProtocolContainer<T, C: Container>(item: T) -> C {","    return [item]","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Using the opaque type "},{"type":"codeVoice","code":"some Container"},{"text":" as a return type","type":"text"},{"type":"text","text":" "},{"type":"text","text":"expresses the desired API contract — the function returns a container,"},{"type":"text","text":" "},{"text":"but declines to specify the container’s type:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["func makeOpaqueContainer<T>(item: T) -> some Container {","    return [item]","}","let opaqueContainer = makeOpaqueContainer(item: 12)","let twelve = opaqueContainer[0]","print(type(of: twelve))","\/\/ Prints \"Int\""]},{"inlineContent":[{"text":"The type of ","type":"text"},{"type":"codeVoice","code":"twelve"},{"type":"text","text":" is inferred to be "},{"type":"codeVoice","code":"Int"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"which illustrates the fact that type inference works with opaque types."},{"text":" ","type":"text"},{"type":"text","text":"In the implementation of "},{"type":"codeVoice","code":"makeOpaqueContainer(item:)"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the underlying type of the opaque container is "},{"code":"[T]","type":"codeVoice"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"In this case, "},{"type":"codeVoice","code":"T"},{"type":"text","text":" is "},{"type":"codeVoice","code":"Int"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"so the return value is an array of integers","type":"text"},{"text":" ","type":"text"},{"text":"and the ","type":"text"},{"type":"codeVoice","code":"Item"},{"text":" associated type is inferred to be ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The subscript on "},{"code":"Container","type":"codeVoice"},{"text":" returns ","type":"text"},{"type":"codeVoice","code":"Item"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"which means that the type of ","type":"text"},{"code":"twelve","type":"codeVoice"},{"text":" is also inferred to be ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"}]}],"kind":"article","references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/OpaqueTypes#The-Problem-That-Opaque-Types-Solve":{"abstract":[],"url":"\/documentation\/the-swift-programming-language\/opaquetypes#The-Problem-That-Opaque-Types-Solve","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes#The-Problem-That-Opaque-Types-Solve","title":"The Problem That Opaque Types Solve","type":"topic","kind":"section"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TypeCasting#Downcasting":{"kind":"section","title":"Downcasting","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting#Downcasting","abstract":[],"url":"\/documentation\/the-swift-programming-language\/typecasting#Downcasting","type":"topic"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"url":"\/documentation\/the-swift-programming-language","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language","kind":"article","role":"collection","abstract":[],"type":"topic","title":"The Swift Programming Language (5.9.2)"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Generics":{"kind":"article","type":"topic","role":"article","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","title":"Generics","abstract":[{"type":"text","text":"Write code that works for multiple types and specify requirements for those types."}],"url":"\/documentation\/the-swift-programming-language\/generics"}}}