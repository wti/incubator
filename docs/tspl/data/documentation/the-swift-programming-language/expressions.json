{"schemaVersion":{"major":0,"minor":3,"patch":0},"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Expressions","interfaceLanguage":"swift"},"primaryContentSections":[{"content":[{"inlineContent":[{"type":"text","text":"In Swift, there are four kinds of expressions:"},{"type":"text","text":" "},{"text":"prefix expressions, infix expressions, primary expressions, and postfix expressions.","type":"text"},{"type":"text","text":" "},{"text":"Evaluating an expression returns a value,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"causes a side effect, or both."}],"type":"paragraph"},{"inlineContent":[{"text":"Prefix and infix expressions let you","type":"text"},{"text":" ","type":"text"},{"text":"apply operators to smaller expressions.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Primary expressions are conceptually the simplest kind of expression,"},{"text":" ","type":"text"},{"text":"and they provide a way to access values.","type":"text"},{"type":"text","text":" "},{"text":"Postfix expressions,","type":"text"},{"type":"text","text":" "},{"text":"like prefix and infix expressions,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"let you build up more complex expressions"},{"text":" ","type":"text"},{"type":"text","text":"using postfixes such as function calls and member access."},{"type":"text","text":" "},{"type":"text","text":"Each kind of expression is described in detail"},{"type":"text","text":" "},{"text":"in the sections below.","type":"text"}],"type":"paragraph"},{"style":"note","name":"Grammar of an expression","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"try-operator"}]},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"await-operator","type":"text"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"prefix-expression"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"infix-expressions"}]},{"inlineContent":[{"text":"?","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression-list"}]},{"type":"text","text":" → "},{"inlineContent":[{"text":"expression","type":"text"}],"type":"emphasis"},{"text":" | ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":",","type":"codeVoice"}]},{"type":"text","text":" "},{"inlineContent":[{"text":"expression-list","type":"text"}],"type":"emphasis"}],"type":"paragraph"}],"type":"aside"},{"type":"heading","level":2,"text":"Prefix Expressions","anchor":"Prefix-Expressions"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Prefix expressions"}],"type":"emphasis"},{"text":" combine","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"an optional prefix operator with an expression."},{"text":" ","type":"text"},{"type":"text","text":"Prefix operators take one argument,"},{"text":" ","type":"text"},{"type":"text","text":"the expression that follows them."}]},{"type":"paragraph","inlineContent":[{"text":"For information about the behavior of these operators,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators"},{"text":" and ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators"},{"type":"text","text":"."}]},{"inlineContent":[{"type":"text","text":"For information about the operators provided by the Swift standard library,"},{"type":"text","text":" "},{"text":"see ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","type":"reference","isActive":true},{"text":".","type":"text"}],"type":"paragraph"},{"type":"aside","style":"note","name":"Grammar of a prefix expression","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"prefix-expression"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"prefix-operator"}]},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"postfix-expression","type":"text"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"prefix-expression"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"in-out-expression"}]}]}]},{"anchor":"In-Out-Expression","text":"In-Out Expression","type":"heading","level":3},{"inlineContent":[{"text":"An ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"in-out expression","type":"text"}]},{"type":"text","text":" marks a variable"},{"type":"text","text":" "},{"type":"text","text":"that’s being passed"},{"type":"text","text":" "},{"text":"as an in-out argument to a function call expression.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["&<#expression#>"]},{"inlineContent":[{"type":"text","text":"For more information about in-out parameters and to see an example,"},{"type":"text","text":" "},{"text":"see ","type":"text"},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#In-Out-Parameters","type":"reference","isActive":true},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"In-out expressions are also used","type":"text"},{"type":"text","text":" "},{"text":"when providing a non-pointer argument","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"in a context where a pointer is needed,"},{"text":" ","type":"text"},{"text":"as described in ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Expressions#Implicit-Conversion-to-a-Pointer-Type"},{"text":".","type":"text"}]},{"style":"note","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"in-out-expression"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"&"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"primary-expression"}]}]}],"type":"aside","name":"Grammar of an in-out expression"},{"anchor":"Try-Operator","level":3,"text":"Try Operator","type":"heading"},{"inlineContent":[{"text":"A ","type":"text"},{"inlineContent":[{"text":"try expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" consists of the "},{"code":"try","type":"codeVoice"},{"type":"text","text":" operator"},{"type":"text","text":" "},{"type":"text","text":"followed by an expression that can throw an error."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}],"type":"paragraph"},{"syntax":"swift","code":["try <#expression#>"],"type":"codeListing"},{"inlineContent":[{"text":"The value of a ","type":"text"},{"code":"try","type":"codeVoice"},{"type":"text","text":" expression is the value of the "},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"inlineContent":[{"text":"optional-try expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" consists of the "},{"code":"try?","type":"codeVoice"},{"type":"text","text":" operator"},{"text":" ","type":"text"},{"type":"text","text":"followed by an expression that can throw an error."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"syntax":"swift","type":"codeListing","code":["try? <#expression#>"]},{"type":"paragraph","inlineContent":[{"text":"If the ","type":"text"},{"inlineContent":[{"text":"expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" doesn’t throw an error,"},{"type":"text","text":" "},{"type":"text","text":"the value of the optional-try expression"},{"type":"text","text":" "},{"type":"text","text":"is an optional containing the value of the "},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"Otherwise, the value of the optional-try expression is ","type":"text"},{"code":"nil","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"text":"A ","type":"text"},{"inlineContent":[{"type":"text","text":"forced-try expression"}],"type":"emphasis"},{"type":"text","text":" consists of the "},{"type":"codeVoice","code":"try!"},{"type":"text","text":" operator"},{"text":" ","type":"text"},{"type":"text","text":"followed by an expression that can throw an error."},{"type":"text","text":" "},{"text":"It has the following form:","type":"text"}]},{"type":"codeListing","code":["try! <#expression#>"],"syntax":"swift"},{"inlineContent":[{"text":"The value of a forced-try expression is the value of the ","type":"text"},{"inlineContent":[{"type":"text","text":"expression"}],"type":"emphasis"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"If the "},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]},{"type":"text","text":" throws an error,"},{"text":" ","type":"text"},{"text":"a runtime error is produced.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"When the expression on the left-hand side of an infix operator","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"is marked with "},{"type":"codeVoice","code":"try"},{"text":", ","type":"text"},{"code":"try?","type":"codeVoice"},{"text":", or ","type":"text"},{"type":"codeVoice","code":"try!"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"that operator applies to the whole infix expression."},{"text":" ","type":"text"},{"text":"That said, you can use parentheses to be explicit about the scope of the operator’s application.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["\/\/ try applies to both function calls","sum = try someThrowingFunction() + anotherThrowingFunction()","","\/\/ try applies to both function calls","sum = try (someThrowingFunction() + anotherThrowingFunction())","","\/\/ Error: try applies only to the first function call","sum = (try someThrowingFunction()) + anotherThrowingFunction()"]},{"type":"paragraph","inlineContent":[{"text":"A ","type":"text"},{"type":"codeVoice","code":"try"},{"type":"text","text":" expression can’t appear on the right-hand side of an infix operator,"},{"type":"text","text":" "},{"type":"text","text":"unless the infix operator is the assignment operator"},{"text":" ","type":"text"},{"type":"text","text":"or the "},{"code":"try","type":"codeVoice"},{"type":"text","text":" expression is enclosed in parentheses."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If an expression includes both the "},{"code":"try","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"await","type":"codeVoice"},{"type":"text","text":" operator,"},{"text":" ","type":"text"},{"type":"text","text":"the "},{"type":"codeVoice","code":"try"},{"text":" operator must appear first.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"For more information and to see examples of how to use ","type":"text"},{"code":"try","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":"try?"},{"text":", and ","type":"text"},{"code":"try!","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"see "},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ErrorHandling","isActive":true,"type":"reference"},{"type":"text","text":"."}]},{"style":"note","name":"Grammar of a try expression","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"try-operator","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"code":"try","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" | "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"try"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":"?"}],"type":"strong"},{"type":"text","text":" | "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"try"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"!"}]}]}]},{"type":"heading","text":"Await Operator","anchor":"Await-Operator","level":3},{"type":"paragraph","inlineContent":[{"text":"An ","type":"text"},{"inlineContent":[{"type":"text","text":"await expression"}],"type":"emphasis"},{"text":" consists of the ","type":"text"},{"code":"await","type":"codeVoice"},{"type":"text","text":" operator"},{"text":" ","type":"text"},{"text":"followed by an expression that uses the result of an asynchronous operation.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"code":["await <#expression#>"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The value of an ","type":"text"},{"code":"await","type":"codeVoice"},{"type":"text","text":" expression is the value of the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"An expression marked with "},{"type":"codeVoice","code":"await"},{"type":"text","text":" is called a "},{"inlineContent":[{"text":"potential suspension point","type":"text"}],"type":"emphasis"},{"type":"text","text":"."},{"text":" ","type":"text"},{"text":"Execution of an asynchronous function can be suspended","type":"text"},{"type":"text","text":" "},{"text":"at each expression that’s marked with ","type":"text"},{"code":"await","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"In addition,"},{"type":"text","text":" "},{"text":"execution of concurrent code is never suspended at any other point.","type":"text"},{"type":"text","text":" "},{"text":"This means code between potential suspension points","type":"text"},{"type":"text","text":" "},{"text":"can safely update state that requires temporarily breaking invariants,","type":"text"},{"text":" ","type":"text"},{"text":"provided that it completes the update","type":"text"},{"type":"text","text":" "},{"type":"text","text":"before the next potential suspension point."}]},{"type":"paragraph","inlineContent":[{"text":"An ","type":"text"},{"code":"await","type":"codeVoice"},{"text":" expression can appear only within an asynchronous context,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"such as the trailing closure passed to the "},{"code":"async(priority:operation:)","type":"codeVoice"},{"text":" function.","type":"text"},{"type":"text","text":" "},{"text":"It can’t appear in the body of a ","type":"text"},{"type":"codeVoice","code":"defer"},{"type":"text","text":" statement,"},{"text":" ","type":"text"},{"text":"or in an autoclosure of synchronous function type.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"When the expression on the left-hand side of an infix operator","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"is marked with the "},{"code":"await","type":"codeVoice"},{"type":"text","text":" operator,"},{"text":" ","type":"text"},{"type":"text","text":"that operator applies to the whole infix expression."},{"text":" ","type":"text"},{"type":"text","text":"That said, you can use parentheses"},{"type":"text","text":" "},{"type":"text","text":"to be explicit about the scope of the operator’s application."}]},{"code":["\/\/ await applies to both function calls","sum = await someAsyncFunction() + anotherAsyncFunction()","","\/\/ await applies to both function calls","sum = await (someAsyncFunction() + anotherAsyncFunction())","","\/\/ Error: await applies only to the first function call","sum = (await someAsyncFunction()) + anotherAsyncFunction()"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"An ","type":"text"},{"code":"await","type":"codeVoice"},{"text":" expression can’t appear on the right-hand side of an infix operator,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"unless the infix operator is the assignment operator"},{"text":" ","type":"text"},{"text":"or the ","type":"text"},{"code":"await","type":"codeVoice"},{"type":"text","text":" expression is enclosed in parentheses."}]},{"inlineContent":[{"text":"If an expression includes both the ","type":"text"},{"code":"await","type":"codeVoice"},{"type":"text","text":" and "},{"code":"try","type":"codeVoice"},{"text":" operator,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"try"},{"type":"text","text":" operator must appear first."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"await-operator","type":"text"}]},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"code":"await","type":"codeVoice"}]}]}],"name":"Grammar of an await expression","type":"aside","style":"note"},{"level":2,"text":"Infix Expressions","anchor":"Infix-Expressions","type":"heading"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"Infix expressions","type":"text"}]},{"type":"text","text":" combine"},{"text":" ","type":"text"},{"type":"text","text":"an infix binary operator with the expression that it takes"},{"text":" ","type":"text"},{"type":"text","text":"as its left- and right-hand arguments."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["<#left-hand argument#> <#operator#> <#right-hand argument#>"]},{"type":"paragraph","inlineContent":[{"text":"For information about the behavior of these operators,","type":"text"},{"text":" ","type":"text"},{"text":"see ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators"},{"type":"text","text":" and "},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators","isActive":true},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For information about the operators provided by the Swift standard library,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"isActive":true,"overridingTitle":"Operator Declarations","type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","overridingTitleInlineContent":[{"type":"text","text":"Operator Declarations"}]},{"type":"text","text":"."}]},{"name":"Note","type":"aside","style":"note","content":[{"inlineContent":[{"text":"At parse time,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"an expression made up of infix operators is represented"},{"type":"text","text":" "},{"type":"text","text":"as a flat list."},{"text":" ","type":"text"},{"type":"text","text":"This list is transformed into a tree"},{"type":"text","text":" "},{"type":"text","text":"by applying operator precedence."},{"text":" ","type":"text"},{"text":"For example, the expression ","type":"text"},{"type":"codeVoice","code":"2 + 3 * 5"},{"text":" ","type":"text"},{"text":"is initially understood as a flat list of five items,","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"2"},{"text":", ","type":"text"},{"code":"+","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":"3"},{"type":"text","text":", "},{"type":"codeVoice","code":"*"},{"type":"text","text":", and "},{"type":"codeVoice","code":"5"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"This process transforms it into the tree (2 + (3 * 5)).","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"infix-expression"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"infix-operator"}]},{"type":"text","text":" "},{"inlineContent":[{"text":"prefix-expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"text":"infix-expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"assignment-operator"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"try-operator"}],"type":"emphasis"},{"inlineContent":[{"text":"?","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"await-operator","type":"text"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"prefix-expression"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"infix-expression","type":"text"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"conditional-operator"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"try-operator"}],"type":"emphasis"},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"text":"await-operator","type":"text"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"prefix-expression","type":"text"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"infix-expression","type":"text"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"type-casting-operator"}],"type":"emphasis"},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"infix-expressions"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"infix-expression"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"infix-expressions"}]},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"}]}],"name":"Grammar of an infix expression","style":"note","type":"aside"},{"level":3,"anchor":"Assignment-Operator","text":"Assignment Operator","type":"heading"},{"inlineContent":[{"text":"The ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"assignment operator","type":"text"}]},{"type":"text","text":" sets a new value"},{"type":"text","text":" "},{"type":"text","text":"for a given expression."},{"text":" ","type":"text"},{"text":"It has the following form:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["<#expression#> = <#value#>"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"The value of the ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]},{"text":" ","type":"text"},{"type":"text","text":"is set to the value obtained by evaluating the "},{"inlineContent":[{"type":"text","text":"value"}],"type":"emphasis"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"If the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"text":" is a tuple,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the "},{"type":"emphasis","inlineContent":[{"text":"value","type":"text"}]},{"type":"text","text":" must be a tuple"},{"type":"text","text":" "},{"type":"text","text":"with the same number of elements."},{"text":" ","type":"text"},{"text":"(Nested tuples are allowed.)","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Assignment is performed from each part of the "},{"inlineContent":[{"type":"text","text":"value"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"text","text":"to the corresponding part of the "},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"For example:"}]},{"type":"codeListing","code":["(a, _, (b, c)) = (\"test\", 9.45, (12, 3))","\/\/ a is \"test\", b is 12, c is 3, and 9.45 is ignored"],"syntax":"swift"},{"inlineContent":[{"text":"The assignment operator doesn’t return any value.","type":"text"}],"type":"paragraph"},{"style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"assignment-operator","type":"text"}]},{"type":"text","text":" → "},{"inlineContent":[{"code":"=","type":"codeVoice"}],"type":"strong"}],"type":"paragraph"}],"name":"Grammar of an assignment operator"},{"anchor":"Ternary-Conditional-Operator","type":"heading","level":3,"text":"Ternary Conditional Operator"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"ternary conditional operator"}]},{"type":"text","text":" evaluates to one of two given values"},{"type":"text","text":" "},{"type":"text","text":"based on the value of a condition."},{"type":"text","text":" "},{"text":"It has the following form:","type":"text"}]},{"code":["<#condition#> ? <#expression used if true#> : <#expression used if false#>"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"If the "},{"type":"emphasis","inlineContent":[{"text":"condition","type":"text"}]},{"text":" evaluates to ","type":"text"},{"type":"codeVoice","code":"true"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the conditional operator evaluates the first expression"},{"text":" ","type":"text"},{"type":"text","text":"and returns its value."},{"type":"text","text":" "},{"text":"Otherwise, it evaluates the second expression","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and returns its value."},{"type":"text","text":" "},{"type":"text","text":"The unused expression isn’t evaluated."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For an example that uses the ternary conditional operator,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators#Ternary-Conditional-Operator","isActive":true,"type":"reference"},{"type":"text","text":"."}]},{"name":"Grammar of a conditional operator","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"conditional-operator","type":"text"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"?"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":":"}],"type":"strong"}]}],"style":"note","type":"aside"},{"text":"Type-Casting Operators","anchor":"Type-Casting-Operators","level":3,"type":"heading"},{"inlineContent":[{"type":"text","text":"There are four type-casting operators:"},{"text":" ","type":"text"},{"type":"text","text":"the "},{"type":"codeVoice","code":"is"},{"type":"text","text":" operator,"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"type":"codeVoice","code":"as"},{"text":" operator,","type":"text"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"type":"codeVoice","code":"as?"},{"text":" operator,","type":"text"},{"type":"text","text":" "},{"text":"and the ","type":"text"},{"type":"codeVoice","code":"as!"},{"type":"text","text":" operator."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"They have the following form:"}]},{"code":["<#expression#> is <#type#>","<#expression#> as <#type#>","<#expression#> as? <#type#>","<#expression#> as! <#type#>"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"is"},{"type":"text","text":" operator checks at runtime whether the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":" "},{"type":"text","text":"can be cast to the specified "},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"It returns ","type":"text"},{"type":"codeVoice","code":"true"},{"type":"text","text":" if the "},{"inlineContent":[{"type":"text","text":"expression"}],"type":"emphasis"},{"type":"text","text":" can be cast to the specified "},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"type":"text","text":";"},{"type":"text","text":" "},{"text":"otherwise, it returns ","type":"text"},{"type":"codeVoice","code":"false"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"as","type":"codeVoice"},{"type":"text","text":" operator performs a cast"},{"type":"text","text":" "},{"type":"text","text":"when it’s known at compile time"},{"type":"text","text":" "},{"text":"that the cast always succeeds,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"such as upcasting or bridging."},{"text":" ","type":"text"},{"text":"Upcasting lets you use an expression as an instance of its type’s supertype,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"without using an intermediate variable."},{"type":"text","text":" "},{"type":"text","text":"The following approaches are equivalent:"}]},{"code":["func f(_ any: Any) { print(\"Function for Any\") }","func f(_ int: Int) { print(\"Function for Int\") }","let x = 10","f(x)","\/\/ Prints \"Function for Int\"","","let y: Any = x","f(y)","\/\/ Prints \"Function for Any\"","","f(x as Any)","\/\/ Prints \"Function for Any\""],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Bridging lets you use an expression of","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"a Swift standard library type such as "},{"code":"String","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"as its corresponding Foundation type such as "},{"code":"NSString","type":"codeVoice"},{"type":"text","text":" "},{"text":"without needing to create a new instance.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For more information on bridging,"},{"type":"text","text":" "},{"text":"see ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/imported_c_and_objective_c_apis\/working_with_foundation_types"},{"text":".","type":"text"}]},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"as?"},{"text":" operator","type":"text"},{"type":"text","text":" "},{"text":"performs a conditional cast of the ","type":"text"},{"inlineContent":[{"text":"expression","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"text","text":"to the specified "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"The ","type":"text"},{"code":"as?","type":"codeVoice"},{"text":" operator returns an optional of the specified ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"At runtime, if the cast succeeds,"},{"type":"text","text":" "},{"text":"the value of ","type":"text"},{"inlineContent":[{"type":"text","text":"expression"}],"type":"emphasis"},{"text":" is wrapped in an optional and returned;","type":"text"},{"type":"text","text":" "},{"type":"text","text":"otherwise, the value returned is "},{"type":"codeVoice","code":"nil"},{"text":".","type":"text"},{"type":"text","text":" "},{"text":"If casting to the specified ","type":"text"},{"inlineContent":[{"text":"type","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"text","text":"is guaranteed to fail or is guaranteed to succeed,"},{"type":"text","text":" "},{"type":"text","text":"a compile-time error is raised."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"as!"},{"type":"text","text":" operator performs a forced cast of the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":" to the specified "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"as!"},{"type":"text","text":" operator returns a value of the specified "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":", not an optional type."},{"type":"text","text":" "},{"type":"text","text":"If the cast fails, a runtime error is raised."},{"text":" ","type":"text"},{"type":"text","text":"The behavior of "},{"code":"x as! T","type":"codeVoice"},{"text":" is the same as the behavior of ","type":"text"},{"code":"(x as? T)!","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"text":"For more information about type casting","type":"text"},{"type":"text","text":" "},{"text":"and to see examples that use the type-casting operators,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting"},{"text":".","type":"text"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"inlineContent":[{"type":"text","text":"type-casting-operator"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"code":"is","type":"codeVoice"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"type-casting-operator"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"as"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"type-casting-operator"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"code":"as","type":"codeVoice"}]},{"type":"text","text":" "},{"inlineContent":[{"code":"?","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"type-casting-operator"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"code":"as","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"!"}]},{"type":"text","text":" "},{"inlineContent":[{"text":"type","type":"text"}],"type":"emphasis"}],"type":"paragraph"}],"style":"note","name":"Grammar of a type-casting operator","type":"aside"},{"type":"heading","text":"Primary Expressions","anchor":"Primary-Expressions","level":2},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Primary expressions"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"are the most basic kind of expression."},{"text":" ","type":"text"},{"type":"text","text":"They can be used as expressions on their own,"},{"type":"text","text":" "},{"type":"text","text":"and they can be combined with other tokens"},{"type":"text","text":" "},{"type":"text","text":"to make prefix expressions, infix expressions, and postfix expressions."}]},{"name":"Grammar of a primary expression","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"primary-expression"}]},{"text":" → ","type":"text"},{"inlineContent":[{"text":"identifier","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"text":"generic-argument-clause","type":"text"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"primary-expression"}]},{"type":"text","text":" → "},{"inlineContent":[{"text":"literal-expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"primary-expression"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"self-expression"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"inlineContent":[{"text":"primary-expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"superclass-expression"}],"type":"emphasis"},{"type":"text","text":" "},{"text":"\n","type":"text"},{"inlineContent":[{"text":"primary-expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"conditional-expression","type":"text"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"primary-expression"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"closure-expression"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"primary-expression"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"text":"parenthesized-expression","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"primary-expression","type":"text"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"tuple-expression"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"primary-expression"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"implicit-member-expression"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"primary-expression","type":"text"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"wildcard-expression"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"primary-expression"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"text":"macro-expansion-expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"primary-expression"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"key-path-expression"}],"type":"emphasis"},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"primary-expression"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"selector-expression","type":"text"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"inlineContent":[{"text":"primary-expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"key-path-string-expression"}]}],"type":"paragraph"}],"type":"aside"},{"level":3,"type":"heading","text":"Literal Expression","anchor":"Literal-Expression"},{"type":"paragraph","inlineContent":[{"text":"A ","type":"text"},{"inlineContent":[{"text":"literal expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" consists of"},{"type":"text","text":" "},{"type":"text","text":"either an ordinary literal (such as a string or a number),"},{"type":"text","text":" "},{"type":"text","text":"an array or dictionary literal,"},{"type":"text","text":" "},{"type":"text","text":"or a playground literal."}]},{"name":"Note","content":[{"inlineContent":[{"type":"text","text":""},{"text":" ","type":"text"},{"type":"text","text":"Prior to Swift 5.9,"},{"type":"text","text":" "},{"type":"text","text":"the following special literals were recognized:"},{"type":"text","text":" "},{"code":"#column","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"code":"#dsohandle","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"#fileID"},{"text":",","type":"text"},{"type":"text","text":" "},{"code":"#filePath","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"code":"#file","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"code":"#function","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"and ","type":"text"},{"type":"codeVoice","code":"#line"},{"text":".","type":"text"},{"type":"text","text":" "},{"text":"These are now implemented as macros in the Swift standard library:","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/column()","type":"reference","isActive":true},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/dsohandle()"},{"type":"text","text":","},{"type":"text","text":" "},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/fileID()","isActive":true,"type":"reference"},{"text":",","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/filePath()","isActive":true,"type":"reference"},{"type":"text","text":","},{"type":"text","text":" "},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/file()","type":"reference","isActive":true},{"type":"text","text":","},{"type":"text","text":" "},{"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/function()"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and "},{"isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/line()","type":"reference"},{"text":".","type":"text"}],"type":"paragraph"}],"type":"aside","style":"note"},{"inlineContent":[{"type":"text","text":"An "},{"inlineContent":[{"text":"array literal","type":"text"}],"type":"emphasis"},{"type":"text","text":" is"},{"text":" ","type":"text"},{"text":"an ordered collection of values.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"It has the following form:"}],"type":"paragraph"},{"type":"codeListing","code":["[<#value 1#>, <#value 2#>, <#...#>]"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"The last expression in the array can be followed by an optional comma."},{"type":"text","text":" "},{"type":"text","text":"The value of an array literal has type "},{"type":"codeVoice","code":"[T]"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"where "},{"type":"codeVoice","code":"T"},{"type":"text","text":" is the type of the expressions inside it."},{"type":"text","text":" "},{"text":"If there are expressions of multiple types,","type":"text"},{"type":"text","text":" "},{"code":"T","type":"codeVoice"},{"type":"text","text":" is their closest common supertype."},{"type":"text","text":" "},{"type":"text","text":"Empty array literals are written using an empty"},{"type":"text","text":" "},{"text":"pair of square brackets and can be used to create an empty array of a specified type.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["var emptyArray: [Double] = []"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"A ","type":"text"},{"inlineContent":[{"type":"text","text":"dictionary literal"}],"type":"emphasis"},{"type":"text","text":" is"},{"type":"text","text":" "},{"text":"an unordered collection of key-value pairs.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"syntax":"swift","code":["[<#key 1#>: <#value 1#>, <#key 2#>: <#value 2#>, <#...#>]"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The last expression in the dictionary can be followed by an optional comma."},{"text":" ","type":"text"},{"type":"text","text":"The value of a dictionary literal has type "},{"type":"codeVoice","code":"[Key: Value]"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"where ","type":"text"},{"code":"Key","type":"codeVoice"},{"text":" is the type of its key expressions","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and "},{"type":"codeVoice","code":"Value"},{"type":"text","text":" is the type of its value expressions."},{"type":"text","text":" "},{"type":"text","text":"If there are expressions of multiple types,"},{"text":" ","type":"text"},{"code":"Key","type":"codeVoice"},{"type":"text","text":" and "},{"code":"Value","type":"codeVoice"},{"text":" are the closest common supertype","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"for their respective values."},{"text":" ","type":"text"},{"type":"text","text":"An empty dictionary literal is written as"},{"text":" ","type":"text"},{"type":"text","text":"a colon inside a pair of brackets ("},{"code":"[:]","type":"codeVoice"},{"text":")","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to distinguish it from an empty array literal."},{"text":" ","type":"text"},{"type":"text","text":"You can use an empty dictionary literal to create an empty dictionary literal"},{"type":"text","text":" "},{"text":"of specified key and value types.","type":"text"}]},{"code":["var emptyDictionary: [String: Double] = [:]"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"playground literal","type":"text"}]},{"type":"text","text":" "},{"text":"is used by Xcode to create an interactive representation","type":"text"},{"type":"text","text":" "},{"type":"text","text":"of a color, file, or image within the program editor."},{"text":" ","type":"text"},{"text":"Playground literals in plain text outside of Xcode","type":"text"},{"type":"text","text":" "},{"text":"are represented using a special literal syntax.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For information on using playground literals in Xcode,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","identifier":"https:\/\/help.apple.com\/xcode\/mac\/current\/#\/dev4c60242fc","isActive":true},{"text":" ","type":"text"},{"type":"text","text":"in Xcode Help."}],"type":"paragraph"},{"name":"Grammar of a literal expression","style":"note","type":"aside","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"literal-expression"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"literal"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"text":"literal-expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"array-literal"}],"type":"emphasis"},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"text":"dictionary-literal","type":"text"}]},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"playground-literal"}]}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"array-literal"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"codeVoice","code":"["}],"type":"strong"},{"text":" ","type":"text"},{"inlineContent":[{"text":"array-literal-items","type":"text"}],"type":"emphasis"},{"inlineContent":[{"text":"?","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"code":"]","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"array-literal-items"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"array-literal-item"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"code":",","type":"codeVoice"}],"type":"strong"},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"array-literal-item"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":",","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"array-literal-items"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"text":"array-literal-item","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"dictionary-literal"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"code":"[","type":"codeVoice"}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"dictionary-literal-items"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":"]","type":"codeVoice"}]},{"type":"text","text":" | "},{"inlineContent":[{"code":"[","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":":"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":"]","type":"codeVoice"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"dictionary-literal-items","type":"text"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"dictionary-literal-item","type":"text"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":","}]},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"text":" | ","type":"text"},{"inlineContent":[{"text":"dictionary-literal-item","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"code":",","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"dictionary-literal-items"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"dictionary-literal-item"}]},{"text":" → ","type":"text"},{"inlineContent":[{"text":"expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"code":":","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"text":"expression","type":"text"}],"type":"emphasis"}]},{"inlineContent":[{"inlineContent":[{"type":"text","text":"playground-literal"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"code":"#colorLiteral","type":"codeVoice"}],"type":"strong"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"("}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"red"}],"type":"strong"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":":","type":"codeVoice"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"expression"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"code":",","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"green"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":":"}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]},{"type":"text","text":" "},{"inlineContent":[{"code":",","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":"blue"}],"type":"strong"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":":","type":"codeVoice"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":","}],"type":"strong"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"alpha"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":":","type":"codeVoice"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"expression"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":")"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"playground-literal"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"code":"#fileLiteral","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":"(","type":"codeVoice"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"resourceName"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":":","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":")"}],"type":"strong"},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"playground-literal","type":"text"}]},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"#imageLiteral"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":"("}],"type":"strong"},{"text":" ","type":"text"},{"inlineContent":[{"code":"resourceName","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":":","type":"codeVoice"}]},{"text":" ","type":"text"},{"inlineContent":[{"text":"expression","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"code":")","type":"codeVoice"}],"type":"strong"}],"type":"paragraph"}]},{"text":"Self Expression","type":"heading","anchor":"Self-Expression","level":3},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"self"},{"type":"text","text":" expression is an explicit reference to the current type"},{"type":"text","text":" "},{"type":"text","text":"or instance of the type in which it occurs."},{"type":"text","text":" "},{"text":"It has the following forms:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["self","self.<#member name#>","self[<#subscript index#>]","self(<#initializer arguments#>)","self.init(<#initializer arguments#>)"]},{"inlineContent":[{"type":"text","text":"In an initializer, subscript, or instance method, "},{"code":"self","type":"codeVoice"},{"type":"text","text":" refers to the current"},{"text":" ","type":"text"},{"text":"instance of the type in which it occurs. In a type method,","type":"text"},{"text":" ","type":"text"},{"code":"self","type":"codeVoice"},{"text":" refers to the current type in which it occurs.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"self"},{"text":" expression is used to specify scope when accessing members,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"providing disambiguation when there’s"},{"text":" ","type":"text"},{"text":"another variable of the same name in scope,","type":"text"},{"text":" ","type":"text"},{"text":"such as a function parameter.","type":"text"},{"text":" ","type":"text"},{"text":"For example:","type":"text"}],"type":"paragraph"},{"code":["class SomeClass {","    var greeting: String","    init(greeting: String) {","        self.greeting = greeting","    }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In a mutating method of a value type,"},{"type":"text","text":" "},{"type":"text","text":"you can assign a new instance of that value type to "},{"type":"codeVoice","code":"self"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For example:"}]},{"syntax":"swift","type":"codeListing","code":["struct Point {","    var x = 0.0, y = 0.0","    mutating func moveBy(x deltaX: Double, y deltaY: Double) {","        self = Point(x: x + deltaX, y: y + deltaY)","    }","}"]},{"type":"aside","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"self-expression","type":"text"}]},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"code":"self","type":"codeVoice"}]},{"type":"text","text":" | "},{"inlineContent":[{"type":"text","text":"self-method-expression"}],"type":"emphasis"},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"self-subscript-expression"}]},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"self-initializer-expression"}]}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"self-method-expression"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"self"}]},{"text":" ","type":"text"},{"inlineContent":[{"code":".","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"text":"identifier","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"self-subscript-expression"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"code":"self","type":"codeVoice"}]},{"type":"text","text":" "},{"inlineContent":[{"code":"[","type":"codeVoice"}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"function-call-argument-list"}]},{"type":"text","text":" "},{"inlineContent":[{"code":"]","type":"codeVoice"}],"type":"strong"},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"self-initializer-expression","type":"text"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"code":"self","type":"codeVoice"}]},{"text":" ","type":"text"},{"inlineContent":[{"code":".","type":"codeVoice"}],"type":"strong"},{"text":" ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"init"}],"type":"strong"}]}],"name":"Grammar of a self expression","style":"note"},{"text":"Superclass Expression","anchor":"Superclass-Expression","type":"heading","level":3},{"inlineContent":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"superclass expression","type":"text"}]},{"type":"text","text":" lets a class"},{"type":"text","text":" "},{"type":"text","text":"interact with its superclass."},{"text":" ","type":"text"},{"text":"It has one of the following forms:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["super.<#member name#>","super[<#subscript index#>]","super.init(<#initializer arguments#>)"]},{"inlineContent":[{"text":"The first form is used to access a member of the superclass.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The second form is used to access the superclass’s subscript implementation."},{"text":" ","type":"text"},{"type":"text","text":"The third form is used to access an initializer of the superclass."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Subclasses can use a superclass expression"},{"type":"text","text":" "},{"type":"text","text":"in their implementation of members, subscripting, and initializers"},{"type":"text","text":" "},{"text":"to make use of the implementation in their superclass.","type":"text"}]},{"style":"note","type":"aside","name":"Grammar of a superclass expression","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"superclass-expression","type":"text"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"superclass-method-expression","type":"text"}]},{"text":" | ","type":"text"},{"inlineContent":[{"text":"superclass-subscript-expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"superclass-initializer-expression"}]}],"type":"paragraph"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"superclass-method-expression"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"super"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"."}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"identifier","type":"text"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"superclass-subscript-expression","type":"text"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"codeVoice","code":"super"}],"type":"strong"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"["}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"function-call-argument-list","type":"text"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"]"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"superclass-initializer-expression"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"codeVoice","code":"super"}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":"."}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"code":"init","type":"codeVoice"}],"type":"strong"}],"type":"paragraph"}]},{"text":"Conditional Expression","type":"heading","level":3,"anchor":"Conditional-Expression"},{"inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"conditional expression"}]},{"text":" evaluates to one of several given values","type":"text"},{"type":"text","text":" "},{"type":"text","text":"based on the value of a condition."},{"text":" ","type":"text"},{"type":"text","text":"It has one the following forms:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["if <#condition 1#> {","   <#expression used if condition 1 is true#>","} else if <#condition 2#> {","   <#expression used if condition 2 is true#>","} else {","   <#expression used if both conditions are false#>","}","","switch <#expression#> {","case <#pattern 1#>:","    <#expression 1#>","case <#pattern 2#> where <#condition#>:","    <#expression 2#>","default:","    <#expression 3#>","}"]},{"inlineContent":[{"text":"A conditional expression","type":"text"},{"text":" ","type":"text"},{"text":"has the same behavior and syntax as an ","type":"text"},{"type":"codeVoice","code":"if"},{"text":" statement or a ","type":"text"},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statement,"},{"type":"text","text":" "},{"text":"except for the differences that the paragraphs below describe.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"A conditional expression appears only in the following contexts:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"As the value assigned to a variable."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"As the initial value in a variable or constant declaration.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"As the error thrown by a "},{"type":"codeVoice","code":"throw"},{"type":"text","text":" expression."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"As the value returned by a function, closure, or property getter.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"As the value inside a branch of a conditional expression.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The branches of a conditional expression are exhaustive,"},{"type":"text","text":" "},{"text":"ensuring that the expression always produces a value","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"regardless of the condition."},{"text":" ","type":"text"},{"text":"This means each ","type":"text"},{"code":"if","type":"codeVoice"},{"type":"text","text":" branch needs a corresponding "},{"code":"else","type":"codeVoice"},{"type":"text","text":" branch."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Each branch contains either a single expression,"},{"type":"text","text":" "},{"type":"text","text":"which is used as the value for the conditional expression"},{"text":" ","type":"text"},{"text":"when that branch’s conditional is true,","type":"text"},{"type":"text","text":" "},{"text":"a ","type":"text"},{"type":"codeVoice","code":"throw"},{"type":"text","text":" statement,"},{"type":"text","text":" "},{"text":"or a call to a function that never returns.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Each branch must produce a value of the same type."},{"type":"text","text":" "},{"type":"text","text":"Because type checking of each branch is independent,"},{"text":" ","type":"text"},{"text":"you sometimes need to specify the value’s type explicitly,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"like when branches include different kinds of literals,"},{"type":"text","text":" "},{"type":"text","text":"or when a branch’s value is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"When you need to provide this information,"},{"text":" ","type":"text"},{"text":"add a type annotation to the variable that the result is assigned to,","type":"text"},{"type":"text","text":" "},{"text":"or add an ","type":"text"},{"code":"as","type":"codeVoice"},{"type":"text","text":" cast to the branches’ values."}]},{"type":"codeListing","code":["let number: Double = if someCondition { 10 } else { 12.34 }","let number = if someCondition { 10 as Double } else { 12.34 }"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"Inside a result builder,"},{"type":"text","text":" "},{"type":"text","text":"conditional expressions can appear"},{"text":" ","type":"text"},{"text":"only as the initial value of a variable or constant.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"This behavior means when you write "},{"type":"codeVoice","code":"if"},{"type":"text","text":" or "},{"code":"switch","type":"codeVoice"},{"text":" in a result builder —","type":"text"},{"type":"text","text":" "},{"type":"text","text":"outside of a variable or constant declaration —"},{"text":" ","type":"text"},{"text":"that code is understood as a branch statement","type":"text"},{"type":"text","text":" "},{"text":"and one of the result builder’s methods transforms that code.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Don’t put a conditional expression in a "},{"code":"try","type":"codeVoice"},{"text":" expression,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"even if one of the branches of a conditional expression is throwing."}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"conditional-expression","type":"text"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"if-expression"}]},{"text":" | ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"switch-expression"}]}],"type":"paragraph"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"if-expression","type":"text"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"if"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"condition-list"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"{"}]},{"type":"text","text":" "},{"inlineContent":[{"text":"statement","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":"}","type":"codeVoice"}]},{"text":" ","type":"text"},{"inlineContent":[{"text":"if-expression-tail","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"if-expression-tail"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"code":"else","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"if-expression"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"if-expression-tail","type":"text"}]},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"code":"else","type":"codeVoice"}]},{"type":"text","text":" "},{"inlineContent":[{"code":"{","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"statement"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"}"}],"type":"strong"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"switch-expression"}]},{"type":"text","text":" → "},{"inlineContent":[{"code":"switch","type":"codeVoice"}],"type":"strong"},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"expression"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"{"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"switch-expression-cases"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"}"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"switch-expression-cases"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"switch-expression-case"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"switch-expression-cases","type":"text"}]},{"inlineContent":[{"text":"?","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"switch-expression-case"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"case-label"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"statement"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"switch-expression-case","type":"text"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"default-label","type":"text"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"statement"}],"type":"emphasis"}]}],"type":"aside","style":"note","name":"Grammar of a conditional expression"},{"text":"Closure Expression","type":"heading","level":3,"anchor":"Closure-Expression"},{"inlineContent":[{"text":"A ","type":"text"},{"inlineContent":[{"type":"text","text":"closure expression"}],"type":"emphasis"},{"type":"text","text":" creates a closure,"},{"type":"text","text":" "},{"text":"also known as a ","type":"text"},{"inlineContent":[{"text":"lambda","type":"text"}],"type":"emphasis"},{"type":"text","text":" or an "},{"type":"emphasis","inlineContent":[{"type":"text","text":"anonymous function"}]},{"text":" ","type":"text"},{"text":"in other programming languages.","type":"text"},{"text":" ","type":"text"},{"text":"Like a function declaration,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"a closure contains statements,"},{"text":" ","type":"text"},{"type":"text","text":"and it captures constants and variables from its enclosing scope."},{"text":" ","type":"text"},{"text":"It has the following form:","type":"text"}],"type":"paragraph"},{"code":["{ (<#parameters#>) -> <#return type#> in","   <#statements#>","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"text":"parameters","type":"text"}]},{"type":"text","text":" have the same form"},{"type":"text","text":" "},{"text":"as the parameters in a function declaration,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"as described in "},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Function-Declaration","isActive":true},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Writing "},{"type":"codeVoice","code":"throws"},{"type":"text","text":" or "},{"code":"async","type":"codeVoice"},{"text":" in a closure expression","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"explicitly marks a closure as throwing or asynchronous."}]},{"type":"codeListing","syntax":"swift","code":["{ (<#parameters#>) async throws -> <#return type#> in","   <#statements#>","}"]},{"inlineContent":[{"type":"text","text":"If the body of a closure includes a try expression,"},{"text":" ","type":"text"},{"text":"the closure is understood to be throwing.","type":"text"},{"text":" ","type":"text"},{"text":"Likewise, if it includes an await expression,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"it’s understood to be asynchronous."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"There are several special forms","type":"text"},{"type":"text","text":" "},{"text":"that allow closures to be written more concisely:","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"A closure can omit the types","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"of its parameters, its return type, or both."},{"text":" ","type":"text"},{"type":"text","text":"If you omit the parameter names and both types,"},{"type":"text","text":" "},{"text":"omit the ","type":"text"},{"type":"codeVoice","code":"in"},{"type":"text","text":" keyword before the statements."},{"type":"text","text":" "},{"type":"text","text":"If the omitted types can’t be inferred,"},{"text":" ","type":"text"},{"type":"text","text":"a compile-time error is raised."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A closure may omit names for its parameters."},{"type":"text","text":" "},{"text":"Its parameters are then implicitly named","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"$"},{"type":"text","text":" followed by their position:"},{"text":" ","type":"text"},{"code":"$0","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"$1"},{"text":", ","type":"text"},{"type":"codeVoice","code":"$2"},{"type":"text","text":", and so on."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"A closure that consists of only a single expression"},{"type":"text","text":" "},{"type":"text","text":"is understood to return the value of that expression."},{"text":" ","type":"text"},{"type":"text","text":"The contents of this expression are also considered"},{"text":" ","type":"text"},{"text":"when performing type inference on the surrounding expression.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"The following closure expressions are equivalent:","type":"text"}]},{"syntax":"swift","code":["myFunction { (x: Int, y: Int) -> Int in","    return x + y","}","","myFunction { x, y in","    return x + y","}","","myFunction { return $0 + $1 }","","myFunction { $0 + $1 }"],"type":"codeListing"},{"inlineContent":[{"text":"For information about passing a closure as an argument to a function,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Expressions#Function-Call-Expression"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Closure expressions can be used"},{"type":"text","text":" "},{"text":"without being stored in a variable or constant,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"such as when you immediately use a closure as part of a function call."},{"type":"text","text":" "},{"type":"text","text":"The closure expressions passed to "},{"code":"myFunction","type":"codeVoice"},{"type":"text","text":" in code above are"},{"text":" ","type":"text"},{"type":"text","text":"examples of this kind of immediate use."},{"type":"text","text":" "},{"text":"As a result,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"whether a closure expression is escaping or nonescaping depends"},{"type":"text","text":" "},{"text":"on the surrounding context of the expression.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"A closure expression is nonescaping"},{"type":"text","text":" "},{"text":"if it’s called immediately","type":"text"},{"text":" ","type":"text"},{"text":"or passed as a nonescaping function argument.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Otherwise, the closure expression is escaping."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more information about escaping closures, see "},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Escaping-Closures","isActive":true,"type":"reference"},{"type":"text","text":"."}]},{"anchor":"Capture-Lists","text":"Capture Lists","level":4,"type":"heading"},{"inlineContent":[{"text":"By default, a closure expression captures","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"constants and variables from its surrounding scope"},{"text":" ","type":"text"},{"text":"with strong references to those values.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"You can use a "},{"type":"emphasis","inlineContent":[{"text":"capture list","type":"text"}]},{"text":" to explicitly control","type":"text"},{"type":"text","text":" "},{"type":"text","text":"how values are captured in a closure."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A capture list is written as a comma-separated list of expressions"},{"text":" ","type":"text"},{"type":"text","text":"surrounded by square brackets,"},{"type":"text","text":" "},{"type":"text","text":"before the list of parameters."},{"text":" ","type":"text"},{"text":"If you use a capture list, you must also use the ","type":"text"},{"code":"in","type":"codeVoice"},{"type":"text","text":" keyword,"},{"text":" ","type":"text"},{"type":"text","text":"even if you omit the parameter names, parameter types, and return type."}]},{"inlineContent":[{"text":"The entries in the capture list are initialized","type":"text"},{"type":"text","text":" "},{"text":"when the closure is created.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For each entry in the capture list,"},{"text":" ","type":"text"},{"type":"text","text":"a constant is initialized"},{"text":" ","type":"text"},{"text":"to the value of the constant or variable that has the same name","type":"text"},{"type":"text","text":" "},{"type":"text","text":"in the surrounding scope."},{"text":" ","type":"text"},{"type":"text","text":"For example in the code below,"},{"text":" ","type":"text"},{"type":"codeVoice","code":"a"},{"text":" is included in the capture list but ","type":"text"},{"code":"b","type":"codeVoice"},{"type":"text","text":" is not,"},{"text":" ","type":"text"},{"text":"which gives them different behavior.","type":"text"}],"type":"paragraph"},{"code":["var a = 0","var b = 0","let closure = { [a] in"," print(a, b)","}","","a = 10","b = 10","closure()","\/\/ Prints \"0 10\""],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"There are two different things named "},{"type":"codeVoice","code":"a"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"the variable in the surrounding scope","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and the constant in the closure’s scope,"},{"text":" ","type":"text"},{"text":"but only one variable named ","type":"text"},{"code":"b","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The "},{"code":"a","type":"codeVoice"},{"text":" in the inner scope is initialized","type":"text"},{"type":"text","text":" "},{"type":"text","text":"with the value of the "},{"type":"codeVoice","code":"a"},{"type":"text","text":" in the outer scope"},{"type":"text","text":" "},{"text":"when the closure is created,","type":"text"},{"text":" ","type":"text"},{"text":"but their values aren’t connected in any special way.","type":"text"},{"type":"text","text":" "},{"text":"This means that a change to the value of ","type":"text"},{"code":"a","type":"codeVoice"},{"type":"text","text":" in the outer scope"},{"type":"text","text":" "},{"type":"text","text":"doesn’t affect the value of "},{"type":"codeVoice","code":"a"},{"type":"text","text":" in the inner scope,"},{"text":" ","type":"text"},{"text":"nor does a change to ","type":"text"},{"type":"codeVoice","code":"a"},{"type":"text","text":" inside the closure"},{"text":" ","type":"text"},{"type":"text","text":"affect the value of "},{"code":"a","type":"codeVoice"},{"text":" outside the closure.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"In contrast, there’s only one variable named "},{"type":"codeVoice","code":"b"},{"type":"text","text":" —"},{"text":" ","type":"text"},{"type":"text","text":"the "},{"type":"codeVoice","code":"b"},{"text":" in the outer scope —","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"so changes from inside or outside the closure are visible in both places."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This distinction isn’t visible"},{"text":" ","type":"text"},{"type":"text","text":"when the captured variable’s type has reference semantics."},{"text":" ","type":"text"},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"text":"there are two things named ","type":"text"},{"code":"x","type":"codeVoice"},{"type":"text","text":" in the code below,"},{"type":"text","text":" "},{"text":"a variable in the outer scope and a constant in the inner scope,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"but they both refer to the same object"},{"text":" ","type":"text"},{"type":"text","text":"because of reference semantics."}]},{"code":["class SimpleClass {","    var value: Int = 0","}","var x = SimpleClass()","var y = SimpleClass()","let closure = { [x] in","    print(x.value, y.value)","}","","x.value = 10","y.value = 10","closure()","\/\/ Prints \"10 10\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"If the type of the expression’s value is a class,"},{"type":"text","text":" "},{"type":"text","text":"you can mark the expression in a capture list"},{"text":" ","type":"text"},{"type":"text","text":"with "},{"type":"codeVoice","code":"weak"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"unowned"},{"type":"text","text":" to capture a weak or unowned reference"},{"text":" ","type":"text"},{"type":"text","text":"to the expression’s value."}],"type":"paragraph"},{"syntax":"swift","code":["myFunction { print(self.title) }                    \/\/ implicit strong capture","myFunction { [self] in print(self.title) }          \/\/ explicit strong capture","myFunction { [weak self] in print(self!.title) }    \/\/ weak capture","myFunction { [unowned self] in print(self.title) }  \/\/ unowned capture"],"type":"codeListing"},{"inlineContent":[{"text":"You can also bind an arbitrary expression","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to a named value in a capture list."},{"text":" ","type":"text"},{"text":"The expression is evaluated when the closure is created,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and the value is captured with the specified strength."},{"type":"text","text":" "},{"text":"For example:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["\/\/ Weak capture of \"self.parent\" as \"parent\"","myFunction { [weak parent = self.parent] in print(parent!.title) }"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"For more information and examples of closure expressions,"},{"type":"text","text":" "},{"text":"see ","type":"text"},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Closure-Expressions","isActive":true},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For more information and examples of capture lists,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting#Resolving-Strong-Reference-Cycles-for-Closures","type":"reference"},{"type":"text","text":"."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"closure-expression","type":"text"}]},{"text":" → ","type":"text"},{"inlineContent":[{"code":"{","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"attributes"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"text":" ","type":"text"},{"inlineContent":[{"text":"closure-signature","type":"text"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"text":" ","type":"text"},{"inlineContent":[{"text":"statements","type":"text"}],"type":"emphasis"},{"inlineContent":[{"text":"?","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"code":"}","type":"codeVoice"}],"type":"strong"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"closure-signature","type":"text"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"capture-list","type":"text"}]},{"inlineContent":[{"text":"?","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"closure-parameter-clause"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"async"}]},{"inlineContent":[{"text":"?","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":"throws"}],"type":"strong"},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"function-result"}]},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"in"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"closure-signature","type":"text"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"capture-list","type":"text"}]},{"type":"text","text":" "},{"inlineContent":[{"code":"in","type":"codeVoice"}],"type":"strong"}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"closure-parameter-clause"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"codeVoice","code":"("}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":")"}],"type":"strong"},{"type":"text","text":" | "},{"inlineContent":[{"type":"codeVoice","code":"("}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"closure-parameter-list","type":"text"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":")","type":"codeVoice"}]},{"type":"text","text":" | "},{"inlineContent":[{"text":"identifier-list","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"closure-parameter-list"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"closure-parameter"}],"type":"emphasis"},{"type":"text","text":" | "},{"inlineContent":[{"text":"closure-parameter","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":",","type":"codeVoice"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"closure-parameter-list"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"closure-parameter","type":"text"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"closure-parameter-name","type":"text"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"type-annotation"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"closure-parameter"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"closure-parameter-name","type":"text"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-annotation"}]},{"text":" ","type":"text"},{"inlineContent":[{"code":"...","type":"codeVoice"}],"type":"strong"},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"closure-parameter-name"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"identifier"}],"type":"emphasis"}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"capture-list","type":"text"}]},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"["}]},{"type":"text","text":" "},{"inlineContent":[{"text":"capture-list-items","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"]"}],"type":"strong"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"capture-list-items"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"capture-list-item"}]},{"text":" | ","type":"text"},{"inlineContent":[{"text":"capture-list-item","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":","}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"capture-list-items"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"capture-list-item","type":"text"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"capture-specifier"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" "},{"inlineContent":[{"text":"identifier","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"capture-list-item"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"capture-specifier"}]},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier"}]},{"text":" ","type":"text"},{"inlineContent":[{"code":"=","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"capture-list-item"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"capture-specifier","type":"text"}]},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"type":"text","text":" "},{"inlineContent":[{"text":"self-expression","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"capture-specifier"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"weak"}],"type":"strong"},{"text":" | ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"unowned"}],"type":"strong"},{"text":" | ","type":"text"},{"type":"strong","inlineContent":[{"code":"unowned(safe)","type":"codeVoice"}]},{"type":"text","text":" | "},{"inlineContent":[{"type":"codeVoice","code":"unowned(unsafe)"}],"type":"strong"}],"type":"paragraph"}],"name":"Grammar of a closure expression","style":"note","type":"aside"},{"level":3,"text":"Implicit Member Expression","type":"heading","anchor":"Implicit-Member-Expression"},{"inlineContent":[{"type":"text","text":"An "},{"inlineContent":[{"type":"text","text":"implicit member expression"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"is an abbreviated way to access a member of a type,"},{"type":"text","text":" "},{"type":"text","text":"such as an enumeration case or a type method,"},{"type":"text","text":" "},{"type":"text","text":"in a context where type inference"},{"text":" ","type":"text"},{"type":"text","text":"can determine the implied type."},{"text":" ","type":"text"},{"text":"It has the following form:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":[".<#member name#>"],"type":"codeListing"},{"inlineContent":[{"text":"For example:","type":"text"}],"type":"paragraph"},{"code":["var x = MyEnumeration.someValue","x = .anotherValue"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the inferred type is an optional,"},{"type":"text","text":" "},{"type":"text","text":"you can also use a member of the non-optional type"},{"type":"text","text":" "},{"text":"in an implicit member expression.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["var someOptional: MyEnumeration? = .someValue"]},{"type":"paragraph","inlineContent":[{"text":"Implicit member expressions can be followed by","type":"text"},{"type":"text","text":" "},{"type":"text","text":"a postfix operator or other postfix syntax listed in"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Expressions#Postfix-Expressions"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This is called a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"chained implicit member expression"}]},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Although it’s common for all of the chained postfix expressions"},{"type":"text","text":" "},{"type":"text","text":"to have the same type,"},{"text":" ","type":"text"},{"type":"text","text":"the only requirement is that the whole chained implicit member expression"},{"type":"text","text":" "},{"type":"text","text":"needs to be convertible to the type implied by its context."},{"type":"text","text":" "},{"type":"text","text":"Specifically,"},{"type":"text","text":" "},{"text":"if the implied type is an optional","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"you can use a value of the non-optional type,"},{"type":"text","text":" "},{"type":"text","text":"and if the implied type is a class type"},{"type":"text","text":" "},{"type":"text","text":"you can use a value of one of its subclasses."},{"type":"text","text":" "},{"text":"For example:","type":"text"}]},{"code":["class SomeClass {","    static var shared = SomeClass()","    static var sharedSubclass = SomeSubclass()","    var a = AnotherClass()","}","class SomeSubclass: SomeClass { }","class AnotherClass {","    static var s = SomeClass()","    func f() -> SomeClass { return AnotherClass.s }","}","let x: SomeClass = .shared.a.f()","let y: SomeClass? = .shared","let z: SomeClass = .sharedSubclass"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"In the code above,","type":"text"},{"text":" ","type":"text"},{"text":"the type of ","type":"text"},{"type":"codeVoice","code":"x"},{"type":"text","text":" matches the type implied by its context exactly,"},{"type":"text","text":" "},{"type":"text","text":"the type of "},{"code":"y","type":"codeVoice"},{"text":" is convertible from ","type":"text"},{"type":"codeVoice","code":"SomeClass"},{"type":"text","text":" to "},{"type":"codeVoice","code":"SomeClass?"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"and the type of ","type":"text"},{"type":"codeVoice","code":"z"},{"type":"text","text":" is convertible from "},{"type":"codeVoice","code":"SomeSubclass"},{"type":"text","text":" to "},{"code":"SomeClass","type":"codeVoice"},{"type":"text","text":"."}]},{"style":"note","type":"aside","name":"Grammar of an implicit member expression","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"implicit-member-expression"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"codeVoice","code":"."}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"identifier","type":"text"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"implicit-member-expression"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"code":".","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"identifier"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"."}]},{"type":"text","text":" "},{"inlineContent":[{"text":"postfix-expression","type":"text"}],"type":"emphasis"}],"type":"paragraph"}]},{"type":"heading","level":3,"anchor":"Parenthesized-Expression","text":"Parenthesized Expression"},{"inlineContent":[{"text":"A ","type":"text"},{"inlineContent":[{"text":"parenthesized expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" consists of"},{"text":" ","type":"text"},{"text":"an expression surrounded by parentheses.","type":"text"},{"type":"text","text":" "},{"text":"You can use parentheses to specify the precedence of operations","type":"text"},{"type":"text","text":" "},{"type":"text","text":"by explicitly grouping expressions."},{"text":" ","type":"text"},{"text":"Grouping parentheses don’t change an expression’s type —","type":"text"},{"text":" ","type":"text"},{"text":"for example, the type of ","type":"text"},{"type":"codeVoice","code":"(1)"},{"type":"text","text":" is simply "},{"code":"Int","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"parenthesized-expression"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"code":"(","type":"codeVoice"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":")"}],"type":"strong"}]}],"name":"Grammar of a parenthesized expression","type":"aside"},{"anchor":"Tuple-Expression","type":"heading","text":"Tuple Expression","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"inlineContent":[{"text":"tuple expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" consists of"},{"type":"text","text":" "},{"type":"text","text":"a comma-separated list of expressions surrounded by parentheses."},{"type":"text","text":" "},{"type":"text","text":"Each expression can have an optional identifier before it,"},{"type":"text","text":" "},{"text":"separated by a colon (","type":"text"},{"type":"codeVoice","code":":"},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"type":"codeListing","code":["(<#identifier 1#>: <#expression 1#>, <#identifier 2#>: <#expression 2#>, <#...#>)"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Each identifier in a tuple expression must be unique","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"within the scope of the tuple expression."},{"text":" ","type":"text"},{"text":"In a nested tuple expression,","type":"text"},{"text":" ","type":"text"},{"text":"identifiers at the same level of nesting must be unique.","type":"text"},{"type":"text","text":" "},{"text":"For example,","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"(a: 10, a: 20)"},{"type":"text","text":" is invalid"},{"text":" ","type":"text"},{"text":"because the label ","type":"text"},{"type":"codeVoice","code":"a"},{"type":"text","text":" appears twice at the same level."},{"text":" ","type":"text"},{"text":"However, ","type":"text"},{"type":"codeVoice","code":"(a: 10, b: (a: 1, x: 2))"},{"type":"text","text":" is valid —"},{"type":"text","text":" "},{"type":"text","text":"although "},{"type":"codeVoice","code":"a"},{"type":"text","text":" appears twice,"},{"text":" ","type":"text"},{"type":"text","text":"it appears once in the outer tuple and once in the inner tuple."}]},{"type":"paragraph","inlineContent":[{"text":"A tuple expression can contain zero expressions,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"or it can contain two or more expressions."},{"text":" ","type":"text"},{"type":"text","text":"A single expression inside parentheses is a parenthesized expression."}]},{"style":"note","name":"Note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Both an empty tuple expression and an empty tuple type"},{"type":"text","text":" "},{"type":"text","text":"are written "},{"code":"()","type":"codeVoice"},{"type":"text","text":" in Swift."},{"type":"text","text":" "},{"text":"Because ","type":"text"},{"code":"Void","type":"codeVoice"},{"type":"text","text":" is a type alias for "},{"code":"()","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"you can use it to write an empty tuple type."},{"text":" ","type":"text"},{"text":"However, like all type aliases, ","type":"text"},{"code":"Void","type":"codeVoice"},{"type":"text","text":" is always a type —"},{"text":" ","type":"text"},{"type":"text","text":"you can’t use it to write an empty tuple expression."}]}]},{"type":"aside","style":"note","name":"Grammar of a tuple expression","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"tuple-expression","type":"text"}]},{"type":"text","text":" → "},{"inlineContent":[{"code":"(","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"code":")","type":"codeVoice"}],"type":"strong"},{"text":" | ","type":"text"},{"inlineContent":[{"code":"(","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"tuple-element"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":",","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-element-list"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":")","type":"codeVoice"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"tuple-element-list","type":"text"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"tuple-element"}],"type":"emphasis"},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"text":"tuple-element","type":"text"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":","}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"tuple-element-list","type":"text"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-element"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"expression"}],"type":"emphasis"},{"type":"text","text":" | "},{"inlineContent":[{"text":"identifier","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":":"}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]}],"type":"paragraph"}]},{"text":"Wildcard Expression","type":"heading","level":3,"anchor":"Wildcard-Expression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"text":"wildcard expression","type":"text"}]},{"type":"text","text":" "},{"type":"text","text":"is used to explicitly ignore a value during an assignment."},{"text":" ","type":"text"},{"type":"text","text":"For example, in the following assignment"},{"type":"text","text":" "},{"type":"text","text":"10 is assigned to "},{"code":"x","type":"codeVoice"},{"text":" and 20 is ignored:","type":"text"}]},{"syntax":"swift","code":["(x, _) = (10, 20)","\/\/ x is 10, and 20 is ignored"],"type":"codeListing"},{"style":"note","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"wildcard-expression"}]},{"type":"text","text":" → "},{"inlineContent":[{"code":"_","type":"codeVoice"}],"type":"strong"}]}],"type":"aside","name":"Grammar of a wildcard expression"},{"type":"heading","anchor":"Macro-Expansion-Expression","text":"Macro-Expansion Expression","level":3},{"type":"paragraph","inlineContent":[{"text":"A ","type":"text"},{"inlineContent":[{"text":"macro-expansion expression","type":"text"}],"type":"emphasis"},{"text":" consists of a macro name","type":"text"},{"type":"text","text":" "},{"type":"text","text":"followed by a comma-separated list of the macro’s arguments in parentheses."},{"text":" ","type":"text"},{"text":"The macro is expanded at compile time.","type":"text"},{"type":"text","text":" "},{"text":"Macro-expansion expressions have the following form:","type":"text"}]},{"code":["<#macro name#>(<#macro argument 1#>, <#macro argument 2#>)"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"A macro-expansion expression omits the parentheses after the macro’s name"},{"type":"text","text":" "},{"text":"if the macro doesn’t take any arguments.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"A macro-expansion expression can’t appear as the default value for a parameter,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"except the "},{"isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/file()","type":"reference","overridingTitle":"file()","overridingTitleInlineContent":[{"code":"file()","type":"codeVoice"}]},{"type":"text","text":" and "},{"overridingTitle":"line()","isActive":true,"overridingTitleInlineContent":[{"type":"codeVoice","code":"line()"}],"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/line()","type":"reference"},{"text":" macros from the Swift standard library.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"When used as the default value of a function or method parameter,"},{"text":" ","type":"text"},{"text":"these macros are evaluated using the source code location of the call site,","type":"text"},{"type":"text","text":" "},{"text":"not the location where they appear in a function definition.","type":"text"}]},{"inlineContent":[{"type":"text","text":"You use macro expressions to call freestanding macros."},{"type":"text","text":" "},{"type":"text","text":"To call an attached macro,"},{"type":"text","text":" "},{"text":"use the custom attribute syntax described in ","type":"text"},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Attributes","isActive":true,"type":"reference"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"Both freestanding and attached macros expand as follows:"}],"type":"paragraph"},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"text":"Swift parses the source code","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"to produce an abstract syntax tree (AST)."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"The macro implementation receives AST nodes as its input"},{"text":" ","type":"text"},{"text":"and performs the transformations needed by that macro.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"The transformed AST nodes that the macro implementation produced"},{"type":"text","text":" "},{"text":"are added to the original AST.","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"text":"The expansion of each macro is independent and self-contained.","type":"text"},{"text":" ","type":"text"},{"text":"However, as a performance optimization,","type":"text"},{"type":"text","text":" "},{"text":"Swift might start an external process that implements the macro","type":"text"},{"text":" ","type":"text"},{"text":"and reuse the same process to expand multiple macros.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"When you implement a macro,"},{"text":" ","type":"text"},{"type":"text","text":"that code must not depend on what macros your code previously expanded,"},{"text":" ","type":"text"},{"type":"text","text":"or on any other external state like the current time."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For nested macros and attached macros that have multiple roles,"},{"text":" ","type":"text"},{"text":"the expansion process repeats.","type":"text"},{"type":"text","text":" "},{"text":"Nested macro-expansion expressions expand from the outside in.","type":"text"},{"text":" ","type":"text"},{"text":"For example, in the code below","type":"text"},{"text":" ","type":"text"},{"code":"outerMacro(_:)","type":"codeVoice"},{"text":" expands first and the unexpanded call to ","type":"text"},{"code":"innerMacro(_:)","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"appears in the abstract syntax tree"},{"type":"text","text":" "},{"type":"text","text":"that "},{"code":"outerMacro(_:)","type":"codeVoice"},{"type":"text","text":" receives as its input."}]},{"code":["#outerMacro(12, #innerMacro(34), \"some text\")"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"An attached macro that has multiple roles expands once for each role."},{"text":" ","type":"text"},{"text":"Each expansion receives the same, original, AST as its input.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Swift forms the overall expansion"},{"type":"text","text":" "},{"type":"text","text":"by collecting all of the generated AST nodes"},{"type":"text","text":" "},{"text":"and putting them in their corresponding places in the AST.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"For an overview of macros in Swift, see ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Macros"},{"text":".","type":"text"}],"type":"paragraph"},{"name":"Grammar of a macro-expansion expression","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"inlineContent":[{"type":"text","text":"macro-expansion-expression"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"code":"#","type":"codeVoice"}],"type":"strong"},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"identifier"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"text":"generic-argument-clause","type":"text"}],"type":"emphasis"},{"inlineContent":[{"text":"?","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"function-call-argument-clause"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"trailing-closures"}]},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]}],"type":"paragraph"}],"type":"aside","style":"note"},{"anchor":"Key-Path-Expression","text":"Key-Path Expression","level":3,"type":"heading"},{"inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"text":"key-path expression","type":"text"}]},{"text":" ","type":"text"},{"type":"text","text":"refers to a property or subscript of a type."},{"text":" ","type":"text"},{"type":"text","text":"You use key-path expressions"},{"type":"text","text":" "},{"text":"in dynamic programming tasks,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"such as key-value observing."},{"text":" ","type":"text"},{"type":"text","text":"They have the following form:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["\\<#type name#>.<#path#>"]},{"inlineContent":[{"type":"text","text":"The "},{"inlineContent":[{"type":"text","text":"type name"}],"type":"emphasis"},{"text":" is the name of a concrete type,","type":"text"},{"type":"text","text":" "},{"text":"including any generic parameters,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"such as "},{"type":"codeVoice","code":"String"},{"text":", ","type":"text"},{"type":"codeVoice","code":"[Int]"},{"text":", or ","type":"text"},{"type":"codeVoice","code":"Set<Int>"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"path","type":"text"}]},{"text":" consists of","type":"text"},{"type":"text","text":" "},{"type":"text","text":"property names, subscripts, optional-chaining expressions,"},{"type":"text","text":" "},{"type":"text","text":"and forced unwrapping expressions."},{"text":" ","type":"text"},{"text":"Each of these key-path components","type":"text"},{"type":"text","text":" "},{"type":"text","text":"can be repeated as many times as needed,"},{"text":" ","type":"text"},{"type":"text","text":"in any order."}]},{"type":"paragraph","inlineContent":[{"text":"At compile time, a key-path expression","type":"text"},{"type":"text","text":" "},{"type":"text","text":"is replaced by an instance"},{"type":"text","text":" "},{"type":"text","text":"of the "},{"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/keypath","isActive":true},{"text":" class.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"To access a value using a key path,","type":"text"},{"type":"text","text":" "},{"text":"pass the key path to the ","type":"text"},{"type":"codeVoice","code":"subscript(keyPath:)"},{"text":" subscript,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"which is available on all types."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","code":["struct SomeStructure {","    var someValue: Int","}","","let s = SomeStructure(someValue: 12)","let pathToProperty = \\SomeStructure.someValue","","let value = s[keyPath: pathToProperty]","\/\/ value is 12"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"text":"type name","type":"text"}]},{"type":"text","text":" can be omitted"},{"type":"text","text":" "},{"type":"text","text":"in contexts where type inference"},{"text":" ","type":"text"},{"type":"text","text":"can determine the implied type."},{"text":" ","type":"text"},{"text":"The following code uses ","type":"text"},{"code":"\\.someProperty","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"instead of "},{"type":"codeVoice","code":"\\SomeClass.someProperty"},{"type":"text","text":":"}],"type":"paragraph"},{"code":["class SomeClass: NSObject {","    @objc dynamic var someProperty: Int","    init(someProperty: Int) {","        self.someProperty = someProperty","    }","}","","let c = SomeClass(someProperty: 10)","c.observe(\\.someProperty) { object, change in","    \/\/ ...","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"path"}]},{"text":" can refer to ","type":"text"},{"code":"self","type":"codeVoice"},{"type":"text","text":" to create the identity key path ("},{"code":"\\.self","type":"codeVoice"},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"The identity key path refers to a whole instance,"},{"type":"text","text":" "},{"text":"so you can use it to access and change all of the data stored in a variable","type":"text"},{"type":"text","text":" "},{"text":"in a single step.","type":"text"},{"text":" ","type":"text"},{"text":"For example:","type":"text"}]},{"code":["var compoundValue = (a: 1, b: 2)","\/\/ Equivalent to compoundValue = (a: 10, b: 20)","compoundValue[keyPath: \\.self] = (a: 10, b: 20)"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"The ","type":"text"},{"inlineContent":[{"type":"text","text":"path"}],"type":"emphasis"},{"text":" can contain multiple property names,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"separated by periods,"},{"type":"text","text":" "},{"type":"text","text":"to refer to a property of a property’s value."},{"type":"text","text":" "},{"text":"This code uses the key path expression","type":"text"},{"type":"text","text":" "},{"code":"\\OuterStructure.outer.someValue","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"to access the "},{"code":"someValue","type":"codeVoice"},{"type":"text","text":" property"},{"text":" ","type":"text"},{"type":"text","text":"of the "},{"type":"codeVoice","code":"OuterStructure"},{"text":" type’s ","type":"text"},{"type":"codeVoice","code":"outer"},{"type":"text","text":" property:"}],"type":"paragraph"},{"type":"codeListing","code":["struct OuterStructure {","    var outer: SomeStructure","    init(someValue: Int) {","        self.outer = SomeStructure(someValue: someValue)","    }","}","","let nested = OuterStructure(someValue: 24)","let nestedKeyPath = \\OuterStructure.outer.someValue","","let nestedValue = nested[keyPath: nestedKeyPath]","\/\/ nestedValue is 24"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"text":"path","type":"text"}]},{"type":"text","text":" can include subscripts using brackets,"},{"type":"text","text":" "},{"text":"as long as the subscript’s parameter type conforms to the ","type":"text"},{"code":"Hashable","type":"codeVoice"},{"text":" protocol.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This example uses a subscript in a key path"},{"type":"text","text":" "},{"type":"text","text":"to access the second element of an array:"}]},{"type":"codeListing","syntax":"swift","code":["let greetings = [\"hello\", \"hola\", \"bonjour\", \"안녕\"]","let myGreeting = greetings[keyPath: \\[String].[1]]","\/\/ myGreeting is 'hola'"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The value used in a subscript can be a named value or a literal."},{"type":"text","text":" "},{"type":"text","text":"Values are captured in key paths using value semantics."},{"type":"text","text":" "},{"type":"text","text":"The following code uses the variable "},{"type":"codeVoice","code":"index"},{"type":"text","text":" "},{"type":"text","text":"in both a key-path expression and in a closure to access"},{"type":"text","text":" "},{"type":"text","text":"the third element of the "},{"type":"codeVoice","code":"greetings"},{"text":" array.","type":"text"},{"text":" ","type":"text"},{"text":"When ","type":"text"},{"type":"codeVoice","code":"index"},{"type":"text","text":" is modified,"},{"text":" ","type":"text"},{"type":"text","text":"the key-path expression still references the third element,"},{"type":"text","text":" "},{"text":"while the closure uses the new index.","type":"text"}]},{"type":"codeListing","code":["var index = 2","let path = \\[String].[index]","let fn: ([String]) -> String = { strings in strings[index] }","","print(greetings[keyPath: path])","\/\/ Prints \"bonjour\"","print(fn(greetings))","\/\/ Prints \"bonjour\"","","\/\/ Setting 'index' to a new value doesn't affect 'path'","index += 1","print(greetings[keyPath: path])","\/\/ Prints \"bonjour\"","","\/\/ Because 'fn' closes over 'index', it uses the new value","print(fn(greetings))","\/\/ Prints \"안녕\""],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"inlineContent":[{"type":"text","text":"path"}],"type":"emphasis"},{"type":"text","text":" can use optional chaining and forced unwrapping."},{"type":"text","text":" "},{"type":"text","text":"This code uses optional chaining in a key path"},{"text":" ","type":"text"},{"type":"text","text":"to access a property of an optional string:"}]},{"type":"codeListing","syntax":"swift","code":["let firstGreeting: String? = greetings.first","print(firstGreeting?.count as Any)","\/\/ Prints \"Optional(5)\"","","\/\/ Do the same thing using a key path.","let count = greetings[keyPath: \\[String].first?.count]","print(count as Any)","\/\/ Prints \"Optional(5)\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can mix and match components of key paths to access values"},{"text":" ","type":"text"},{"text":"that are deeply nested within a type.","type":"text"},{"text":" ","type":"text"},{"text":"The following code accesses different values and properties","type":"text"},{"text":" ","type":"text"},{"text":"of a dictionary of arrays","type":"text"},{"type":"text","text":" "},{"text":"by using key-path expressions","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that combine these components."}]},{"code":["let interestingNumbers = [\"prime\": [2, 3, 5, 7, 11, 13, 17],","                          \"triangular\": [1, 3, 6, 10, 15, 21, 28],","                          \"hexagonal\": [1, 6, 15, 28, 45, 66, 91]]","print(interestingNumbers[keyPath: \\[String: [Int]].[\"prime\"]] as Any)","\/\/ Prints \"Optional([2, 3, 5, 7, 11, 13, 17])\"","print(interestingNumbers[keyPath: \\[String: [Int]].[\"prime\"]![0]])","\/\/ Prints \"2\"","print(interestingNumbers[keyPath: \\[String: [Int]].[\"hexagonal\"]!.count])","\/\/ Prints \"7\"","print(interestingNumbers[keyPath: \\[String: [Int]].[\"hexagonal\"]!.count.bitWidth])","\/\/ Prints \"64\""],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use a key path expression"},{"type":"text","text":" "},{"text":"in contexts where you would normally provide a function or closure.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Specifically,"},{"text":" ","type":"text"},{"type":"text","text":"you can use a key path expression"},{"type":"text","text":" "},{"type":"text","text":"whose root type is "},{"type":"codeVoice","code":"SomeType"},{"text":" ","type":"text"},{"text":"and whose path produces a value of type ","type":"text"},{"type":"codeVoice","code":"Value"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"instead of a function or closure of type "},{"code":"(SomeType) -> Value","type":"codeVoice"},{"type":"text","text":"."}]},{"code":["struct Task {","    var description: String","    var completed: Bool","}","var toDoList = [","    Task(description: \"Practice ping-pong.\", completed: false),","    Task(description: \"Buy a pirate costume.\", completed: true),","    Task(description: \"Visit Boston in the Fall.\", completed: false),","]","","\/\/ Both approaches below are equivalent.","let descriptions = toDoList.filter(\\.completed).map(\\.description)","let descriptions2 = toDoList.filter { $0.completed }.map { $0.description }"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Any side effects of a key path expression"},{"type":"text","text":" "},{"type":"text","text":"are evaluated only at the point where the expression is evaluated."},{"text":" ","type":"text"},{"text":"For example,","type":"text"},{"type":"text","text":" "},{"text":"if you make a function call inside a subscript in a key path expression,","type":"text"},{"text":" ","type":"text"},{"text":"the function is called only once as part of evaluating the expression,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"not every time the key path is used."}]},{"code":["func makeIndex() -> Int {","    print(\"Made an index\")","    return 0","}","\/\/ The line below calls makeIndex().","let taskKeyPath = \\[Task][makeIndex()]","\/\/ Prints \"Made an index\"","","\/\/ Using taskKeyPath doesn't call makeIndex() again.","let someTask = toDoList[keyPath: taskKeyPath]"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more information about using key paths"},{"text":" ","type":"text"},{"type":"text","text":"in code that interacts with Objective-C APIs,"},{"text":" ","type":"text"},{"text":"see ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/using_objective_c_runtime_features_in_swift"},{"text":".","type":"text"},{"type":"text","text":" "},{"text":"For information about key-value coding and key-value observing,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"see "},{"identifier":"https:\/\/developer.apple.com\/library\/content\/documentation\/Cocoa\/Conceptual\/KeyValueCoding\/index.html#\/\/apple_ref\/doc\/uid\/10000107i","type":"reference","isActive":true},{"type":"text","text":" "},{"text":"and ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/library\/content\/documentation\/Cocoa\/Conceptual\/KeyValueObserving\/KeyValueObserving.html#\/\/apple_ref\/doc\/uid\/10000177i","type":"reference","isActive":true},{"type":"text","text":"."}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"key-path-expression"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"codeVoice","code":"\\"}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"inlineContent":[{"text":"?","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":"."}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"key-path-components"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"key-path-components"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"text":"key-path-component","type":"text"}],"type":"emphasis"},{"type":"text","text":" | "},{"inlineContent":[{"text":"key-path-component","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"."}]},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"key-path-components"}],"type":"emphasis"},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"key-path-component"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"key-path-postfixes"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" | "},{"inlineContent":[{"type":"text","text":"key-path-postfixes"}],"type":"emphasis"}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"key-path-postfixes","type":"text"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"key-path-postfix"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"key-path-postfixes","type":"text"}]},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"key-path-postfix"}]},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"?"}]},{"text":" | ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"!"}]},{"type":"text","text":" | "},{"inlineContent":[{"code":"self","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" | "},{"inlineContent":[{"code":"[","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"text":"function-call-argument-list","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":"]"}],"type":"strong"}],"type":"paragraph"}],"type":"aside","style":"note","name":"Grammar of a key-path expression"},{"level":3,"anchor":"Selector-Expression","text":"Selector Expression","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"A selector expression lets you access the selector","type":"text"},{"text":" ","type":"text"},{"text":"used to refer to a method or to a property’s","type":"text"},{"type":"text","text":" "},{"type":"text","text":"getter or setter in Objective-C."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"syntax":"swift","code":["#selector(<#method name#>)","#selector(getter: <#property name#>)","#selector(setter: <#property name#>)"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"method name","type":"text"}]},{"type":"text","text":" and "},{"type":"emphasis","inlineContent":[{"text":"property name","type":"text"}]},{"type":"text","text":" must be a reference to a method or a property"},{"type":"text","text":" "},{"type":"text","text":"that’s available in the Objective-C runtime."},{"type":"text","text":" "},{"text":"The value of a selector expression is an instance of the ","type":"text"},{"code":"Selector","type":"codeVoice"},{"type":"text","text":" type."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","code":["class SomeClass: NSObject {","    @objc let property: String","","    @objc(doSomethingWithInt:)","    func doSomething(_ x: Int) { }","","    init(property: String) {","        self.property = property","    }","}","let selectorForMethod = #selector(SomeClass.doSomething(_:))","let selectorForPropertyGetter = #selector(getter: SomeClass.property)"],"syntax":"swift"},{"inlineContent":[{"text":"When creating a selector for a property’s getter,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the "},{"inlineContent":[{"type":"text","text":"property name"}],"type":"emphasis"},{"type":"text","text":" can be a reference to a variable or constant property."},{"type":"text","text":" "},{"type":"text","text":"In contrast, when creating a selector for a property’s setter,"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"property name","type":"text"}]},{"type":"text","text":" must be a reference to a variable property only."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"method name","type":"text"}]},{"type":"text","text":" can contain parentheses for grouping,"},{"text":" ","type":"text"},{"type":"text","text":"as well the "},{"type":"codeVoice","code":"as"},{"type":"text","text":" operator to disambiguate between methods that share a name"},{"text":" ","type":"text"},{"text":"but have different type signatures.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"code":["extension SomeClass {","    @objc(doSomethingWithString:)","    func doSomething(_ x: String) { }","}","let anotherSelector = #selector(SomeClass.doSomething(_:) as (SomeClass) -> (String) -> Void)"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Because a selector is created at compile time, not at runtime,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the compiler can check that a method or property exists"},{"text":" ","type":"text"},{"text":"and that they’re exposed to the Objective-C runtime.","type":"text"}]},{"content":[{"inlineContent":[{"type":"text","text":"Although the "},{"inlineContent":[{"type":"text","text":"method name"}],"type":"emphasis"},{"type":"text","text":" and the "},{"inlineContent":[{"type":"text","text":"property name"}],"type":"emphasis"},{"text":" are expressions,","type":"text"},{"type":"text","text":" "},{"text":"they’re never evaluated.","type":"text"}],"type":"paragraph"}],"type":"aside","style":"note","name":"Note"},{"inlineContent":[{"text":"For more information about using selectors","type":"text"},{"text":" ","type":"text"},{"text":"in Swift code that interacts with Objective-C APIs,","type":"text"},{"type":"text","text":" "},{"text":"see ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/using_objective_c_runtime_features_in_swift","type":"reference","overridingTitle":"Using Objective-C Runtime Features in Swift","overridingTitleInlineContent":[{"type":"text","text":"Using Objective-C Runtime Features in Swift"}],"isActive":true},{"text":".","type":"text"}],"type":"paragraph"},{"style":"note","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"inlineContent":[{"inlineContent":[{"text":"selector-expression","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"#selector"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"("}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":")","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"selector-expression"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"code":"#selector","type":"codeVoice"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":"("}],"type":"strong"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":"getter:","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":")"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"selector-expression","type":"text"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"#selector"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"("}]},{"type":"text","text":" "},{"inlineContent":[{"code":"setter:","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":")","type":"codeVoice"}]}],"type":"paragraph"}],"name":"Grammar of a selector expression","type":"aside"},{"type":"heading","text":"Key-Path String Expression","level":3,"anchor":"Key-Path-String-Expression"},{"type":"paragraph","inlineContent":[{"text":"A key-path string expression lets you access the string","type":"text"},{"type":"text","text":" "},{"text":"used to refer to a property in Objective-C,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"for use in key-value coding and key-value observing APIs."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"syntax":"swift","code":["#keyPath(<#property name#>)"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"text":"property name","type":"text"}]},{"text":" must be a reference to a property","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that’s available in the Objective-C runtime."},{"type":"text","text":" "},{"type":"text","text":"At compile time, the key-path string expression is replaced by a string literal."},{"text":" ","type":"text"},{"type":"text","text":"For example:"}],"type":"paragraph"},{"syntax":"swift","code":["class SomeClass: NSObject {","    @objc var someProperty: Int","    init(someProperty: Int) {","       self.someProperty = someProperty","    }","}","","let c = SomeClass(someProperty: 12)","let keyPath = #keyPath(SomeClass.someProperty)","","if let value = c.value(forKey: keyPath) {","    print(value)","}","\/\/ Prints \"12\""],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"When you use a key-path string expression within a class,"},{"type":"text","text":" "},{"type":"text","text":"you can refer to a property of that class"},{"text":" ","type":"text"},{"text":"by writing just the property name, without the class name.","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["extension SomeClass {","    func getSomeKeyPath() -> String {","        return #keyPath(someProperty)","    }","}","print(keyPath == c.getSomeKeyPath())","\/\/ Prints \"true\""],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because the key path string is created at compile time, not at runtime,"},{"text":" ","type":"text"},{"text":"the compiler can check that the property exists","type":"text"},{"text":" ","type":"text"},{"text":"and that the property is exposed to the Objective-C runtime.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more information about using key paths"},{"text":" ","type":"text"},{"type":"text","text":"in Swift code that interacts with Objective-C APIs,"},{"text":" ","type":"text"},{"text":"see ","type":"text"},{"overridingTitle":"Using Objective-C Runtime Features in Swift","overridingTitleInlineContent":[{"text":"Using Objective-C Runtime Features in Swift","type":"text"}],"isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/using_objective_c_runtime_features_in_swift","type":"reference"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"For information about key-value coding and key-value observing,"},{"text":" ","type":"text"},{"text":"see ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/library\/content\/documentation\/Cocoa\/Conceptual\/KeyValueCoding\/index.html#\/\/apple_ref\/doc\/uid\/10000107i","type":"reference","isActive":true,"overridingTitle":"Key-Value Coding Programming Guide","overridingTitleInlineContent":[{"type":"text","text":"Key-Value Coding Programming Guide"}]},{"type":"text","text":" "},{"text":"and ","type":"text"},{"overridingTitleInlineContent":[{"text":"Key-Value Observing Programming Guide","type":"text"}],"isActive":true,"overridingTitle":"Key-Value Observing Programming Guide","identifier":"https:\/\/developer.apple.com\/library\/content\/documentation\/Cocoa\/Conceptual\/KeyValueObserving\/KeyValueObserving.html#\/\/apple_ref\/doc\/uid\/10000177i","type":"reference"},{"type":"text","text":"."}]},{"name":"Note","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"Although the ","type":"text"},{"inlineContent":[{"text":"property name","type":"text"}],"type":"emphasis"},{"type":"text","text":" is an expression, it’s never evaluated."}]}],"type":"aside"},{"type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"key-path-string-expression","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"code":"#keyPath","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"("}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":")"}]}]}],"style":"note","name":"Grammar of a key-path string expression"},{"type":"heading","text":"Postfix Expressions","level":2,"anchor":"Postfix-Expressions"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Postfix expressions"}]},{"text":" are formed","type":"text"},{"text":" ","type":"text"},{"text":"by applying a postfix operator or other postfix syntax","type":"text"},{"text":" ","type":"text"},{"text":"to an expression.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Syntactically, every primary expression is also a postfix expression."}]},{"type":"paragraph","inlineContent":[{"text":"For information about the behavior of these operators,","type":"text"},{"text":" ","type":"text"},{"text":"see ","type":"text"},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators","isActive":true},{"type":"text","text":" and "},{"isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators","type":"reference"},{"text":".","type":"text"}]},{"inlineContent":[{"text":"For information about the operators provided by the Swift standard library,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"see "},{"overridingTitle":"Operator Declarations","overridingTitleInlineContent":[{"type":"text","text":"Operator Declarations"}],"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","isActive":true,"type":"reference"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"aside","style":"note","name":"Grammar of a postfix expression","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"postfix-expression"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"text":"primary-expression","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"postfix-expression"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"postfix-expression"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"text":"postfix-operator","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"inlineContent":[{"text":"postfix-expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"function-call-expression"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"postfix-expression","type":"text"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"initializer-expression","type":"text"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"postfix-expression"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"text":"explicit-member-expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"postfix-expression"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"postfix-self-expression"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"postfix-expression","type":"text"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"subscript-expression","type":"text"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"postfix-expression"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"forced-value-expression"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"postfix-expression","type":"text"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"optional-chaining-expression"}]}]}]},{"level":3,"anchor":"Function-Call-Expression","type":"heading","text":"Function Call Expression"},{"inlineContent":[{"type":"text","text":"A "},{"inlineContent":[{"text":"function call expression","type":"text"}],"type":"emphasis"},{"text":" consists of a function name","type":"text"},{"type":"text","text":" "},{"type":"text","text":"followed by a comma-separated list of the function’s arguments in parentheses."},{"text":" ","type":"text"},{"type":"text","text":"Function call expressions have the following form:"}],"type":"paragraph"},{"syntax":"swift","code":["<#function name#>(<#argument value 1#>, <#argument value 2#>)"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"text":"function name","type":"text"}]},{"text":" can be any expression whose value is of a function type.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"If the function definition includes names for its parameters,"},{"type":"text","text":" "},{"type":"text","text":"the function call must include names before its argument values,"},{"type":"text","text":" "},{"type":"text","text":"separated by a colon ("},{"type":"codeVoice","code":":"},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"This kind of function call expression has the following form:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["<#function name#>(<#argument name 1#>: <#argument value 1#>, <#argument name 2#>: <#argument value 2#>)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A function call expression can include trailing closures"},{"type":"text","text":" "},{"type":"text","text":"in the form of closure expressions immediately after the closing parenthesis."},{"text":" ","type":"text"},{"type":"text","text":"The trailing closures are understood as arguments to the function,"},{"text":" ","type":"text"},{"text":"added after the last parenthesized argument.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The first closure expression is unlabeled;"},{"type":"text","text":" "},{"type":"text","text":"any additional closure expressions are preceded by their argument labels."},{"text":" ","type":"text"},{"text":"The example below shows the equivalent version of function calls","type":"text"},{"type":"text","text":" "},{"text":"that do and don’t use trailing closure syntax:","type":"text"}]},{"code":["\/\/ someFunction takes an integer and a closure as its arguments","someFunction(x: x, f: { $0 == 13 })","someFunction(x: x) { $0 == 13 }","","\/\/ anotherFunction takes an integer and two closures as its arguments","anotherFunction(x: x, f: { $0 == 13 }, g: { print(99) })","anotherFunction(x: x) { $0 == 13 } g: { print(99) }"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"If the trailing closure is the function’s only argument,"},{"type":"text","text":" "},{"text":"you can omit the parentheses.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["\/\/ someMethod takes a closure as its only argument","myData.someMethod() { $0 == 13 }","myData.someMethod { $0 == 13 }"],"type":"codeListing"},{"inlineContent":[{"text":"To include the trailing closures in the arguments,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the compiler examines the function’s parameters from left to right as follows:"}],"type":"paragraph"},{"rows":[[[{"type":"paragraph","inlineContent":[{"text":"Trailing Closure","type":"text"}]}],[{"type":"paragraph","inlineContent":[{"text":"Parameter","type":"text"}]}],[{"inlineContent":[{"type":"text","text":"Action"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"text","text":"Labeled"}],"type":"paragraph"}],[{"type":"paragraph","inlineContent":[{"text":"Labeled","type":"text"}]}],[{"inlineContent":[{"type":"text","text":"If the labels are the same, the closure matches the parameter; otherwise, the parameter is skipped."}],"type":"paragraph"}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Labeled"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Unlabeled"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"The parameter is skipped."}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Unlabeled"}]}],[{"inlineContent":[{"text":"Labeled or unlabeled","type":"text"}],"type":"paragraph"}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"If the parameter structurally resembles a function type, as defined below, the closure matches the parameter; otherwise, the parameter is skipped."}]}]]],"header":"row","type":"table"},{"type":"paragraph","inlineContent":[{"text":"The trailing closure is passed as the argument for the parameter that it matches.","type":"text"},{"type":"text","text":" "},{"text":"Parameters that were skipped during the scanning process","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"don’t have an argument passed to them —"},{"text":" ","type":"text"},{"type":"text","text":"for example, they can use a default parameter."},{"text":" ","type":"text"},{"text":"After finding a match, scanning continues","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"with the next trailing closure and the next parameter."},{"text":" ","type":"text"},{"type":"text","text":"At the end of the matching process,"},{"text":" ","type":"text"},{"text":"all trailing closures must have a match.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A parameter "},{"inlineContent":[{"text":"structurally resembles","type":"text"}],"type":"emphasis"},{"type":"text","text":" a function type"},{"text":" ","type":"text"},{"type":"text","text":"if the parameter isn’t an in-out parameter,"},{"type":"text","text":" "},{"text":"and the parameter is one of the following:","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A parameter whose type is a function type,"},{"type":"text","text":" "},{"type":"text","text":"like "},{"code":"(Bool) -> Int","type":"codeVoice"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"An autoclosure parameter"},{"type":"text","text":" "},{"type":"text","text":"whose wrapped expression’s type is a function type,"},{"type":"text","text":" "},{"type":"text","text":"like "},{"type":"codeVoice","code":"@autoclosure () -> ((Bool) -> Int)"}]}]},{"content":[{"inlineContent":[{"text":"A variadic parameter","type":"text"},{"text":" ","type":"text"},{"text":"whose array element type is a function type,","type":"text"},{"type":"text","text":" "},{"text":"like ","type":"text"},{"type":"codeVoice","code":"((Bool) -> Int)..."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"A parameter whose type is wrapped in one or more layers of optional,","type":"text"},{"type":"text","text":" "},{"text":"like ","type":"text"},{"type":"codeVoice","code":"Optional<(Bool) -> Int>"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"A parameter whose type combines these allowed types,"},{"type":"text","text":" "},{"type":"text","text":"like "},{"type":"codeVoice","code":"(Optional<(Bool) -> Int>)..."}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"text":"When a trailing closure is matched to a parameter","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"whose type structurally resembles a function type, but isn’t a function,"},{"text":" ","type":"text"},{"type":"text","text":"the closure is wrapped as needed."},{"type":"text","text":" "},{"text":"For example, if the parameter’s type is an optional type,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the closure is wrapped in "},{"type":"codeVoice","code":"Optional"},{"text":" automatically.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"To ease migration of code from versions of Swift prior to 5.3 —","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"which performed this matching from right to left —"},{"text":" ","type":"text"},{"text":"the compiler checks both the left-to-right and right-to-left orderings.","type":"text"},{"type":"text","text":" "},{"text":"If the scan directions produce different results,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the old right-to-left ordering is used"},{"text":" ","type":"text"},{"type":"text","text":"and the compiler generates a warning."},{"type":"text","text":" "},{"type":"text","text":"A future version of Swift will always use the left-to-right ordering."}],"type":"paragraph"},{"code":["typealias Callback = (Int) -> Int","func someFunction(firstClosure: Callback? = nil,","                secondClosure: Callback? = nil) {","    let first = firstClosure?(10)","    let second = secondClosure?(20)","    print(first ?? \"-\", second ?? \"-\")","}","","someFunction()  \/\/ Prints \"- -\"","someFunction { return $0 + 100 }  \/\/ Ambiguous","someFunction { return $0 } secondClosure: { return $0 }  \/\/ Prints \"10 20\""],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the example above,"},{"type":"text","text":" "},{"text":"the function call marked “Ambiguous”","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"prints “- 120” and produces a compiler warning on Swift 5.3."},{"type":"text","text":" "},{"type":"text","text":"A future version of Swift will print “110 -”."}]},{"inlineContent":[{"type":"text","text":"A class, structure, or enumeration type"},{"type":"text","text":" "},{"type":"text","text":"can enable syntactic sugar for function call syntax"},{"type":"text","text":" "},{"text":"by declaring one of several methods,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"as described in "},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Methods-with-Special-Names","isActive":true,"type":"reference"},{"type":"text","text":"."}],"type":"paragraph"},{"anchor":"Implicit-Conversion-to-a-Pointer-Type","level":4,"text":"Implicit Conversion to a Pointer Type","type":"heading"},{"inlineContent":[{"text":"In a function call expression,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"if the argument and parameter have a different type,"},{"type":"text","text":" "},{"text":"the compiler tries to make their types match","type":"text"},{"type":"text","text":" "},{"type":"text","text":"by applying one of the implicit conversions in the following list:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"inout SomeType","type":"codeVoice"},{"text":" can become","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"UnsafePointer<SomeType>"},{"type":"text","text":" or "},{"code":"UnsafeMutablePointer<SomeType>","type":"codeVoice"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"inout Array<SomeType>","type":"codeVoice"},{"type":"text","text":" can become"},{"text":" ","type":"text"},{"type":"codeVoice","code":"UnsafePointer<SomeType>"},{"type":"text","text":" or "},{"type":"codeVoice","code":"UnsafeMutablePointer<SomeType>"}]}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"Array<SomeType>"},{"text":" can become ","type":"text"},{"type":"codeVoice","code":"UnsafePointer<SomeType>"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"code":"String","type":"codeVoice"},{"type":"text","text":" can become "},{"code":"UnsafePointer<CChar>","type":"codeVoice"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The following two function calls are equivalent:"}]},{"syntax":"swift","type":"codeListing","code":["func unsafeFunction(pointer: UnsafePointer<Int>) {","    \/\/ ...","}","var myNumber = 1234","","unsafeFunction(pointer: &myNumber)","withUnsafePointer(to: myNumber) { unsafeFunction(pointer: $0) }"]},{"type":"paragraph","inlineContent":[{"text":"A pointer that’s created by these implicit conversions","type":"text"},{"type":"text","text":" "},{"type":"text","text":"is valid only for the duration of the function call."},{"text":" ","type":"text"},{"type":"text","text":"To avoid undefined behavior,"},{"type":"text","text":" "},{"type":"text","text":"ensure that your code"},{"text":" ","type":"text"},{"type":"text","text":"never persists the pointer after the function call ends."}]},{"type":"aside","content":[{"inlineContent":[{"text":"When implicitly converting an array to an unsafe pointer,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Swift ensures that the array’s storage is contiguous"},{"text":" ","type":"text"},{"type":"text","text":"by converting or copying the array as needed."},{"type":"text","text":" "},{"type":"text","text":"For example, you can use this syntax"},{"type":"text","text":" "},{"text":"with an array that was bridged to ","type":"text"},{"code":"Array","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"from an "},{"type":"codeVoice","code":"NSArray"},{"text":" subclass that makes no API contract about its storage.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"If you need to guarantee that the array’s storage is already contiguous,"},{"text":" ","type":"text"},{"type":"text","text":"so the implicit conversion never needs to do this work,"},{"type":"text","text":" "},{"type":"text","text":"use "},{"code":"ContiguousArray","type":"codeVoice"},{"type":"text","text":" instead of "},{"type":"codeVoice","code":"Array"},{"type":"text","text":"."}],"type":"paragraph"}],"style":"note","name":"Note"},{"inlineContent":[{"text":"Using ","type":"text"},{"type":"codeVoice","code":"&"},{"text":" instead of an explicit function like ","type":"text"},{"code":"withUnsafePointer(to:)","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"can help make calls to low-level C functions more readable,"},{"type":"text","text":" "},{"text":"especially when the function takes several pointer arguments.","type":"text"},{"text":" ","type":"text"},{"text":"However, when calling functions from other Swift code,","type":"text"},{"text":" ","type":"text"},{"text":"avoid using ","type":"text"},{"code":"&","type":"codeVoice"},{"type":"text","text":" instead of using the unsafe APIs explicitly."}],"type":"paragraph"},{"name":"Grammar of a function call expression","style":"note","type":"aside","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"function-call-expression"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"postfix-expression"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"function-call-argument-clause"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"function-call-expression"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"postfix-expression"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"function-call-argument-clause"}],"type":"emphasis"},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"trailing-closures","type":"text"}]}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"function-call-argument-clause"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"("}]},{"text":" ","type":"text"},{"inlineContent":[{"code":")","type":"codeVoice"}],"type":"strong"},{"text":" | ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"("}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"function-call-argument-list"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":")"}],"type":"strong"},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"function-call-argument-list"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"function-call-argument"}]},{"type":"text","text":" | "},{"inlineContent":[{"type":"text","text":"function-call-argument"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"code":",","type":"codeVoice"}],"type":"strong"},{"text":" ","type":"text"},{"inlineContent":[{"text":"function-call-argument-list","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"function-call-argument","type":"text"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"text":" | ","type":"text"},{"inlineContent":[{"type":"text","text":"identifier"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":":","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"function-call-argument"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"operator"}],"type":"emphasis"},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"text":"identifier","type":"text"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":":"}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"operator"}]}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"trailing-closures"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"closure-expression"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"labeled-trailing-closures"}],"type":"emphasis"},{"inlineContent":[{"text":"?","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"labeled-trailing-closures"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"labeled-trailing-closure","type":"text"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"labeled-trailing-closures"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"labeled-trailing-closure","type":"text"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":":"}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"closure-expression"}]}]}]},{"text":"Initializer Expression","anchor":"Initializer-Expression","level":3,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"initializer expression"}]},{"type":"text","text":" provides access"},{"type":"text","text":" "},{"text":"to a type’s initializer.","type":"text"},{"text":" ","type":"text"},{"text":"It has the following form:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["<#expression#>.init(<#initializer arguments#>)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You use the initializer expression in a function call expression"},{"text":" ","type":"text"},{"type":"text","text":"to initialize a new instance of a type."},{"type":"text","text":" "},{"type":"text","text":"You also use an initializer expression"},{"type":"text","text":" "},{"type":"text","text":"to delegate to the initializer of a superclass."}]},{"syntax":"swift","type":"codeListing","code":["class SomeSubClass: SomeSuperClass {","    override init() {","        \/\/ subclass initialization goes here","        super.init()","    }","}"]},{"inlineContent":[{"text":"Like a function, an initializer can be used as a value.","type":"text"},{"text":" ","type":"text"},{"text":"For example:","type":"text"}],"type":"paragraph"},{"code":["\/\/ Type annotation is required because String has multiple initializers.","let initializer: (Int) -> String = String.init","let oneTwoThree = [1, 2, 3].map(initializer).reduce(\"\", +)","print(oneTwoThree)","\/\/ Prints \"123\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"If you specify a type by name,"},{"text":" ","type":"text"},{"text":"you can access the type’s initializer without using an initializer expression.","type":"text"},{"type":"text","text":" "},{"text":"In all other cases, you must use an initializer expression.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let s1 = SomeType.init(data: 3)  \/\/ Valid","let s2 = SomeType(data: 1)       \/\/ Also valid","","let s3 = type(of: someValue).init(data: 7)  \/\/ Valid","let s4 = type(of: someValue)(data: 5)       \/\/ Error"]},{"style":"note","name":"Grammar of an initializer expression","type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"inlineContent":[{"inlineContent":[{"text":"initializer-expression","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"postfix-expression"}]},{"text":" ","type":"text"},{"inlineContent":[{"code":".","type":"codeVoice"}],"type":"strong"},{"text":" ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"init"}],"type":"strong"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"initializer-expression"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"postfix-expression","type":"text"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"."}],"type":"strong"},{"text":" ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"init"}],"type":"strong"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":"(","type":"codeVoice"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"argument-names"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":")","type":"codeVoice"}]}],"type":"paragraph"}]},{"text":"Explicit Member Expression","anchor":"Explicit-Member-Expression","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"text":"An ","type":"text"},{"inlineContent":[{"type":"text","text":"explicit member expression"}],"type":"emphasis"},{"type":"text","text":" allows access"},{"type":"text","text":" "},{"type":"text","text":"to the members of a named type, a tuple, or a module."},{"type":"text","text":" "},{"text":"It consists of a period (","type":"text"},{"code":".","type":"codeVoice"},{"type":"text","text":") between the item"},{"text":" ","type":"text"},{"type":"text","text":"and the identifier of its member."}]},{"syntax":"swift","code":["<#expression#>.<#member name#>"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The members of a named type are named"},{"text":" ","type":"text"},{"type":"text","text":"as part of the type’s declaration or extension."},{"type":"text","text":" "},{"type":"text","text":"For example:"}],"type":"paragraph"},{"code":["class SomeClass {","    var someProperty = 42","}","let c = SomeClass()","let y = c.someProperty  \/\/ Member access"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"The members of a tuple","type":"text"},{"type":"text","text":" "},{"type":"text","text":"are implicitly named using integers in the order they appear,"},{"text":" ","type":"text"},{"text":"starting from zero.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For example:"}]},{"code":["var t = (10, 20, 30)","t.0 = t.1","\/\/ Now t is (20, 20, 30)"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The members of a module access","type":"text"},{"text":" ","type":"text"},{"text":"the top-level declarations of that module.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Types declared with the ","type":"text"},{"code":"dynamicMemberLookup","type":"codeVoice"},{"type":"text","text":" attribute"},{"type":"text","text":" "},{"text":"include members that are looked up at runtime,","type":"text"},{"text":" ","type":"text"},{"text":"as described in ","type":"text"},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Attributes","isActive":true},{"type":"text","text":"."}]},{"inlineContent":[{"type":"text","text":"To distinguish between methods or initializers"},{"text":" ","type":"text"},{"text":"whose names differ only by the names of their arguments,","type":"text"},{"text":" ","type":"text"},{"text":"include the argument names in parentheses,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"with each argument name followed by a colon ("},{"code":":","type":"codeVoice"},{"type":"text","text":")."},{"text":" ","type":"text"},{"text":"Write an underscore (","type":"text"},{"code":"_","type":"codeVoice"},{"type":"text","text":") for an argument with no name."},{"type":"text","text":" "},{"type":"text","text":"To distinguish between overloaded methods,"},{"text":" ","type":"text"},{"text":"use a type annotation.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For example:"}],"type":"paragraph"},{"code":["class SomeClass {","    func someMethod(x: Int, y: Int) {}","    func someMethod(x: Int, z: Int) {}","    func overloadedMethod(x: Int, y: Int) {}","    func overloadedMethod(x: Int, y: Bool) {}","}","let instance = SomeClass()","","let a = instance.someMethod              \/\/ Ambiguous","let b = instance.someMethod(x:y:)        \/\/ Unambiguous","","let d = instance.overloadedMethod        \/\/ Ambiguous","let d = instance.overloadedMethod(x:y:)  \/\/ Still ambiguous","let d: (Int, Bool) -> Void  = instance.overloadedMethod(x:y:)  \/\/ Unambiguous"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a period appears at the beginning of a line,"},{"type":"text","text":" "},{"type":"text","text":"it’s understood as part of an explicit member expression,"},{"text":" ","type":"text"},{"text":"not as an implicit member expression.","type":"text"},{"type":"text","text":" "},{"text":"For example, the following listing shows chained method calls","type":"text"},{"type":"text","text":" "},{"type":"text","text":"split over several lines:"}]},{"code":["let x = [10, 3, 20, 15, 4]","    .sorted()","    .filter { $0 > 5 }","    .map { $0 * 100 }"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"You can combine this multiline chained syntax"},{"text":" ","type":"text"},{"text":"with compiler control statements","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to control when each method is called."},{"type":"text","text":" "},{"text":"For example,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the following code uses a different filtering rule on iOS:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let numbers = [10, 20, 33, 43, 50]","#if os(iOS)","    .filter { $0 < 40 }","#else","    .filter { $0 > 25 }","#endif"]},{"inlineContent":[{"text":"Between ","type":"text"},{"type":"codeVoice","code":"#if"},{"type":"text","text":", "},{"type":"codeVoice","code":"#endif"},{"type":"text","text":", and other compilation directives,"},{"type":"text","text":" "},{"type":"text","text":"the conditional compilation block can contain"},{"type":"text","text":" "},{"text":"an implicit member expression","type":"text"},{"type":"text","text":" "},{"text":"followed by zero or more postfixes,","type":"text"},{"text":" ","type":"text"},{"text":"to form a postfix expression.","type":"text"},{"type":"text","text":" "},{"text":"It can also contain","type":"text"},{"type":"text","text":" "},{"type":"text","text":"another conditional compilation block,"},{"type":"text","text":" "},{"type":"text","text":"or a combination of these expressions and blocks."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"You can use this syntax anywhere that you can write"},{"text":" ","type":"text"},{"text":"an explicit member expression,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"not just in top-level code."}],"type":"paragraph"},{"inlineContent":[{"text":"In the conditional compilation block,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the branch for the "},{"code":"#if","type":"codeVoice"},{"text":" compilation directive","type":"text"},{"type":"text","text":" "},{"text":"must contain at least one expression.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The other branches can be empty."}],"type":"paragraph"},{"name":"Grammar of an explicit member expression","type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"explicit-member-expression"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"text":"postfix-expression","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"."}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"decimal-digits"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"explicit-member-expression","type":"text"}]},{"text":" → ","type":"text"},{"inlineContent":[{"text":"postfix-expression","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":".","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"generic-argument-clause","type":"text"}]},{"inlineContent":[{"text":"?","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"explicit-member-expression","type":"text"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"postfix-expression","type":"text"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":".","type":"codeVoice"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":"(","type":"codeVoice"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"argument-names"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":")","type":"codeVoice"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"text":"explicit-member-expression","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"postfix-expression"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"conditional-compilation-block"}]}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"argument-names","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"text":"argument-name","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"text":"argument-names","type":"text"}],"type":"emphasis"},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"argument-name"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"identifier","type":"text"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":":","type":"codeVoice"}]}]}],"style":"note"},{"level":3,"type":"heading","text":"Postfix Self Expression","anchor":"Postfix-Self-Expression"},{"inlineContent":[{"type":"text","text":"A postfix "},{"type":"codeVoice","code":"self"},{"type":"text","text":" expression consists of an expression or the name of a type,"},{"type":"text","text":" "},{"type":"text","text":"immediately followed by "},{"type":"codeVoice","code":".self"},{"type":"text","text":". It has the following forms:"}],"type":"paragraph"},{"syntax":"swift","code":["<#expression#>.self","<#type#>.self"],"type":"codeListing"},{"inlineContent":[{"text":"The first form evaluates to the value of the ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"For example, "},{"type":"codeVoice","code":"x.self"},{"type":"text","text":" evaluates to "},{"code":"x","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"The second form evaluates to the value of the ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"text":". Use this form","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to access a type as a value. For example,"},{"text":" ","type":"text"},{"text":"because ","type":"text"},{"type":"codeVoice","code":"SomeClass.self"},{"type":"text","text":" evaluates to the "},{"type":"codeVoice","code":"SomeClass"},{"text":" type itself,","type":"text"},{"text":" ","type":"text"},{"text":"you can pass it to a function or method that accepts a type-level argument.","type":"text"}]},{"style":"note","type":"aside","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"postfix-self-expression","type":"text"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"postfix-expression"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"."}]},{"type":"text","text":" "},{"inlineContent":[{"code":"self","type":"codeVoice"}],"type":"strong"}]}],"name":"Grammar of a postfix self expression"},{"text":"Subscript Expression","level":3,"type":"heading","anchor":"Subscript-Expression"},{"inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"text":"subscript expression","type":"text"}]},{"text":" provides subscript access","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"using the getter and setter"},{"type":"text","text":" "},{"type":"text","text":"of the corresponding subscript declaration."},{"text":" ","type":"text"},{"type":"text","text":"It has the following form:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["<#expression#>[<#index expressions#>]"]},{"inlineContent":[{"type":"text","text":"To evaluate the value of a subscript expression,"},{"text":" ","type":"text"},{"type":"text","text":"the subscript getter for the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"text":"’s type is called","type":"text"},{"text":" ","type":"text"},{"text":"with the ","type":"text"},{"inlineContent":[{"text":"index expressions","type":"text"}],"type":"emphasis"},{"text":" passed as the subscript parameters.","type":"text"},{"type":"text","text":" "},{"text":"To set its value,","type":"text"},{"type":"text","text":" "},{"text":"the subscript setter is called in the same way.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"For information about subscript declarations,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Protocol-Subscript-Declaration"},{"text":".","type":"text"}]},{"type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"subscript-expression"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"postfix-expression"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"["}]},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"function-call-argument-list"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"]"}]}],"type":"paragraph"}],"name":"Grammar of a subscript expression","style":"note"},{"text":"Forced-Value Expression","anchor":"Forced-Value-Expression","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"forced-value expression"}]},{"text":" unwraps an optional value","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that you are certain isn’t "},{"code":"nil","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"syntax":"swift","type":"codeListing","code":["<#expression#>!"]},{"inlineContent":[{"type":"text","text":"If the value of the "},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]},{"text":" isn’t ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the optional value is unwrapped"},{"type":"text","text":" "},{"type":"text","text":"and returned with the corresponding non-optional type."},{"text":" ","type":"text"},{"type":"text","text":"Otherwise, a runtime error is raised."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The unwrapped value of a forced-value expression can be modified,"},{"text":" ","type":"text"},{"type":"text","text":"either by mutating the value itself,"},{"text":" ","type":"text"},{"type":"text","text":"or by assigning to one of the value’s members."},{"text":" ","type":"text"},{"text":"For example:","type":"text"}]},{"syntax":"swift","code":["var x: Int? = 0","x! += 1","\/\/ x is now 1","","var someDictionary = [\"a\": [1, 2, 3], \"b\": [10, 20]]","someDictionary[\"a\"]![0] = 100","\/\/ someDictionary is now [\"a\": [100, 2, 3], \"b\": [10, 20]]"],"type":"codeListing"},{"style":"note","type":"aside","name":"Grammar of a forced-value expression","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"forced-value-expression","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"postfix-expression"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":"!","type":"codeVoice"}]}]}]},{"text":"Optional-Chaining Expression","level":3,"type":"heading","anchor":"Optional-Chaining-Expression"},{"inlineContent":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"text":"optional-chaining expression","type":"text"}]},{"text":" provides a simplified syntax","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"for using optional values in postfix expressions."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}],"type":"paragraph"},{"code":["<#expression#>?"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The postfix "},{"type":"codeVoice","code":"?"},{"type":"text","text":" operator makes an optional-chaining expression"},{"text":" ","type":"text"},{"type":"text","text":"from an expression without changing the expression’s value."}]},{"type":"paragraph","inlineContent":[{"text":"Optional-chaining expressions must appear within a postfix expression,","type":"text"},{"type":"text","text":" "},{"text":"and they cause the postfix expression to be evaluated in a special way.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"If the value of the optional-chaining expression is "},{"code":"nil","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"all of the other operations in the postfix expression are ignored"},{"text":" ","type":"text"},{"type":"text","text":"and the entire postfix expression evaluates to "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"If the value of the optional-chaining expression isn’t "},{"type":"codeVoice","code":"nil"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"the value of the optional-chaining expression is unwrapped","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and used to evaluate the rest of the postfix expression."},{"type":"text","text":" "},{"text":"In either case,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the value of the postfix expression is still of an optional type."}]},{"inlineContent":[{"type":"text","text":"If a postfix expression that contains an optional-chaining expression"},{"text":" ","type":"text"},{"type":"text","text":"is nested inside other postfix expressions,"},{"type":"text","text":" "},{"type":"text","text":"only the outermost expression returns an optional type."},{"text":" ","type":"text"},{"type":"text","text":"In the example below,"},{"text":" ","type":"text"},{"text":"when ","type":"text"},{"code":"c","type":"codeVoice"},{"type":"text","text":" isn’t "},{"code":"nil","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"its value is unwrapped and used to evaluate "},{"type":"codeVoice","code":".property"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"the value of which is used to evaluate ","type":"text"},{"type":"codeVoice","code":".performAction()"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The entire expression "},{"type":"codeVoice","code":"c?.property.performAction()"},{"type":"text","text":" "},{"type":"text","text":"has a value of an optional type."}],"type":"paragraph"},{"code":["var c: SomeClass?","var result: Bool? = c?.property.performAction()"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"The following example shows the behavior","type":"text"},{"text":" ","type":"text"},{"text":"of the example above","type":"text"},{"type":"text","text":" "},{"text":"without using optional chaining.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["var result: Bool?","if let unwrappedC = c {","    result = unwrappedC.property.performAction()","}"]},{"inlineContent":[{"type":"text","text":"The unwrapped value of an optional-chaining expression can be modified,"},{"text":" ","type":"text"},{"type":"text","text":"either by mutating the value itself,"},{"text":" ","type":"text"},{"type":"text","text":"or by assigning to one of the value’s members."},{"type":"text","text":" "},{"text":"If the value of the optional-chaining expression is ","type":"text"},{"code":"nil","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"the expression on the right-hand side of the assignment operator"},{"text":" ","type":"text"},{"type":"text","text":"isn’t evaluated."},{"type":"text","text":" "},{"type":"text","text":"For example:"}],"type":"paragraph"},{"syntax":"swift","code":["func someFunctionWithSideEffects() -> Int {","    return 42  \/\/ No actual side effects.","}","var someDictionary = [\"a\": [1, 2, 3], \"b\": [10, 20]]","","someDictionary[\"not here\"]?[0] = someFunctionWithSideEffects()","\/\/ someFunctionWithSideEffects isn't evaluated","\/\/ someDictionary is still [\"a\": [1, 2, 3], \"b\": [10, 20]]","","someDictionary[\"a\"]?[0] = someFunctionWithSideEffects()","\/\/ someFunctionWithSideEffects is evaluated and returns 42","\/\/ someDictionary is now [\"a\": [42, 2, 3], \"b\": [10, 20]]"],"type":"codeListing"},{"name":"Grammar of an optional-chaining expression","type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"optional-chaining-expression"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"postfix-expression"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":"?","type":"codeVoice"}]}],"type":"paragraph"}]}],"kind":"content"}],"kind":"article","hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"sections":[],"abstract":[{"type":"text","text":"Access, modify, and assign values."}],"metadata":{"title":"Expressions"},"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Declarations#Function-Declaration":{"abstract":[],"title":"Function Declaration","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Function-Declaration","url":"\/documentation\/the-swift-programming-language\/declarations#Function-Declaration"},"https://developer.apple.com/documentation/swift/fileID()":{"titleInlineContent":[{"type":"codeVoice","code":"fileID()"}],"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/fileID()","type":"link","title":"fileID()","url":"https:\/\/developer.apple.com\/documentation\/swift\/fileID()"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Macros":{"abstract":[{"type":"text","text":"Use macros to generate code at compile time."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Macros","title":"Macros","url":"\/documentation\/the-swift-programming-language\/macros","role":"article","type":"topic","kind":"article"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"url":"\/documentation\/the-swift-programming-language","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language","kind":"article","role":"collection","abstract":[],"type":"topic","title":"The Swift Programming Language (5.9.2)"},"https://developer.apple.com/documentation/swift/function()":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/function()","url":"https:\/\/developer.apple.com\/documentation\/swift\/function()","type":"link","titleInlineContent":[{"type":"codeVoice","code":"function()"}],"title":"function()"},"https://developer.apple.com/documentation/swift/imported_c_and_objective_c_apis/working_with_foundation_types":{"titleInlineContent":[{"type":"text","text":"Working with Foundation Types"}],"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/imported_c_and_objective_c_apis\/working_with_foundation_types","type":"link","title":"Working with Foundation Types","url":"https:\/\/developer.apple.com\/documentation\/swift\/imported_c_and_objective_c_apis\/working_with_foundation_types"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures#Closure-Expressions":{"type":"topic","url":"\/documentation\/the-swift-programming-language\/closures#Closure-Expressions","title":"Closure Expressions","abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Closure-Expressions","kind":"section"},"https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/using_objective_c_runtime_features_in_swift","url":"https:\/\/developer.apple.com\/documentation\/swift\/using_objective_c_runtime_features_in_swift","type":"link","titleInlineContent":[{"type":"text","text":"Using Objective-C Runtime Features in Swift"}],"title":"Using Objective-C Runtime Features in Swift"},"https://help.apple.com/xcode/mac/current/#/dev4c60242fc":{"titleInlineContent":[{"type":"text","text":"Add a color, file, or image literal"}],"identifier":"https:\/\/help.apple.com\/xcode\/mac\/current\/#\/dev4c60242fc","type":"link","title":"Add a color, file, or image literal","url":"https:\/\/help.apple.com\/xcode\/mac\/current\/#\/dev4c60242fc"},"https://developer.apple.com/documentation/swift/line()":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/line()","url":"https:\/\/developer.apple.com\/documentation\/swift\/line()","type":"link","titleInlineContent":[{"type":"codeVoice","code":"line()"}],"title":"line()"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AdvancedOperators":{"abstract":[{"type":"text","text":"Define custom operators, perform bitwise operations, and use builder syntax."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators","title":"Advanced Operators","url":"\/documentation\/the-swift-programming-language\/advancedoperators","role":"article","type":"topic","kind":"article"},"https://developer.apple.com/documentation/swift/dsohandle()":{"titleInlineContent":[{"type":"codeVoice","code":"dsohandle()"}],"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/dsohandle()","type":"link","title":"dsohandle()","url":"https:\/\/developer.apple.com\/documentation\/swift\/dsohandle()"},"https://developer.apple.com/documentation/swift/file()":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/file()","url":"https:\/\/developer.apple.com\/documentation\/swift\/file()","type":"link","titleInlineContent":[{"type":"codeVoice","code":"file()"}],"title":"file()"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Expressions#Function-Call-Expression":{"type":"topic","url":"\/documentation\/the-swift-programming-language\/expressions#Function-Call-Expression","title":"Function Call Expression","abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Expressions#Function-Call-Expression","kind":"section"},"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i":{"titleInlineContent":[{"type":"text","text":"Key-Value Observing Programming Guide"}],"identifier":"https:\/\/developer.apple.com\/library\/content\/documentation\/Cocoa\/Conceptual\/KeyValueObserving\/KeyValueObserving.html#\/\/apple_ref\/doc\/uid\/10000177i","type":"link","title":"Key-Value Observing Programming Guide","url":"https:\/\/developer.apple.com\/library\/content\/documentation\/Cocoa\/Conceptual\/KeyValueObserving\/KeyValueObserving.html#\/\/apple_ref\/doc\/uid\/10000177i"},"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i":{"identifier":"https:\/\/developer.apple.com\/library\/content\/documentation\/Cocoa\/Conceptual\/KeyValueCoding\/index.html#\/\/apple_ref\/doc\/uid\/10000107i","url":"https:\/\/developer.apple.com\/library\/content\/documentation\/Cocoa\/Conceptual\/KeyValueCoding\/index.html#\/\/apple_ref\/doc\/uid\/10000107i","type":"link","titleInlineContent":[{"type":"text","text":"Key-Value Coding Programming Guide"}],"title":"Key-Value Coding Programming Guide"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures#Escaping-Closures":{"title":"Escaping Closures","abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Escaping-Closures","url":"\/documentation\/the-swift-programming-language\/closures#Escaping-Closures","type":"topic","kind":"section"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AutomaticReferenceCounting#Resolving-Strong-Reference-Cycles-for-Closures":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting#Resolving-Strong-Reference-Cycles-for-Closures","kind":"section","type":"topic","abstract":[],"title":"Resolving Strong Reference Cycles for Closures","url":"\/documentation\/the-swift-programming-language\/automaticreferencecounting#Resolving-Strong-Reference-Cycles-for-Closures"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Declarations#Protocol-Subscript-Declaration":{"kind":"section","url":"\/documentation\/the-swift-programming-language\/declarations#Protocol-Subscript-Declaration","abstract":[],"type":"topic","title":"Protocol Subscript Declaration","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Protocol-Subscript-Declaration"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions#In-Out-Parameters":{"title":"In-Out Parameters","url":"\/documentation\/the-swift-programming-language\/functions#In-Out-Parameters","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#In-Out-Parameters","abstract":[],"kind":"section","type":"topic"},"https://developer.apple.com/documentation/swift/filePath()":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/filePath()","url":"https:\/\/developer.apple.com\/documentation\/swift\/filePath()","type":"link","titleInlineContent":[{"type":"codeVoice","code":"filePath()"}],"title":"filePath()"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/BasicOperators":{"abstract":[{"type":"text","text":"Perform operations like assignment, arithmetic, and comparison."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators","title":"Basic Operators","url":"\/documentation\/the-swift-programming-language\/basicoperators","role":"article","type":"topic","kind":"article"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TypeCasting":{"role":"article","abstract":[{"type":"text","text":"Determine a value’s runtime type and give it more specific type information."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting","title":"Type Casting","type":"topic","url":"\/documentation\/the-swift-programming-language\/typecasting","kind":"article"},"https://developer.apple.com/documentation/swift/column()":{"titleInlineContent":[{"type":"codeVoice","code":"column()"}],"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/column()","type":"link","title":"column()","url":"https:\/\/developer.apple.com\/documentation\/swift\/column()"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ErrorHandling":{"role":"article","title":"Error Handling","url":"\/documentation\/the-swift-programming-language\/errorhandling","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ErrorHandling","kind":"article","type":"topic","abstract":[{"text":"Respond to and recover from errors.","type":"text"}]},"https://developer.apple.com/documentation/swift/keypath":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/keypath","url":"https:\/\/developer.apple.com\/documentation\/swift\/keypath","type":"link","titleInlineContent":[{"type":"codeVoice","code":"KeyPath"}],"title":"KeyPath"},"https://developer.apple.com/documentation/swift/operator_declarations":{"titleInlineContent":[{"type":"text","text":"Operator Declarations"}],"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","type":"link","title":"Operator Declarations","url":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Attributes":{"role":"article","url":"\/documentation\/the-swift-programming-language\/attributes","kind":"article","abstract":[{"type":"text","text":"Add information to declarations and types."}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Attributes","type":"topic","title":"Attributes"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Expressions#Implicit-Conversion-to-a-Pointer-Type":{"type":"topic","url":"\/documentation\/the-swift-programming-language\/expressions#Implicit-Conversion-to-a-Pointer-Type","title":"Implicit Conversion to a Pointer Type","abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Expressions#Implicit-Conversion-to-a-Pointer-Type","kind":"section"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/BasicOperators#Ternary-Conditional-Operator":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators#Ternary-Conditional-Operator","url":"\/documentation\/the-swift-programming-language\/basicoperators#Ternary-Conditional-Operator","abstract":[],"type":"topic","kind":"section","title":"Ternary Conditional Operator"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Declarations#Methods-with-Special-Names":{"abstract":[],"title":"Methods with Special Names","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Methods-with-Special-Names","url":"\/documentation\/the-swift-programming-language\/declarations#Methods-with-Special-Names"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Expressions#Postfix-Expressions":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Expressions#Postfix-Expressions","kind":"section","type":"topic","abstract":[],"title":"Postfix Expressions","url":"\/documentation\/the-swift-programming-language\/expressions#Postfix-Expressions"}}}